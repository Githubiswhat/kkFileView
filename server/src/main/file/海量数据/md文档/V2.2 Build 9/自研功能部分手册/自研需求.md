

# 开发者指南





### SQL参考

#### SQL语法

##### 普通表和分区表在线重建索引

**功能描述**

支持在线rebuild普通行存表索引和行存一级分区表索引，其中行存一级分区表索引包括本地分区索引和全局索引。

**语法格式**

```
ALTER INDEX index_name
REBUILD [ PARTITION partition_name ] CONCURRENTLY;

REINDEX INDEX CONCURRENTLY
index_name [ PARTITION partiotion_name ];
```

**参数说明**

- index_name：自定义的索引名称。
- CONCURRENTLY：并行的含义是不会阻塞DML和DQL语句。

**注意事项**

- 目前仅支持并行重建普通行存表和行存一级分区表。
- 支持行级一级分区表上local和global类型的主表索引重建。
- 支持行级一级分区表上local类型索引在某一特定分区上的分区索引的重建。
- 不支持行级一级分区表上global类型索引在某一特定分区上的重建。

**示例**

1、创建测试表和索引，并插入数据。

```
CREATE TABLE t_rebuild_row(id int,name varchar(20));
INSERT INTO t_rebuild_row values(1,'liuyi');
INSERT INTO t_rebuild_row values(2,'chener');
INSERT INTO t_rebuild_row values(3,'zhangsan');
INSERT INTO t_rebuild_row values(4,'lisi');
INSERT INTO t_rebuild_row values(5,'wangwu');
INSERT INTO t_rebuild_row values(6,'zhaoliu');
INSERT INTO t_rebuild_row values(7,'sunqi');
INSERT INTO t_rebuild_row values(8,'zhouba');
INSERT INTO t_rebuild_row values(9,'wujiu');
CREATE INDEX idx_row ON t_rebuild_row (id);
```

2、查看索引是否创建成功。

```
\d t_rebuild_row 
```

返回结果如下，则表示索引创建成功：

```
   Table "public.t_rebuild_row"
 Column |    Type     | Modifiers
--------+-------------+-----------
 id     | integer     |
 name   | varchar(20) |
Indexes:
    "idx_row" btree (id) TABLESPACE pg_default
```

3、设置扫描开关。

```
set enable_seqscan =off;
```

4、检查执行计划是否为索引扫描。

```
explain select /*+tablescan(t_rebuild_row) */ count(*) from t_rebuild_row where id <6;
explain select /*+indexonlyscan(t_rebuild_row idx_row )*/ count(*) from t_rebuild_row where id <6;
```

两个执行计划分别为顺序扫描及索引扫描,返回结果为：

```
                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Aggregate  (cost=1000000000111.26..1000000000111.27 rows=1 width=8)
   ->  Seq Scan on t_rebuild_row  (cost=10000000000.00..1000000000111.25 rows=3 width=0)
         Filter: (id < 6)
(3 rows)

                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Aggregate  (cost=8.31..8.32 rows=1 width=8)
   ->  Index Only Scan using idx_row on t_rebuild_row  (cost=0.00..8.30 rows=3 width=0)
         Index Cond: (id < 6)
(3 rows)

```

5、打开两个会话，会话1不断执行DML和DQL操作。

```
do language plpgsql $$    
declare    
begin    
  for i in 5..100000 loop    
    INSERT INTO t_rebuild_row values(10,'zhengshi');
     DELETE FROM t_rebuild_row WHERE id=10;
     perform name FROM t_rebuild_row WHERE id<6 order by name;
    commit;    
  end loop;    
end;    
$$;   
```

6、切换至会话2，重建索引。

```
ALTER  INDEX idx_row REBUILD concurrently;
```

或

```
REINDEX INDEX CONCURRENTLY idx_row;
```

7、会话2中执行如下命令，检查索引是否创建成功(会话1执行过程中，会话2重建索引成功，且会话1不报错)。

```
explain select /*+tablescan(t_rebuild_row) */ count(*) from t_rebuild_row where id <6;
explain select /*+indexonlyscan(t_rebuild_row idx_row )*/ count(*) from t_rebuild_row where id <6;
```

两个执行计划分别为顺序扫描及索引扫描,返回结果如下则表示索引创建成功：

```
                                QUERY PLAN
--------------------------------------------------------------------------
 Aggregate  (cost=1390.03..1390.04 rows=1 width=8)
   ->  Seq Scan on t_rebuild_row  (cost=0.00..1332.40 rows=23051 width=0)
         Filter: (id < 6)
(3 rows)


                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=2637.27..2637.28 rows=1 width=8)
   ->  Index Only Scan using idx_row on t_rebuild_row  (cost=0.00..2579.64 rows=23051 width=0)
         Index Cond: (id < 6)
(3 rows)

```

8、在会话2中执行如下命令，检查两者的结果是否相同。

```
select /*+tablescan(t_rebuild_row) */ count(*) from t_rebuild_row where id <6;
select /*+indexonlyscan(t_rebuild_row idx_row )*/ count(*) from t_rebuild_row where id <6;
```

返回结果相同，均为：

```
 count
-------
     5
(1 row)
```

9、还原扫描开关。

```
reset enable_seqscan ;
```


#####  ANALYZE和ANALYSE

**功能描述**

ANALYZE和ANALYSE用于收集与数据库中普通表内容相关的统计信息，统计结果存储在系统表PG_STATISTIC下。执行计划生成器会使用这些统计数据，以确定最有效的执行计划。

如果没有指定参数，ANALYZE会分析当前数据库中的每个表和分区表。同时也可以通过指定table_name、column和partition_name参数把分析限定在特定的表、列或分区表中。

ANALYZE VERIFY和ANALYSE VERIFY用于检测数据库中普通表（行存表、列存表）的数据文件是否损坏。

**注意事项**

- ANALYZE非临时表不能在一个匿名块、事务块、函数或存储过程内被执行。支持存储过程中ANALYZE临时表，不支持统计信息回滚操作。

- ANALYZE VERIFY 操作处理的大多为异常场景检测需要使用RELEASE版本。

- ANALYZE VERIFY 场景不触发远程读，因此远程读参数不生效。对于关键系统表出现错误被系统检测出页面损坏时，将直接报错不再继续检测。

**语法格式**

- 收集表的统计信息。

```
{ ANALYZE | ANALYSE } [ VERBOSE ] 
  [ table_name [ ( column_name [, ...] ) ] ];
```

- 收集分区表的统计信息。

```
{ ANALYZE | ANALYSE } [ VERBOSE ] 
[ table_name [ ( column_name [, ...] ) ] ] 
PARTITION ( patrition_name ) ;
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 普通分区表目前支持针对某个分区的统计信息的语法，在功能上不支持针对某个分区的统计信息收集。

- 收集多列统计信息。 

```
{ANALYZE | ANALYSE} [ VERBOSE ] 
  table_name (( column_1_name, column_2_name [, ...] ));
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> （1）收集多列统计信息时，请设置GUC参数default_statistics_target为负数，  以使用百分比采样方式。	
>
> （2）每组多列统计信息最多支持32列。
>
> （3）不支持收集多列统计信息的表：系统表。 

- 检测当前库的数据文件。

```
{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE};
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> （1）Fast模式校验时，需要对校验的表有并发的DML操作，会导致校验过程中有误报的问题，因为当前Fast模式是直接从磁盘上读取，并发有其他线程修改文件时，会导致获取的数据不准确，建议离线操作。
>
> （2）支持对全库进行操作，由于涉及的表较多，建议以重定向保存结果，命令如下所示：
>
> ```
> vsql -d database -p port -f "verify.sql"> verify_warning.txt  2>&1
> ```
>
> （3）对外提示NOTICE只核对外可见的表，内部表的检测会包含在它所依赖的外部表，不对外显示和呈现。
>
> （4）此命令的处理可容错ERROR级别的处理。由于debug版本的Assert可能会导致core无法继续执行命令，建议在release模式下操作。
>
> （5）对于全库操作时，当关键系统表出现损坏则直接报错，不再继续执行。
>
> （6）不支持临时表和unlog表。

- 检测表和索引的数据文件。

```
{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE} table_name|index_name [CASCADE];
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> （1）支持对普通表的操作和索引表的操作，但不支持对索引表index使用CASCADE操作。原因是由于CASCADE模式用于处理主表的所有索引表，当单独对索引表进行检测时，无需使用CASCADE模式。
>
> （2）不支持临时表和unlog表。
>
> （3）对于主表的检测会同步检测主表的内部表，例如toast表、cudesc表等。
>
> （4）当提示索引表损坏时，建议使用reindex命令进行重建索引操作。

- 检测表分区的数据文件。

```
{ANALYZE | ANALYSE} VERIFY {FAST|COMPLETE} table_name PARTITION {(patrition_name)}[CASCADE];
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> （1）支持对表的单独分区进行检测操作，但不支持对索引表index使用CASCADE操作。
>
> （2）不支持临时表和unlog表。
>
> （3） 全局分区索引适配支持ANALYZE VERIFY FAST。

**参数说明**

- VERBOSE：启用显示进度信息，如果指定了VERBOSE，ANALYZE发出进度信息，表明目前正在处理的表。各种有关表的统计信息也会打印出来。

- FAST|COMPLETE：对于行存表，FAST模式下主要对于行存表的CRC和page header进行校验，如果校验失败则会告警; 而COMPLETE模式下，则主要对行存表的指针、tuple进行解析校验。 对于列存表，FAST模式下主要对于列存表的CRC和magic进行校验，如果校验失败则会告警; 而COMPLETE模式下，则主要对列存表的CU进行解析校验。

- table_name：需要分析的特定表的表名（可能会带模式名），如果省略，将对数据库中的所有表（非外部表）进行分析。对于ANALYZE收集统计信息，目前仅支持行存表、列存表。

  取值范围：已有的表名。

- index_name需要分析的特定索引表的表名（可能会带模式名）。

  取值范围：已有的表名。

- CASCADE：CASCADE模式下会对当前表的所有索引进行检测处理。

- partition_name：如果table为分区表，在关键字PARTITION后面指定分区名partition_name表示分析该分区表的统计信息。目前语法上支持分区表做ANALYZE，但功能实现上暂不支持对指定分区统计信息的分析。

  取值范围：表的某一个分区名。

**示例**

1、创建测试表。

```
CREATE TABLE customer_info 
( 
WR_RETURNED_DATE_SK    INTEGER            , 
WR_RETURNED_TIME_SK    INTEGER            , 
WR_ITEM_SK         INTEGER        NOT NULL, 
WR_REFUNDED_CUSTOMER_SK  INTEGER 
) ;
```

2、创建分区表。

```
CREATE TABLE customer_par 
( 
WR_RETURNED_DATE_SK    INTEGER            , 
WR_RETURNED_TIME_SK    INTEGER            , 
WR_ITEM_SK         INTEGER        NOT NULL, 
WR_REFUNDED_CUSTOMER_SK  INTEGER 
) 
PARTITION BY RANGE(WR_RETURNED_DATE_SK) 
( 
PARTITION P1 VALUES LESS THAN(2452275), 
PARTITION P2 VALUES LESS THAN(2452640), 
PARTITION P3 VALUES LESS THAN(2453000), 
PARTITION P4 VALUES LESS THAN(MAXVALUE) 
) 
ENABLE ROW MOVEMENT;
```

3、使用ANALYZE语句更新统计信息。

```
ANALYZE customer_info;
```

4、使用ANALYZE VERBOSE语句更新统计信息，并输出表的相关信息。

```
ANALYZE VERBOSE customer_info; 
```

返回结果为：

```
INFO:  analyzing "public.customer_info"(node1 pid=336454)
INFO:  ANALYZE INFO : "customer_info": scanned 0 of 0 pages, containing 0 live rows and 0 dead rows; 0 rows in sample, 0 estimated total rows(node1 pid=336454)
ANALYZE
```

5、删除表。

```
DROP TABLE customer_info; 
DROP TABLE customer_par;
```

##### SQL并行查询

**功能描述**

一条查询语句在所涉及的表中的数据量达到阈值时，由规划器生成的计划去执行扫描时性能会比较差。因此需要使用多个worker线程并行各自去执行扫描表操作，在Vastbase G100 V2.2版本中支持[并行顺序扫描](#并行顺序扫描)、[并行嵌套查询](#并行嵌套查询)、[并行哈希连接](#并行哈希连接)、[并行索引扫描](#并行索引扫描)。


###### 并行顺序扫描<a id="并行顺序扫描"></a>

**功能描述**

并行顺序扫描就是利用多核CPU的并行处理能力，将一个表的顺序查询语句由多个并行worker线程去执行查询操作。

**注意事项**

- 不支持临时表、外表、分区表、非行存表的并行查询。
- 不支持CET查询，并行join，并行子查询等。

**示例**

1、创建测试表test并插入数据。

```
create table test(id int,name text,age int);
insert into test values(generate_series(1,1000000),'vastbase',34);
```

2、指定分析表test。

```
analyze test;
```

3、设置并行度。

```
set query_dop=5;
```

4、打印并行查询计划。

```
explain select count(*) from test where id<100;
```

返回结果如下，则表示支持该功能：

```
                                      QUERY PLAN                                 
     
---------------------------------------------------------------------------------
-----
 Aggregate  (cost=8100.25..8100.26 rows=1 width=8)
   ->  Streaming(type: LOCAL GATHER dop: 1/5)  (cost=8100.25..8100.26 rows=1 widt
h=8)
         ->  Aggregate  (cost=8100.25..8100.26 rows=1 width=8)
               ->  Seq Scan on test  (cost=0.00..8100.00 rows=100 width=0)
                     Filter: (id < 100)
(5 rows)
```

###### 并行索引扫描<a id="并行索引扫描"></a>

**功能描述**

并行索引扫描就是利用多核CPU的并行处理能力，索引查询可以由多个并行worker线程执行。

当一条sql语句的条件子句中涉及的属性是索引时，查询编译器就会生成并行索引扫描路径，根据代价估算得到并行索引扫描计划，执行器在选择扫描计划时，会将索引扫描计划分给多个worker来执行。

**注意事项**

- 不支持临时表、外表、分区表、非行存表的并行查询。
- 不支持CET查询。
- 只支持并行btree索引扫描，bitmap，gin，gist等索引查询不支持。

**示例**

1、创建测试表并插入数据。

```
create table parallel_t2(a int,b int);
insert into parallel_t2 values(generate_series(1,100000), generate_series(1,100000));
```

2、创建btree索引。

```
create index t2_idx on parallel_t2 using btree(a);
```

3、设置扫描开关和并行代价。

```
set enable_seqscan to off;
set enable_bitmapscan to off;
```

4、.打印并行执行计划。

```
explain (costs off) select count(b) from parallel_t2 where a > 5000;
```

返回结果为：

```
                  QUERY PLAN
----------------------------------------------
 Aggregate
   ->  Index Scan using t2_idx on parallel_t2
         Index Cond: (a > 5000)
(3 rows)
```

```
explain (costs off) select count(b) from parallel_t2 where a < 5000;
```

返回结果为：

```
                  QUERY PLAN
----------------------------------------------
 Aggregate
   ->  Index Scan using t2_idx on parallel_t2
         Index Cond: (a < 5000)
(3 rows)
```

5、执行查询。

```
select count(b) from parallel_t2 where a > 5000;
```

返回结果为：

```
 count
-------
 95000
(1 row)
```

```
select count(b) from parallel_t2 where a < 5000;
```

返回结果为：

```
 count
-------
  4999
(1 row)
```

###### 并行嵌套查询<a id="并行嵌套查询"></a>

**功能描述**

并行嵌套查询就是利用多核CPU的并行处理能力，将一个多表连接查询语句由多个并行worker线程执行。

**注意事项**

- 不支持临时表、外表、分区表、非行存表的并行查询。
- 不支持CET查询，并行子查询等。

**示例**

1、创建测试表并插入数据。

```
create table test_a (id int, col varchar(20));
create table test_b (id int, col int);
create table t3(id int, id2 int, id3 int);
insert into test_a  values(generate_series(1,200000), 'xiaohong');
insert into test_b  values(generate_series(100,200000), 20);
insert into t3 values(generate_series(1, 200000), generate_series(1, 100), generate_series(1, 10));
```

2、设置并行开关。

```
set enable_nestloop=on;
set enable_mergejoin=off;
set enable_hashjoin=off;
set query_dop=2;
```

3、打印嵌套循环并行查询计划。

```
explain (costs off) 
select col from test_a where id in (select id from test_b where id in (select id from t3));
```

返回结果为：

```
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Streaming(type: LOCAL GATHER dop: 1/2)
   ->  Nested Loop Semi Join
         Join Filter: (test_a.id = test_b.id)
         ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
               ->  Seq Scan on test_a
         ->  Materialize
               ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                     ->  Nested Loop Semi Join
                           Join Filter: (test_b.id = t3.id)
                           ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                 ->  Seq Scan on test_b
                           ->  Materialize
                                 ->  Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                       ->  Seq Scan on t3
(14 rows)
```

###### 并行哈希连接<a id="并行哈希连接"></a>

**功能描述**

并行哈希连接是利用多核CPU的并行处理能力，将一个生成哈希连接的执行计划由多个Worker执行。一个表连接语句规划器会生成哈希连接计划，并行哈希连接功能是执行器在执行时，将哈希连接的操作由多个Worker并行执行完成。

**注意事项**

- 不支持临时表、外表、分区表、非行存表的并行查询。
- 不支持CET查询，并行子查询等。

**示例**

1、创建两张表。

```
create table parallel_hashjoin_test_a (id int);
create table parallel_hashjoin_test_b (id int);
```

2、插入数据。

```
insert into parallel_hashjoin_test_a select n from generate_series(1,1000) n;
insert into parallel_hashjoin_test_b select n from generate_series(1,10) n;
```

3、收集两张表的统计信息。

```
analyse parallel_hashjoin_test_a;
analyse parallel_hashjoin_test_b;
```

4、打印两张表连接查询的查询计划。

```
explain (costs off) select * from parallel_hashjoin_test_a left outer join parallel_hashjoin_test_b on parallel_hashjoin_test_a.id = parallel_hashjoin_test_b.id where parallel_hashjoin_test_a.id < 10 order by parallel_hashjoin_test_a.id;
```

返回结果如下，则表示支持该功能：

```
                                   QUERY PLAN
--------------------------------------------------------------------------------
 Sort
   Sort Key: parallel_hashjoin_test_a.id
   ->  Hash Left Join
         Hash Cond: (parallel_hashjoin_test_a.id = parallel_hashjoin_test_b.id)
         ->  Seq Scan on parallel_hashjoin_test_a
               Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on parallel_hashjoin_test_b
(8 rows)
```

5、执行两张表连接查询。

```
select * from parallel_hashjoin_test_a left outer join parallel_hashjoin_test_b on parallel_hashjoin_test_a.id = parallel_hashjoin_test_b.id where parallel_hashjoin_test_a.id < 10 order by parallel_hashjoin_test_a.id;
```

返回结果为:

```
 id | id
----+----
  1 |  1
  2 |  2
  3 |  3
  4 |  4
  5 |  5
  6 |  6
  7 |  7
  8 |  8
  9 |  9
(9 rows)
```

##### 聚合函数嵌套

**功能描述**

Vastbase支持聚合函数嵌套使用。其中内层聚合函数用于计算通过group by子句定义的分组的聚合结果，再将内层聚合函数返回的结果集使用外层聚合函数再进行一次聚合计算，从而返回整体的结果。

**语法格式**

```
aggregate_name1(aggregate_name2(expression[,…][order_by_clause]))
aggregate_name1(aggregate_name2(ALL expression [,…][order_by_clause]))
aggregate_name1(aggregate_name2(DISTINCT expression[,…][order_by_clause]))
aggregate_name1(aggregate_name2(*))
aggregate_name1(aggregate_name2([expression[,…]]))
```

**参数说明**

- aggregate_name1：预定义的聚合函数名称1，内层函数。
- aggregate_name2：预定义的聚合函数名称2，外层函数。
- expression：自身不包含聚合函数表达式的任意值表达式。

**注意事项**

聚合函数嵌套的用法约束有如下限制：

- 必须含有group by子句，否则报错。例如：

```
select avg(max(salary)) from empsalary;
```

- 查询列中同时包括嵌套聚合函数和非嵌套聚合函数时报错。例如：

```
select avg(max(salary)),max(salary) from empsalary group by department_id;
```

- 查询列中同时包括嵌套聚合函数和一般列时报错。例如：

```
select avg(max(salary)),salary from empsalary group by department_id;
```

**示例**

1、创建测试表empsalary。

```
create table empsalary (
depname  varchar,
empno  int,
salary int
);
```

2、插入数据。

```
insert into empsalary values('develop',10,5200);
insert into empsalary values('develop',10,5200);
insert into empsalary values('saleseeee',10,5000);
insert into empsalary values('personnel11',5,500);
insert into empsalary values('personnel11',5,500);
insert into empsalary values('personnel11',5,500);
insert into empsalary values('personnel1',5,500);
insert into empsalary values('sales',1,5200);
insert into empsalary values('sales',1,5200);
insert into empsalary values('selaseee',1,5000);
```

3、调用聚合嵌套函数1。

```
select max(max(Empno)),max(sum(salary)) from empsalary group by depname;
```

返回结果如下，则表示调用成功：

```
max | max
-----------
10  | 10400
(1 row)
```

4、调用聚合嵌套函数2。

```
select max(sum(Empno)),max(sum(salary)) from empsalary group by depname;
```

返回结果如下，则表示调用成功：

```
 max |  max  
-----+-------
  20 | 10400
(1 row)
```

##### list分区键值支持127列

**功能描述**

  list分区中分区键从支持64列提升到127列。

**注意事项**

分区键值不能超过127列。

**示例**

```
create table t_list(col1 int)
partition by list(col1)( 
partition p1 values(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128),
partition p2 values( 133));
```

报错显示如下：

```
ERROR:  too many partition keys, allowed is 127
```



##### ALTER ROLE

**功能描述**

修改角色属性。

**语法格式**

- 修改角色的权限。

```
ALTER ROLE role_name [ [ WITH ] option [ ... ] ];
```

其中权限项子句option为：

```
  {CREATEDB | NOCREATEDB}
      | {CREATEROLE | NOCREATEROLE}
      | {INHERIT | NOINHERIT}
      | {AUDITADMIN | NOAUDITADMIN}
      | {SYSADMIN | NOSYSADMIN}
      | {MONADMIN | NOMONADMIN}
      | {OPRADMIN | NOOPRADMIN}
      | {POLADMIN | NOPOLADMIN}
      | {USEFT | NOUSEFT}
      | {LOGIN | NOLOGIN}
      | {REPLICATION | NOREPLICATION}
      | {INDEPENDENT | NOINDEPENDENT}
      | {VCADMIN | NOVCADMIN}
      | {PERSISTENCE | NOPERSISTENCE}
      | CONNECTION LIMIT connlimit
      | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password' [EXPIRED]
      | [ ENCRYPTED | UNENCRYPTED ] IDENTIFIED BY 'password' [ REPLACE 'old_password' | EXPIRED ]
      | VALID BEGIN 'timestamp'
      | VALID UNTIL 'timestamp'
      | RESOURCE POOL 'respool'
      | USER GROUP 'groupuser'
      | PERM SPACE 'spacelimit'
      | TEMP SPACE 'tmpspacelimit'
      | SPILL SPACE 'spillspacelimit'
      | NODE GROUP logic_cluster_name
      | ACCOUNT { LOCK | UNLOCK }
      | PGUSER
```

- 修改角色的名称。

```
ALTER ROLE role_name 
    RENAME TO new_name;
```

- 锁定或解锁。

```
ALTER ROLE role_name 
    ACCOUNT { LOCK | UNLOCK };
```

- 设置角色的配置参数。

```
ALTER ROLE role_name [ IN DATABASE database_name ]
  SET configuration_parameter {{ TO | = } { value | DEFAULT } | FROM CURRENT};
```

- 重置角色的配置参数。

```
ALTER ROLE role_name
    [ IN DATABASE database_name ] RESET {configuration_parameter|ALL};
```

**参数说明**

- role_name：现有角色名。

  取值范围：已存在的用户名。

- IN DATABASE database_name：表示修改角色在指定数据库上的参数。

- SET configuration_parameter：设置角色的参数。ALTER ROLE中修改的会话参数只针对指定的角色，且在下一次该角色启动的会话中有效。

  取值范围：configuration_parameter和value的取值请参见章节“SET”

  - DEFAULT：表示清除configuration_parameter参数的值，configuration_parameter参数的值将继承本角色新产生的SESSION的默认值。
  - FROM CURRENT：取当前会话中的值设置为configuration_parameter参数的值。
  
- RESET configuration_parameter/ALL：清除configuration_parameter参数的值。与SET configuration_parameter TO DEFAULT的效果相同。

  取值范围：ALL表示清除所有参数的值。

- ACCOUNT LOCK | ACCOUNT UNLOCK：

  - ACCOUNT LOCK：锁定帐户，禁止登录数据库。
  - ACCOUNT UNLOCK：解锁帐户，允许登录数据库。

- PGUSER：当前版本不允许修改角色的PGUSER属性。

- PASSWORD/IDENTIFIED BY 'password'：重置或修改用户密码。除了初始用户外其他管理员或普通用户修改自己的密码需要输入正确的旧密码。只有初始用户、系统管理员（sysadmin）或拥有创建用户（CREATEROLE）权限的用户才可以重置普通用户密码，无需输入旧密码。初始用户可以重置系统管理员的密码，系统管理员不允许重置其他系统管理员的密码。

- EXPIRED：设置密码失效。只有初始用户、系统管理员（sysadmin）或拥有创建用户（CREATEROLE）权限的用户才可以设置用户密码失效，其中系统管理员也可以设置自己或其他系统管理员密码失效。不允许设置初始用户密码失效。密码失效的用户可以登录数据库但不能执行查询操作，只有修改密码或由管理员重置密码后才可以恢复正常查询操作。


其他参数请参见“CREATE ROLE”的参数说明部分。

**注意事项**

只允许修改用户的标识，但是不允许修改属性标识。

**示例**

- 修改角色manager的密码为abcd@123。 

```
ALTER ROLE manager IDENTIFIED BY 'abcd@123' REPLACE 'Bigdata@123';
```

- 修改角色manager为系统管理员。 

```
ALTER ROLE manager SYSADMIN; 
```

##### DROP ROLE

**功能描述**

删除指定的角色。

**语法格式**

```
DROP ROLE [ IF EXISTS ] role_name [, ...];
```

**参数说明**

- IF EXISTS：如果指定的角色不存在，则发出一个notice而不是抛出一个错误。

- role_name：要删除的角色名称。

  取值范围：已存在的角色。

**注意事项**

只允许删除同类型管理员属性的用户。

**示例**

1、创建测试用户utest。

```
CREATE ROLE utest IDENTIFIED BY 'Bigdata@123';
```

2、删除测试用户。

```
DROP ROLE utest;
```



##### START TRANSACTION

**功能描述**

通过START TRANSACTION启动事务。如果声明了隔离级别、读写模式，那么新事务就使用这些特性，类似执行了SET TRANSACTION。

**语法格式**

格式一：START TRANSACTION格式

```
START TRANSACTION
   [ { ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ  }
   | { READ WRITE | READ ONLY }
   } [, ...] ];
```

格式二：BEGIN格式

```
BEGIN [ WORK | TRANSACTION ]
  [ { ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ }
  | { READ WRITE | READ ONLY }
  } [, ...] ];
```

**参数说明**

- WORK | TRANSACTIONBEGIN：格式中的可选关键字，没有实际作用。

- ISOLATION LEVEL：指定事务隔离级别，它决定当一个事务中存在其他并发运行事务时它能够看到什么数据。

  > <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
  > 在事务中第一个数据修改语句（SELECT、 INSERT、DELETE、UPDATE、FETCH、COPY）执行之后，事务隔离级别就不能再次设置。
  
  取值范围：

  - READ COMMITTED：读已提交隔离级别，只能读到已经提交的数据，而不会读到未提交的数据。这是缺省值。
  - READ UNCOMMITTED：读未提交隔离级别，也就是说事务所作的修改在未提交前，其他并发事务是可以读到的。
  - REPEATABLE READ：可重复读隔离级别，仅仅看到事务开始之前提交的数据，它不能看到未提交的数据，以及在事务执行期间由其它并发事务提交的修改。
  - SERIALIZABLE：Vastbase目前功能上不支持此隔离级别，等价于REPEATABLE READ。
  
- READ WRITE | READ ONLY：指定事务访问模式（读/写或者只读）。

**注意事项**

无。

**示例**

1、创建测试表test。

```
CREATE TABLE test(id int);
```

2、以不同方式启动事务

- 以默认方式（START TRANSACTION）启动事务，并在操作后提交。 

```
START TRANSACTION; 
SELECT * FROM test;
END; 
```

- 以默认方式（BEGIN）启动事务，并在操作后提交。 


```
BEGIN; 
SELECT * FROM test; 
END; 
```

- 以隔离级别为READ COMMITTED，读/写方式启动事务，并在操作后提交。 


```
START TRANSACTION ISOLATION LEVEL READ COMMITTED READ WRITE; 
SELECT * FROM test; 
COMMIT;
```

3、删除测试表

```
DROP TABLE test;
```

##### BEGIN

**功能描述**

BEGIN可以用于开始一个匿名块，也可以用于开始一个事务。本节描述用BEGIN开始匿名块的语法，以BEGIN开始事务的语法见章节“START TRANSACTION”

**语法格式**

开启匿名块：

```
[DECLARE [declare_statements]] 
BEGIN
execution_statements  
END;
/
```

**参数说明**

- declare_statements：声明变量，包括变量名和变量类型，如“sales_cnt int”。

- execution_statements：匿名块中要执行的语句。

  取值范围：DML操作(数据操纵操作：select、insert、delete、update)或系统表中已注册的函数名称。

**注意事项**

无。

**示例**

1. 创建测试表test。

```
CREATE TABLE test(id int);
```

2. 执行匿名块

```
BEGIN
for i in 0..10 LOOP
INSERT INTO test(id) values (i);
END LOOP;
END;
/
```

3. 验证结果

```
select * from test;
```

当结果显示如下信息，则表示匿名块执行完成。

```
 id 
------------------
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(11 rows)
```

4. 删除测试表

```
DROP TABLE test;
```

##### SET TRANSACTION

**功能描述**

为事务设置特性。事务特性包括事务隔离级别、事务访问模式(读/写或者只读)。可以设置当前事务的特性（LOCAL)，也可以设置会话的默认事务特性(SESSION)。

**语法格式**

设置事务的隔离级别、读写模式。

```
{ SET [ LOCAL ] TRANSACTION|SET SESSION CHARACTERISTICS AS TRANSACTION }
  { ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ  }
  | { READ WRITE | READ ONLY } } [, ...]
```

**参数说明**

- LOCAL：声明该命令只在当前事务中有效。

- SESSION：声明这个命令只对当前会话起作用。

  取值范围：字符串，要符合标识符的命名规范。

- ISOLATION_LEVEL：指定事务隔离级别，该参数决定当一个事务中存在其他并发运行事务时能够看到什么数据。

  > <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
  >
  > 在事务中第一个数据修改语句（SELECT、INSERT、DELETE、UPDATE、FETCH、COPY)执行之后，当前事务的隔离级别就不能再次设置。
  
  取值范围：

  - READ COMMITTED：读已提交隔离级别，只能读到已经提交的数据，而不会读到未提交的数据。这是缺省值。
  - READ UNCOMMITTED：读未提交隔离级别，也就是说事务所作的修改在未提交前，其他并发事务是可以读到的。
  - REPEATABLE READ：可重复读隔离级别，仅仅能看到事务开始之前提交的数据，不能看到未提交的数据，以及在事务执行期间由其它并发事务提交的修改。
  - SERIALIZABLE：Vastbase目前功能上不支持此隔离级别，等价于REPEATABLE READ。
  
- READ WRITE | READ ONLY：指定事务访问模式（读/写或者只读）。


**注意事项**

设置当前事务特性需要在事务中执行（即执行SET TRANSACTION之前需要执行START TRANSACTION或者BEGIN），否则设置不生效。

**示例**

开启一个事务，设置事务的隔离级别为READ COMMITTED，访问模式为READ ONLY。 

```
START TRANSACTION; 
SET LOCAL TRANSACTION ISOLATION LEVEL READ COMMITTED READ ONLY; 
COMMIT;
```

##### COMMIT | END

**功能描述**

通过COMMIT或者END可完成提交事务的功能，即提交事务的所有操作。

**语法格式**

```
{ COMMIT | END } [ WORK | TRANSACTION ] ;
```

**参数说明**

- COMMIT | END：提交当前事务，让所有当前事务的更改为其他事务可见。

- WORK | TRANSACTION：可选关键字，除了增加可读性没有其他任何作用。

**注意事项**

无。

**示例**

1. 创建表。 

```
CREATE TABLE customer_demographics_t2 
   ( 
     CD_DEMO_SK         INTEGER        NOT NULL, 
     CD_GENDER         CHAR(1), 
     CD_MARITAL_STATUS     CHAR(1), 
     CD_EDUCATION_STATUS    CHAR(20), 
     CD_PURCHASE_ESTIMATE    INTEGER, 
     CD_CREDIT_RATING      CHAR(10), 
     CD_DEP_COUNT        INTEGER, 
     CD_DEP_EMPLOYED_COUNT   INTEGER, 
     CD_DEP_COLLEGE_COUNT    INTEGER 
   ) 
   WITH (ORIENTATION = COLUMN,COMPRESSION=MIDDLE) 
   ; 
```

2. 开启事务。 

```
START TRANSACTION; 
```

3. 插入数据。 

```
INSERT INTO customer_demographics_t2 VALUES(1,'M', 'U', 'DOCTOR DEGREE', 1200, 'GOOD', 1, 0, 0); 
INSERT INTO customer_demographics_t2 VALUES(2,'F', 'U', 'MASTER DEGREE', 300, 'BAD', 1, 0, 0); 
```

4. 提交事务，让所有更改永久化。 

```
COMMIT; 
```

5. 新建连接查询数据。 

```
SELECT * FROM customer_demographics_t2; 
```

当结果显示如下信息时，则表示事务提交成功。
```
cd_demo_sk | cd_gender | cd_marital_status | cd_education_status  |      cd_purchase_estimate | cd_credi
t_rating | cd_dep_count | cd_dep_employed_count |          cd_dep_college_count 
------------+-----------+-------------------+----------------------+----------------------+---------
---------+--------------+-----------------------+----------------------
          1 | M         | U                 | DOCTOR DEGREE        |                    1200 | GOOD    
         |            1 |                     0 |                    0
          2 | F         | U                 | MASTER DEGREE        |                     300 | BAD     
         |            1 |                     0 |                       0
(2 rows)
```
6. 删除表customer_demographics_t2。 

```
DROP TABLE customer_demographics_t2;
```

   

##### ROLLBACK

**功能描述**

回滚当前事务并取消当前事务中的所有更新。

在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，数据库状态回到事务开始前。

**语法格式**

```
ROLLBACK [ WORK | TRANSACTION ];
```

**参数说明**

WORK | TRANSACTION：可选关键字。除了增加可读性，没有任何其他作用。

**注意事项**

无。

**示例**

1. 创建测试表test。

```
CREATE TABLE test(id int);
```

2. 开启一个事务 。

```
START TRANSACTION; 
```

3. 插入数据。

```
INSERT INTO test(id) VALUES(1);
```

4. 查询当前数据。

```
select * from test;
```

当结果显示如下信息，则表示插入成功。

```
 id 
----
  1
(1 row)
```

5. 取消所有更改 。

```
ROLLBACK;
```

6. 查询数据进行验证。

```
select * from test;
```

当结果显示如下信息，则表示回滚成功。

```
id 
----
(0 rows)
```

   

##### CREATE ROLE

**功能描述**

创建角色。角色是拥有数据库对象和权限的实体。在不同的环境中角色可以认为是一个用户，一个组或者兼顾两者。

**语法格式**

```
CREATE ROLE role_name [ [ WITH ] option [ ... ] ] [ ENCRYPTED | UNENCRYPTED ] { PASSWORD | IDENTIFIED BY } { 'password' | DISABLE };
```

其中角色信息设置子句option语法为：

```
{SYSADMIN | NOSYSADMIN}
    | {MONADMIN | NOMONADMIN}
    | {OPRADMIN | NOOPRADMIN}
    | {POLADMIN | NOPOLADMIN}
    | {AUDITADMIN | NOAUDITADMIN}
    | {SSOADMIN | NOSSOADMIN}
    | {CREATEDB | NOCREATEDB}
    | {USEFT | NOUSEFT}
    | {CREATEROLE | NOCREATEROLE}
    | {INHERIT | NOINHERIT}
    | {LOGIN | NOLOGIN}
    | {REPLICATION | NOREPLICATION}
    | {INDEPENDENT | NOINDEPENDENT}
    | {VCADMIN | NOVCADMIN}
    | {PERSISTENCE | NOPERSISTENCE}
    | CONNECTION LIMIT connlimit
    | VALID BEGIN 'timestamp'
    | VALID UNTIL 'timestamp'
    | RESOURCE POOL 'respool'
    | PERM SPACE 'spacelimit'
    | TEMP SPACE 'tmpspacelimit'
    | SPILL SPACE 'spillspacelimit'
    | IN ROLE role_name [, ...]
    | IN GROUP role_name [, ...]
    | ROLE role_name [, ...]
    | ADMIN rol e_name [, ...]
    | USER role_name [, ...]
    | SYSID uid
    | DEFAULT TABLESPACE tablespace_name
    | PROFILE DEFAULT
    | PROFILE profile_name
    | PGUSER
```

**参数说明**

- role_name：角色名称

  取值范围：字符串，要符合标识符的命名规范，且最多为63个字符。若超过63个字符，数据库会截断并保留前63个字符当做角色名称。在创建角色时，数据库的时候会给出提示信息。

  >  <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
  >
  > 标识符需要为字母、下划线、数字（0-9）或美元符号（$），且必须以字母（a-z）或下划线（_)开头。

- password：登录密码

  密码规则如下：

  - 密码默认不少于8个字符。
  - 不能与用户名及用户名倒序相同。
  - 至少包含大写字母（A-Z）、小写字母（a-z）、数字（0-9）、非字母数字字符（限定为~!@#$%^&*()-_=+\|[{}];:,<.>/?）四类字符中的三类字符。
  - 密码也可以是符合格式要求的密文字符串，这种情况主要用于用户数据导入场景，不推荐用户直接使用。如果直接使用密文密码，用户需要知道密文密码对应的明文，并且保证明文密码复杂度，数据库不会校验密文密码复杂度，直接使用密文密码的安全性由用户保证。
  - 创建角色时，应当使用双引号或单引号将用户密码括起来。

  取值范围：不为空的字符串。

- EXPIRED：在创建用户时可指定EXPIRED参数，即创建密码失效用户，该用户不允许执行简单查询和扩展查询。只有在修改自身密码后才可正常执行语句。

- DISABLE：默认情况下，用户可以更改自己的密码，除非密码被禁用。要禁用用户的密码，请指定DISABLE。禁用某个用户的密码后，将从系统中删除该密码，此类用户只能通过外部认证来连接数据库，例如：kerberos认证。只有管理员才能启用或禁用密码。普通用户不能禁用初始用户的密码。要启用密码，请运行ALTER USER并指定密码。

- ENCRYPTED | UNENCRYPTED：控制密码存储在系统表里的口令是否加密。按照产品安全要求，密码必须加密存储，所以，UNENCRYPTED在Vastbase中禁止使用。因为系统无法对指定的加密口令字符串进行解密，所以如果目前的口令字符串已经是用SHA256加密的格式，则会继续照此存放，而不管是否声明了ENCRYPTED或UNENCRYPTED。这样就允许在dump/restore的时候重新加载加密的口令。

- SYSADMIN | NOSYSADMIN：决定一个新角色是否为“系统管理员”，具有SYSADMIN属性的角色拥有系统最高权限。

  缺省为NOSYSADMIN。

- MONADMIN | NOMONADMIN：定义角色是否是监控管理员。

  缺省为NOMONADMIN。

- OPRADMIN | NOOPRADMIN：定义角色是否是运维管理员。

  缺省为NOOPRADMIN。

- POLADMIN | NOPOLADMIN：定义角色是否是安全策略管理员。

  缺省为NOPOLADMIN。

- SSOADMIN | NOSSOADMIN：定义角色是否有安全管理属性。

  缺省为NOSSOADMIN。

- AUDITADMIN | NOAUDITADMIN：定义角色是否有审计管理属性。

  缺省为NOAUDITADMIN。

- CREATEDB | NOCREATEDB：决定一个新角色是否能创建数据库。新角色没有创建数据库的权限。

  缺省为NOCREATEDB。

- USEFT | NOUSEFT：该参数为保留参数，暂未启用。

- CREATEROLE | NOCREATEROLE：决定一个角色是否可以创建新角色（也就是执行CREATE ROLE和CREATE USER）。 一个拥有CREATEROLE权限的角色也可以修改和删除其他角色。

  缺省为NOCREATEROLE。

- INHERIT | NOINHERIT：这些子句决定一个角色是否“继承”它所在组的角色的权限。不推荐使用。

- LOGIN | NOLOGIN：具有LOGIN属性的角色才可以登录数据库。一个拥有LOGIN属性的角色可以认为是一个用户。

  缺省为NOLOGIN。

- REPLICATION | NOREPLICATION：定义角色是否允许流复制或设置系统为备份模式。REPLICATION属性是特定的角色，仅用于复制。

  缺省为NOREPLICATION。

- INDEPENDENT | NOINDEPENDENT：定义私有、独立的角色。具有INDEPENDENT属性的角色，管理员对其进行的控制、访问的权限被分离，具体规则如下：

  - 未经INDEPENDENT角色授权，系统管理员无权对其表对象进行增、删、查、改、拷贝、授权操作。
  - 若将私有用户表的相关权限授予其他非私有用户，系统管理员也会获得同样的权限。
  - 未经INDEPENDENT角色授权，系统管理员和拥有CREATEROLE属性的安全管理员无权修改INDEPENDENT角色的继承关系。
  - 系统管理员无权修改INDEPENDENT角色的表对象的属主。
  - 系统管理员和拥有CREATEROLE属性的安全管理员无权去除INDEPENDENT角色的INDEPENDENT属性。
  - 系统管理员和拥有CREATEROLE属性的安全管理员无权修改INDEPENDENT角色的数据库口令，INDEPENDENT角色需管理好自身口令，口令丢失无法重置。
  - 管理员属性用户不允许定义修改为INDEPENDENT属性。
  
- VCADMIN | NOVCADMIN：该版本没有实际意义。

- PERSISTENCE | NOPERSISTENCE：定义永久用户。仅允许初始用户创建、修改和删除具有PERSISTENCE属性的永久用户。

- CONNECTION LIMIT：声明该角色可以使用的并发连接数量。

  > <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
  > - 系统管理员不受此参数的限制。
  > - connlimit数据库主节点单独统计，Vastbase整体的连接数 = connlimit * 当前正常数据库主节点个数。

  取值范围：整数，>=-1，缺省值为100，-1表示没有限制。

- VALID BEGIN：设置角色生效的时间戳。如果省略了该子句，角色无有效开始时间限制。

- VALID UNTIL：设置角色失效的时间戳。如果省略了该子句，角色无有效结束时间限制。

- RESOURCE POOL：设置角色使用的resource pool名称，该名称属于系统表：pg_resource_pool。

- PERM SPACE：设置用户使用空间的大小。

- TEMP SPACE：设置用户临时表存储空间限额。

- SPILL SPACE：设置用户算子落盘空间限额。

- IN ROLE：新角色立即拥有IN ROLE子句中列出的一个或多个现有角色拥有的权限。不推荐使用。

- IN GROUP：IN GROUP是IN ROLE过时的拼法。不推荐使用。

- ROLE：ROLE子句列出一个或多个现有的角色，它们将自动添加为这个新角色的成员，拥有新角色所有的权限。

- ADMIN：ADMIN子句类似ROLE子句，不同的是ADMIN后的角色可以把新角色的权限赋给其他角色。

- USER：USER子句是ROLE子句过时的拼法。

- SYSID：SYSID子句将被忽略，无实际意义。

- DEFAULT TABLESPACE：DEFAULT TABLESPACE子句将被忽略，无实际意义。

- PROFILE：PROFILE子句将被忽略，无实际意义。

- PGUSER：当前版本该属性没有实际意义，仅为了语法的前向兼容而保留。

**注意事项**

- 在数据库中添加一个新角色，角色无登录权限。
- 创建角色的用户必须具备CREATE ROLE的权限或者是系统管理员。
- 只允许创建相同属性的管理员用户。

**示例**

- 创建一个角色，名为manager，密码为Bigdata@123。 

```
CREATE ROLE manager IDENTIFIED BY 'Bigdata@123'; 
```

- 创建一个角色，从2015年1月1日开始生效，到2026年1月1日失效。 

```
CREATE ROLE miriam WITH LOGIN PASSWORD 'Bigdata@123' VALID BEGIN '2015-01-01' VALID UNTIL '2026-01-01'; 
```

- 修改角色manager的密码为abcd@123。 

```
ALTER ROLE manager IDENTIFIED BY 'abcd@123' REPLACE 'Bigdata@123';
```

- 修改角色manager为系统管理员。 

```
ALTER ROLE manager SYSADMIN; 
```

- 删除角色manager。 

```
DROP ROLE manager; 
```

- 删除角色miriam。 

```
DROP ROLE miriam;
```

##### SELECT

**功能描述**

SELECT用于从表或视图中查询数据。

SELECT语句就像叠加在数据库表上的过滤器，利用SQL关键字从数据表中过滤出用户需要的数据。

**注意事项**

- 需要对每个在SELECT命令中使用的字段具有SELECT权限。
- 使用FOR UPDATE，FOR NO KEY UPDATE，FOR SHARE或FOR KEY SHARE还要求UPDATE权限。

**语法格式**

- 查询数据

```
[ WITH [ RECURSIVE ] with_query [, ...] ]
SELECT [/*+ plan_hint */] [ ALL | DISTINCT [ ON ( expression[, ...] ) ] ]
{ * | {expression [ [ AS ] output_name ]} [, ...] }
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [, ...] ]
[ HAVING condition [, ...] ]
[ WINDOW {window_name AS ( window_definition )} [, ...] ]
[ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ]
[ ORDER BY {expression [ [ ASC | DESC | USING operator ] |nlssort_expression_clause ] [ NULLS { FIRST | LAST } ]} [, ...]]
[ LIMIT { [offset,] count | ALL } ]
[ OFFSET start [ ROW | ROWS] ]
[ FETCH { FIRST| NEXT } [ count ] { ROW | ROWS } ONLY ]
[ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT]} [...] ];
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> condition和expression中可以使用targetlist中表达式的别名。
>
> - 只能同一层引用。
> - 只能引用targetlist中的别名。
> - 只能是后面的表达式引用前面的表达式。
> - 不能包含volatile函数。
> - 不能包含Window function函数。
> - 不支持在join on条件中引用别名。
> - targetlist中有多个要应用的别名则报错。

- 其中子查询with_query为：

```
with_query_name [ ( column_name [, ...] ) ]
AS ( {select | values | insert | update | delete} )
```

- 其中指定查询源from_item为：

```
{[ ONLY ] table_name [ * ] [ partition_clause ] [ [ AS ]alias [ ( column_alias [, ...] ) ] ]
[ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE (seed ) ] ]|( select ) [ AS ] alias [ ( column_alias [, ...] ) ]
|with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ]]
|function_name ( [ argument [, ...] ] ) [ AS ] alias [ (column_alias [, ...] 
| column_definition [, ...] ) ]
|function_name ( [ argument [, ...] ] ) AS ( column_definition[, ...] )
|from_item [ NATURAL ] join_type from_item [ ON join_condition |USING ( join_column [, ...] ) ]}
```

- 其中group子句为：

```
expression
| ( expression [, ...] )
| ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )
| CUBE ( { expression | ( expression [, ...] ) } [, ...] )
| GROUPING SETS ( grouping_element [, ...] )
```

- 其中指定分区partition_clause为：

```
PARTITION { ( partition_name ) |
FOR ( partition_value [, ...] ) }
```

- 其中设置排序方式nlssort_expression_clause为：

```
NLSSORT ( column_name, ' NLS_SORT = { SCHINESE_PINYIN_M |generic_m_ci } ' )
```

- 简化版查询语法，功能相当于select * from table_name。

```
TABLE { ONLY {(table_name)| table_name} | table_name [ * ]}; 	
```

**参数说明**

- WITH [ RECURSIVE ] with_query [, ...]

  - 用于声明一个或多个可以在主查询中通过名称引用的子查询，相当于临时表。如果声明了RECURSIVE，那么允许SELECT子查询通过名称引用它自己。

  - with_query的详细格式为：

```
with_query_name [ ( column_name [, ...]) ] AS ( {select | values | insert | update | delete} )
```

  - with_query_name指定子查询生成的结果集名称，在查询中可使用该名称访问子查询的结果集。

  - column_name指定子查询结果集中显示的列名。

  - 每个子查询可以是SELECT，VALUES，INSERT，UPDATE或DELETE语句。

- plan_hint子句

  以/*+*/的形式在SELECT关键字后，用于对SELECT对应的语句块生成的计划进行hint调优。

- ALL

  声明返回所有符合条件的行，是默认行为，可以省略该关键字。

- DISTINCT [ ON ( expression [, …] ) ]

  从SELECT的结果集中删除所有重复的行，使结果集中的每行都是唯一的。

  ON ( expression [, …] )只保留那些在给出的表达式上运算出相同结果的行集合中的第一行。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> DISTINCT ON表达式是使用与ORDER BY相同的规则进行解释的。除非使用了ORDER BY来保证需要的行首先出现，否则，"第一行" 是不可预测的。

- SELECT列表

  指定查询表中列名，可以是部分列或者是全部（使用通配符*表示）。 通过使用子句AS output_name可以为输出字段取个别名，这个别名通常用于输出字段的显示。列名可以用下面几种形式表达：

  - 手动输入列名，多个列之间用英文逗号（,）分隔。
  - 可以是FROM子句里面计算出来的字段。

- FROM子句

  为SELECT声明一个或者多个源表。 FROM子句涉及的元素如下所示。

  - table_name

    表名或视图名，名称前可加上模式名，如：schema_name.table_name。

  - alias

    给表或复杂的表引用起一个临时的表别名，以便被其余的查询引用。

    别名用于缩写或者在自连接中消除歧义。如果提供了别名，它就会完全隐藏表的实际名。

  - TABLESAMPLE sampling_method ( argument [, …] ) [ REPEATABLE (seed ) ]

    table_name之后的TABLESAMPLE子句表示应该用指定的sampling_method来检索表中行的子集。可选的REPEATABLE子句指定一个用于产生采样方法中随机数的种子数。种子值可以是任何非空常量值。如果查询时表没有被更改，指定相同种子和argument值的两个查询将会选择该表相同的采样。但是不同的种子值通常将会产生不同的采样。如果没有给出REPEATABLE，则会基于一个系统产生的种子为每一个查询选择一个新的随机采样。

  - column_alias

    列别名。

  - PARTITION

    查询分区表的某个分区的数据。

  - partition_name

    分区名。

  - partition_value

    指定的分区键值。在创建分区表时，如果指定了多个分区键，可以通过PARTITION FOR子句指定的这一组分区键的值，唯一确定一个分区。

  - subquery

    FROM子句中可以出现子查询，创建一个临时表保存子查询的输出。

  - with_query_name

    WITH子句同样可以作为FROM子句的源，可以通过WITH查询的名称对其进行引用。

  - function_name

    函数名称。函数调用也可以出现在FROM子句中。

  - ON join_condition

    连接条件，用于限定连接中的哪些行是匹配的。如：

```
ON left_table.a = right_table.a
```

  - USING(join_column[，…])

    ON left_table.a = right_table.a AND left_table.b = right_table.b …的简写。要求对应的列必须同名。

  - NATURAL

    NATURAL是具有相同名称的两个表的所有列的USING列表的简写。

  - from_item

    用于连接的查询源对象的名称。

  - join_type

    有5种类型，如下所示。

    - [ INNER ] JOIN

      一个JOIN子句组合两个FROM项。可使用圆括弧以决定嵌套的顺序。如果没有圆括弧，JOIN从左向右嵌套。在任何情况下，JOIN都比逗号分隔的FROM项绑定得更紧。

    - LEFT [ OUTER ] JOIN

      返回笛卡尔积中所有符合连接条件的行，再加上左表中通过连接条件没有匹配到右表行的那些行。这样，左边的行将扩展为生成表的全长，方法是在那些右表对应的字段位置填上NULL。请注意，只在计算匹配的时候，才使用JOIN子句的条件，外层的条件是在计算完毕之后 施加的。

    - RIGHT [ OUTER ] JOIN

      返回所有内连接的结果行，加上每个不匹配的右边行（左边用NULL 扩展）。这只是一个符号上的方便，因为总是可以把它转换成一个LEFT OUTER JOIN，只要把左边和右边的输入互换位置即可。

    - FULL [ OUTER ] JOIN

      返回所有内连接的结果行，加上每个不匹配的左边行（右边用NULL扩展），再加上每个不匹配的右边行（左边用NULL扩展）。

    - CROSS JOIN

      CROSS JOIN等效于INNER JOIN ON（TRUE） ，即没有被条件删除的行。这种连接类型只是符号上的方便，因为它们与简单的FROM和WHERE的效果相同。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 必须为INNER和OUTER连接类型声明一个连接条件，即NATURAL ON，join_condition，USING (join_column [， …]) 之一。但是它们不能出现在CROSS JOIN中。其中CROSS JOIN和INNER JOIN生成一个简单的笛卡尔积，和在FROM的顶层列出两个项的结果相同。

- WHERE子句

  WHERE子句构成一个行选择表达式，用来缩小SELECT查询的范围。condition是返回值为布尔型的任意表达式，任何不满足该条件的行都不会被检索。

  WHERE子句中可以通过指定”(+)“操作符的方法将表的连接关系转换为外连接。但是不建议用户使用这种用法，因为这并不是SQL的标准语法，在做平台迁移的时候可能面临语法兼容性的问题。同时，使用”(+)“有很多限制：

  - ”(+)“只能出现在where子句中。
  - 如果from子句中已经有指定表连接关系，那么不能再在where子句中使用”(+)“。
  - ”(+)“只能作用在表或者视图的列上，不能作用在表达式上。
  - 如果表A和表B有多个连接条件，那么必须在所有的连接条件中指定”(+)“，否则”(+)“将不会生效，表连接会转化成内连接，并且不给出任何提示信息。
  - 在任何外连接的 WHERE 子句中，无论指定哪种形式，都不能将带有”（+）”的列与子查询进行比较。
  - 如果”(+)“作用的表，不在当前查询或者子查询的from子句中，则会报错。如果”(+)“作用的对端的表不存在，则不报错，同时连接关系会转化为内连接。
  - ”(+)“作用的表达式不能直接通过”OR”连接。
  - 如果”(+)“作用的列是和一个常量的比较关系， 那么这个表达式会成为join条件的一部分。
  - 同一个表不能对应多个外表。
  - ”(+)“只能出现”比较表达式”，”NOT表达式”，”ANY表达式”，”ALL表达式”，”IN表达式”，”NULLIF表达式”，”IS DISTINCT FROM表达式”，”IS OF”表达式。”(+)“不能出现在其他类型表达式中，并且这些表达式中不允许出现通过”AND”和”OR”连接的表达式。
  - ”(+)“只能转化为左外连接或者右外连接，不能转化为全连接，即不能在一个表达式的两个表上同时指定“(+)“。



> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> 对于WHERE子句的LIKE操作符，当LIKE中要查询特殊字符”%“、”_“、”\“的时候需要使用反斜 杠”\“来进行转义。

- GROUP BY子句

  将查询结果按某一列或多列的值分组，值相等的为一组。

  - CUBE ( { expression | ( expression [, …] ) } [, …] )

    CUBE是自动对groupby子句中列出的字段进行分组汇总，结果集将包含维度列中各值的所有可能组合，以及与这些维度值组合相匹配的基础行中的聚合值。它会为每个分组返回一行汇总信息，用户可以使用CUBE来产生交叉表值。比如，在CUBE子句中给出三个表达式（n =3），运算结果为2^n= 2^3 = 8组。以n个表达式的值分组的行称为常规行，其余的行称为超级聚集行。

  - GROUPING SETS ( grouping_element [, …] )

    GROUPING SETS子句是GROUP BY子句的进一步扩展，它可以使用户指定多个GROUP BY选项。这样做可以通过裁剪用户不需要的数据组来提高效率。当用户指定了所需的数据组时，数据库不需要执行完整CUBE或ROLLUP生成的聚合集合。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> SELECT子句中指定字段必须要包含在group by语句后，作为分组的依据，如果没有包含则会报错。除非SELECT子句中的字段包含在聚集函数中，因为对于未分组的字段，可能会返回多个数值。

- HAVING子句

  与GROUP BY子句配合用来选择特殊的组。HAVING子句将组的一些属性与一个常数值比较，只有满足HAVING子句中的逻辑表达式的组才会被提取出来。

- WINDOW子句

  一般形式为：

```
WINDOW window_name AS ( window_definition ) [，...]
```

  window_name是可以被随后的窗口定义所引用的名称，window_definition可以是以下的形式：

```
[ existing_window_name ]
[ PARTITION BY expression [, ...] ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS {FIRST | LAST } ] [, ...] ]    
[ frame_clause]
```

  frame_clause为窗函数定义一个窗口框架window frame，窗函数（并非所有）依赖于框架，window frame是当前查询行的一组相关行。frame_clause可以是以下的形式：

```
[ RANGE | ROWS ] frame_start
[ RANGE | ROWS ] BETWEEN frame_start AND frame_end
```

  frame_start和frame_end可以是：

```
UNBOUNDED PRECEDING
value PRECEDING
CURRENT ROW 
value FOLLOWING
UNBOUNDED FOLLOWING
```

  > <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
  >
  > 对列存表的查询目前只支持row_number窗口函数，不支持frame_clause。

- UNION子句

  UNION计算多个SELECT语句返回行集合的并集。

  UNION子句有如下约束条件：

  - 除非声明了ALL子句，否则缺省的UNION结果不包含重复的行。
  - 同一个SELECT语句中的多个UNION操作符是从左向右计算的，除非用圆括弧进行了标识
  - FOR UPDATE不能在UNION的结果或输入中声明。

  一般表达式：

```
select_statement UNION [ALL] select_statement
```

  - select_statement可以是任何没有ORDER BY、LIMIT、FOR UPDATE子句的SELECT语句。
  - 如果用圆括弧包围，ORDER BY和LIMIT可以附着在子表达式里。

- INTERSECT子句

  INTERSECT计算多个SELECT语句返回行集合的交集，不含重复的记录。

  INTERSECT子句有如下约束条件：

  - 同一个SELECT语句中的多个INTERSECT操作符是从左向右计算的，除非用圆括弧进行了标识。
  - 当对多个SELECT语句的执行结果进行UNION和INTERSECT操作的时候，会优先处理INTERSECT。

  一般形式：

```
select_statement INTERSECT select_statement
```

  select_statement可以是任何没有FOR UPDATE子句的SELECT语句。

- EXCEPT子句

  EXCEPT子句有如下的通用形式：

```
select_statement EXCEPT [ ALL ] select_statement 
```

  select_statement是任何没有FOR UPDATE子句的SELECT表达式。

  - EXCEPT操作符计算存在于左边SELECT语句的输出而不存在于右边SELECT语句输出的行。
  - EXCEPT的结果不包含任何重复的行，除非声明了ALL选项。使用ALL时，一个在左边表中有m个重复而在右边表中有n个重复的行将在结果中出现max(m-n,0)次。
  - 除非用圆括弧指明顺序，否则同一个SELECT语句中的多个EXCEPT操作符是从左向右计算的。EXCEPT和UNION的绑定级别相同。
  - 不能给EXCEPT的结果或者任何EXCEPT的输入声明FOR UPDATE子句。

- MINUS子句

  与EXCEPT子句具有相同的功能和用法。

- ORDER BY子句

  对SELECT语句检索得到的数据进行升序或降序排序。对于ORDER BY表达式中包含多列的情况：

  - 首先根据最左边的列进行排序，如果这一列的值相同，则根据下一个表达式进行比较，依此类推。
  - 如果对于所有声明的表达式都相同，则按随机顺序返回。
  - ORDER BY中排序的列必须包括在SELECT语句所检索的结果集的列中。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> 如果要支持中文拼音排序和不区分大小写排序，需要在初始化数据库时指定编码格式为UTF-8或GBK。 命令如下:
> initdb --E UTF8 --D ../data --locale=zh_CN.UTF-8或initdb --E GBK --D ../data -- locale=zh_CN.GBK
> 注意：若要使用pg_zhtrgm插件，initdb时指定的 -E和--locale参数对应的编码规则必须一致。

- LIMIT子句

```
LIMIT { count | ALL }
```

  当limit后面跟一个参数的时候，该参数表示要取的行数。 当limit后面跟两个参数的时候，第一个数表示要跳过的行数，后一位表示要取的行数。

- OFFSET子句

```
OFFSET start { ROW | ROWS }
```

  start声明开始返回行之前忽略的行数。当limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的行数,offset表示要跳过的行数。

- FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY

  如果不指定count，默认值为1，FETCH子句限定返回查询结果从第一行开始的总行数。

- FOR UPDATE子句

  - FOR UPDATE子句将对SELECT检索出来的行进行加锁。这样避免它们在当前事务结束前被其他事务修改或者删除，即其他企图UPDATE、DELETE、 SELECT FOR UPDATE这些行的事务将被阻塞，直到当前事务结束。
  - 为了避免操作等待其他事务提交，可使用NOWAIT选项，如果被选择的行不能立即被锁住，执行SELECT FOR UPDATE NOWAIT将会立即汇报一个错误，而不是等待。
  - FOR NO KEY UPDATE行为与FOR UPDATE类似，不过获得的锁较弱：这种锁将不会阻塞尝试在相同行上获得锁的SELECT FOR KEY SHARE命令。任何不获取FOR UPDATE锁的UPDATE也会获得这种锁模式。FOR SHARE的行为类似，只是它在每个检索出来的行上要求一个共享锁，而不是一个排他锁。一个共享锁阻塞其它事务执行UPDATE、DELETE、SELECT，不阻塞SELECT FOR SHARE。
  - 如果在FOR UPDATE或FOR SHARE中明确指定了表名称，则只有这些指定的表被锁定，其他在SELECT中使用的表将不会被锁定。否则，将锁定该命令中所有使用的表。
  - 如果FOR UPDATE或FOR SHARE应用于一个视图或者子查询，它同样将锁定所有该视图或子查询中使用到的表。
  - 多个FOR UPDATE和FOR SHARE子句可以用于为不同的表指定不同的锁定模式。
  - 如果一个表中同时出现（或隐含同时出现）在FOR UPDATE和FOR SHARE子句中，则按照FOR UPDATE处理。类似的，如果影响一个表的任意子句中出现了NOWAIT，该表将按照NOWAIT处理。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> 对列存表的查询不支持for update/share。

- NLS_SORT

  指定某字段按照特殊方式排序。目前仅支持中文拼音格式排序和不区分大小写排序。

  取值范围：

  - SCHINESE_PINYIN_M，按照中文拼音排序。如果要支持此排序方式，在创建数据库时需要指定编码格式为”GBK”，否则排序无效。
  - generic_m_ci，不区分大小写排序。

- PARTITION子句

  查询某个分区表中相应分区的数据。

**示例**

通过子查询得到一张临时表temp_t，然后查询表temp_t中的所有数据。

```
WITH temp_t(name,isdba) AS (SELECT usename,usesuper FROM pg_user) SELECT * FROM temp_t;
```

创建表test并插入测试数据。

```
CREATE TABLE test(id int,name varchar);
INSERT INTO test(id,name) VALUES('1','zhangsan');
INSERT INTO test(id,name) VALUES('2','lisi');
INSERT INTO test(id,name) VALUES('3','zhangsan');
INSERT INTO test(id,name) VALUES('4','wangwu');
INSERT INTO test(id,name) VALUES('5','xiaoming');
INSERT INTO test(id,name) VALUES('6','xiaohong');
INSERT INTO test(id,name) VALUES('7','LISI');
```

查询test表的所有name记录，且去除重复。

```
SELECT DISTINCT(name) FROM test;
```

LIMIT子句示例：获取表中一条记录。

```
SELECT * FROM test LIMIT 1;
```

查询所有记录，且按字母升序排列。

```
SELECT name FROM test ORDER BY name;
```

GROUP BY子句示例：根据查询条件过滤，并对结果进行分组。

```
SELECT name, AVG(id) FROM test GROUP BY name HAVING AVG(id) > 2;
```

GROUP BY CUBE子句示例：根据查询条件过滤，并对结果进行分组汇总。

```
SELECT name,AVG(id) FROM test GROUP BY CUBE(id,name);
```

GROUP BY GROUPING SETS子句示例:根据查询条件过滤，并对结果进行分组汇总。

```
SELECT name,AVG(id) FROM test GROUP BY GROUPING SETS((id,name),id);
```

UNION子句示例：将表test里name字段中的内容以'l'开头和以'z'开头的进行合并。

```
SELECT id, name  FROM test WHERE test.name LIKE 'l%' UNION SELECT id, name FROM test WHERE test.name LIKE 'z%';
```

NLS_SORT子句示例：中文拼音排序。

```
SELECT * FROM test ORDER BY NLSSORT(name, 'NLS_SORT = SCHINESE_PINYIN_M');
```

不区分大小写排序:

```
SELECT * FROM test ORDER BY NLSSORT(name, 'NLS_SORT = generic_m_ci');
```

通过表别名，从pg_user和pg_user_status这两张表中获取数据。

```
SELECT a.usename,b.locktime FROM pg_user a,pg_user_status b WHERE a.usesysid=b.roloid;
```

FULL JOIN子句示例：将pg_user和pg_user_status这两张表的数据进行全连接显示，即数据的合集。

```
SELECT a.usename,b.locktime,a.usesuper FROM pg_user a FULL JOIN pg_user_status b on a.usesysid=b.roloid;
```

创建分区表test_p

```
CREATE TABLE test_p
(
r_reason_sk integer,
r_reason_id character(16),
r_reason_desc character(100)
)
PARTITION BY RANGE (r_reason_sk)
(
partition P_05_BEFORE values less than (05),
partition P_15 values less than (15),
partition P_25 values less than (25),
partition P_35 values less than (35),
partition P_45_AFTER values less than (MAXVALUE)
)
;
```

插入数据。

```
INSERT INTO test_p
values(3,'AAAAAAAABAAAAAAA','reason
1'),(10,'AAAAAAAABAAAAAAA','reason
2'),(4,'AAAAAAAABAAAAAAA','reason
3'),(10,'AAAAAAAABAAAAAAA','reason
4'),(10,'AAAAAAAABAAAAAAA','reason
5'),(20,'AAAAAAAACAAAAAAA','reason
6'),(30,'AAAAAAAACAAAAAAA','reason 7');
```

PARTITION子句示例：从test_p的表分区P_05_BEFORE中获取数据。

```
SELECT * FROM test_p PARTITION (P_05_BEFORE);
```

GROUP BY子句示例：按r_reason_id分组统计test_p表中的记录数。

```
SELECT COUNT(*),r_reason_id FROM test_p GROUP BY r_reason_id;
```

HAVING子句示例：按r_reason_id分组统计tpcds.reason_p表中的记录，并只显示r_reason_id个数大于2的信息。

```
SELECT COUNT(*) c,r_reason_id FROM test_p GROUP BY r_reason_id HAVING c>2;
```

IN子句示例：按r_reason_id分组统计tpcds.reason_p表中的r_reason_id个数，并只显示r_reason_id值为AAAAAAAABAAAAAAA或AAAAAAAADAAAAAAA的个数。

```
SELECT COUNT(*),r_reason_id FROM test_p GROUP BY
r_reason_id HAVING r_reason_id IN('AAAAAAAABAAAAAAA','AAAAAAAADAAAAAAA');
```

INTERSECT子句示例：查询r_reason_id等于AAAAAAAABAAAAAAA，并且r_reason_sk小于5的信息。

```
SELECT * FROM test_p WHERE r_reason_id='AAAAAAAABAAAAAAA' INTERSECT SELECT * FROM test_p WHERE r_reason_sk<5;
```

EXCEPT子句示例：查询r_reason_id等于AAAAAAAABAAAAAAA，并且去除r_reason_sk小于4的信息。

```
SELECT * FROM test_p WHERE r_reason_id='AAAAAAAABAAAAAAA' EXCEPT SELECT * FROM test_p WHERE r_reason_sk<4;
```

通过在where子句中指定”(+)“来实现左连接。

```
SELECT test_p.r_reason_sk ,test.id FROM test_p,test WHERE test_p.r_reason_sk=test.id(+);
```

通过在where子句中指定”(+)“来实现右连接。

```
SELECT test_p.r_reason_sk ,test.id FROM test_p,test WHERE test_p.r_reason_sk(+)=test.id;
```

通过在where子句中指定”(+)“来实现左连接，并且增加连接条件。

```
SELECT test_p.r_reason_sk ,test.id FROM test_p,test WHERE test_p.r_reason_sk=test.id(+) AND test.id(+) < 1 ORDER BY 1 LIMIT 1 ;
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> - 不支持在where子句中指定”(+)“的同时使用内层嵌套AND/OR的表达式。
> - where子句在不支持表达式宏指定”(+)“会报错。
> - where子句在表达式的两边都指定”(+)“会报错。

删除表。

```

DROP TABLE test_p,test;
```

##### CREATE TABLE

**功能描述**

在当前数据库中创建一个新的空白表，该表由命令执行者所有。

**注意事项**

- 列存表支持的数据类型请参考列存表支持的数据类型。
- 列存表不支持数组。
- 列存表不支持生成列。
- 列存表不支持创建全局临时表。

- 创建列存表的数量建议不超过1000个。

- 表中的主键约束和唯一约束必须包含分布列。

- 如果在建表过程中数据库系统发生故障，系统恢复后可能无法自动清除之前已创建的、大小为0的磁盘文件。此种情况出现概率小，不影响数据库系统的正常运行。

- 列存表的表级约束只支持PARTIAL CLUSTER KEY，不支持主外键等表级约束。

- 列存表的字段约束只支持NULL、NOT NULL、DEFAULT常量值、UNIQUE和PRIMARY KEY。

- 列存表支持delta表，受参数enable_delta_store 控制是否开启，受参数deltarow_threshold控制进入delta表的阀值。

- 使用JDBC时，支持通过PrepareStatement对DEFAUTL值进行参数化设置。
- 每张表的列数最大为1600，具体取决于列的类型，所有列的大小加起来不能超过8192 byte，text、varchar、char等长度可变的类型除外。
- 被授予CREATE ANY TABLE权限的用户，可以在public模式和用户模式下创建表。如果想要创建包含serial类型列的表，还需要授予CREATE ANY SEQUENCE创建序列的权限。
- 表名长度最多支持128字符。

**语法格式**

```
CREATE [ [ GLOBAL | LOCAL ] [ TEMPORARY | TEMP ] | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name 
    ({ column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ]
        | table_constraint
        | LIKE source_table [ like_option [...] ] }
        [, ... ])
    [ WITH ( {storage_parameter = value} [, ... ] ) ]
    [ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
    [ COMPRESS | NOCOMPRESS ]
    [ TABLESPACE tablespace_name ];
```

- 其中列约束column_constraint为：

```
  [ CONSTRAINT constraint_name ]
  { NOT NULL |
    NULL |
    CHECK ( expression ) |
    DEFAULT default_expr |
    UNIQUE index_parameters |
    ENCRYPTED WITH ( COLUMN_ENCRYPTION_KEY = column_encryption_key, ENCRYPTION_TYPE = encryption_type_value ) |
    PRIMARY KEY index_parameters |
    REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
        [ ON DELETE action ] [ ON UPDATE action ] }
  [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
```

- 其中列的压缩可选项compress_mode为：

```
  { DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS }
```

- 其中表约束table_constraint为：

```
  [ CONSTRAINT constraint_name ]
  { CHECK ( expression ) |
    UNIQUE ( column_name [, ... ] ) index_parameters |
    PRIMARY KEY ( column_name [, ... ] ) index_parameters |
    FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ (refcolumn [, ... ] ) ]
        [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] |
    PARTIAL CLUSTER KEY ( column_name [, ... ] ) }
  [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
```

- 其中like选项like_option为：

```
  { INCLUDING | EXCLUDING } { DEFAULTS | GENERATED | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | PARTITION | RELOPTIONS | ALL }
```

- 其中索引参数index_parameters为：

```
  [ WITH ( {storage_parameter = value} [, ... ] ) ]
  [ USING INDEX TABLESPACE tablespace_name ]
```

- 创建虚拟列分区表语法如下：

```
  CREATE TABLE [IF NOT EXISTS ] partition_table_name
  ([{column_name data_type [ COLLATE_COLLATION ] [column_constraint [...]] | table_constraint 
  | LIKE source_table [ like_option [...]]}
  [,...]
  [column_name2 data_type GENERATED ALWAYS AS (column_expression) STORED] ])
  [ WITH ( { storage_parameter = value} [,...] ) ]
  [ COMPRESS | NOCOMPRESS ]
  [ TABLESPACE tablespace_name ]
  [ TO { GROUP groupname | NODE ( nodename [,...] ) } ]
  PARTITION BY {
          {VALUES (column_name [,...] ) } 
          | {RANGE ( column_name2 [,...] ) [INTERVAL ('interval_expr') [STORE IN (tablespace_name [,...])]]}
          | { LIST ( column_name2 [,...])} 
          | { HASH (column_name2 [,...])}
  }
  [ SUBPARTITON BY [RANGE | LIST | HASH] (column_name2 [,...])]
  [{ SUBPARTITION TEMPLATE ( subpartition_desc [,...])} | hash_subpartitions_by_quantity]
  table_partitioning_clauses
  [ { ENABLE | DISABLE} ROW MOVEMENT];
```
> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
> column_name2可以使用新增的虚拟列作为分区键

**参数说明**

- UNLOGGED：如果指定此关键字，则创建的表为非日志表。在非日志表中写入的数据不会被写入到预写日志中，这样就会比普通表快很多。但是非日志表在冲突、执行操作系统重启、强制重启、切断电源操作或异常关机后会被自动截断，会造成数据丢失的风险。非日志表中的内容也不会被复制到备服务器中。在非日志表中创建的索引也不会被自动记录。

  使用场景：非日志表不能保证数据的安全性，用户应该在确保数据已经做好备份的前提下使用，例如系统升级时进行数据的备份。

  故障处理：当异常关机等操作导致非日志表上的索引发生数据丢失时，用户应该对发生错误的索引进行重建。

- GLOBAL | LOCAL：创建临时表时可以在TEMP或TEMPORARY前指定GLOBAL或LOCAL关键字。如果指定GLOBAL关键字，Vastbase会创建全局临时表，否则Vastbase会创建本地临时表。

- TEMPORARY | TEMP：如果指定TEMP或TEMPORARY关键字，则创建的表为临时表。临时表分为全局临时表和本地临时表两种类型。创建临时表时如果指定GLOBAL关键字则为全局临时表，否则为本地临时表。

  全局临时表的元数据对所有会话可见，会话结束后元数据继续存在。会话与会话之间的用户数据、索引和统计信息相互隔离，每个会话只能看到和更改自己提交的数据。全局临时表有两种模式：一种是基于会话级别的(ON COMMIT PRESERVE ROWS), 当会话结束时自动清空用户数据；一种是基于事务级别的(ON COMMIT DELETE ROWS), 当执行commit或rollback时自动清空用户数据。建表时如果没有指定ON COMMIT选项，则缺省为会话级别。与本地临时表不同，全局临时表建表时可以指定非pg_temp_开头的schema。

  本地临时表只在当前会话可见，本会话结束后会自动删除。因此，在除当前会话连接的数据库节点故障时，仍然可以在当前会话上创建和使用临时表。由于临时表只在当前会话创建，对于涉及对临时表操作的DDL语句，会产生DDL失败的报错。因此，建议DDL语句中不要对临时表进行操作。TEMP和TEMPORARY等价。

  > <div align="left"><img src="image/image2.png" style="zoom:20%")</div>  
  >
  > - 本地临时表通过每个会话独立的以pg_temp开头的schema来保证只对当前会话可见，因此，不建议用户在日常操作中手动删除以pg_temp、pg_toast_temp开头的schema。
  > - 如果建表时不指定TEMPORARY/TEMP关键字，而指定表的schema为当前会话的pg_temp_开头的schema，则此表会被创建为临时表。
  > - ALTER/DROP全局临时表和索引，如果其它会话正在使用它，禁止操作（ALTER INDEX index_name REBUILD除外）。
  > - 全局临时表的DDL只会影响当前会话的用户数据和索引。例如truncate、reindex、analyze只对当前会话有效。
  > - 全局临时表功能可以通过设置GUC参数max_active_global_temporary_table控制是否启用。如果max_active_global_temporary_table=0，关闭全局临时表功能。
  > - 临时表只对当前会话可见，因此不支持与\parallel on并行执行一起使用。
  > - \parallel on临时表不支持主备切换。
  
- IF NOT EXISTS：如果已经存在相同名称的表，不会报出错误，而会发出通知，告知通知此表已存在。

- table_name：要创建的表名。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   
> 物化视图的一些处理逻辑会通过表名的前缀来识别是不是物化视图日志表和物化视图关联表，因此，用户不要创建表名以mlog或matviewmap为前缀的表，否则会影响此表的一些功能。

- column_name：新表中要创建的字段名。

- data_type：字段的数据类型。

- compress_mode：表字段的压缩选项。该选项指定表字段优先使用的压缩算法。行存表不支持压缩。

  取值范围：DELTA、PREFIX、DICTIONARY、NUMSTR、NOCOMPRESS

- COLLATE collation：COLLATE子句指定列的排序规则（该列必须是可排列的数据类型）。如果没有指定，则使用默认的排序规则。排序规则可以使用“select * from pg_collation;”命令从pg_collation系统表中查询，默认的排序规则为查询结果中以default开始的行。

- LIKE source_table [ like_option … ]：LIKE子句声明一个表，新表自动从这个表中继承所有字段名及其数据类型和非空约束。新表与源表之间在创建动作完毕之后是完全无关的。在源表做的任何修改都不会传播到新表中，并且也不可能在扫描源表的时候包含新表的数据。被复制的列和约束并不使用相同的名称进行融合。如果明确的指定了相同的名称或者在另外一个LIKE子句中，将会报错。

  - 源表上的字段缺省表达式只有在指定INCLUDING DEFAULTS时，才会复制到新表中。缺省是不包含缺省表达式的，即新表中的所有字段的缺省值都是NULL。
- 源表上的CHECK约束仅在指定INCLUDING CONSTRAINTS时，会复制到新表中，而其他类型的约束永远不会复制到新表中。非空约束总是复制到新表中。此规则同时适用于表约束和列约束。
  
  - 如果指定了INCLUDING INDEXES，则源表上的索引也将在新表上创建，默认不建立索引。
- 如果指定了INCLUDING STORAGE，则复制列的STORAGE设置会复制到新表中，默认情况下不包含STORAGE设置。
  
  - 如果指定了INCLUDING COMMENTS，则源表列、约束和索引的注释会复制到新表中。默认情况下，不复制源表的注释。
- 如果指定了INCLUDING PARTITION，则源表的分区定义会复制到新表中，同时新表将不能再使用PARTITION BY子句。默认情况下，不拷贝源表的分区定义。如果源表上带有索引，可以使用INCLUDING PARTITION INCLUDING INDEXES语法实现。如果对分区表只使用INCLUDING INDEXES，目标表定义将是普通表，但是索引是分区索引，最后结果会报错，因为普通表不支持分区索引。
  - 如果指定了INCLUDING RELOPTIONS，则源表的存储参数（即源表的WITH子句）会复制到新表中。默认情况下，不复制源表的存储参数。
  - INCLUDING ALL包含了INCLUDING DEFAULTS、INCLUDING CONSTRAINTS、INCLUDING INDEXES、INCLUDING STORAGE、INCLUDING COMMENTS、INCLUDING PARTITION和INCLUDING RELOPTIONS的内容。
  
  > <div align="left"><img src="image/image2.png" style="zoom:20%")</div>  
  >
  > - 如果源表包含serial、bigserial、smallserial、largeserial类型，或者源表字段的默认值是sequence，且sequence属于源表（通过CREATE SEQUENCE … OWNED BY创建），这些Sequence不会关联到新表中，新表中会重新创建属于自己的sequence。这和之前版本的处理逻辑不同。如果用户希望源表和新表共享Sequence，需要首先创建一个共享的Sequence（避免使用OWNED BY），并配置为源表字段默认值，这样创建的新表会和源表共享该Sequence。
  > - 不建议将其他表私有的Sequence配置为源表字段的默认值，尤其是其他表只分布在特定的NodeGroup上，这可能导致CREATE TABLE … LIKE执行失败。另外，如果源表配置其他表私有的Sequence，当该表删除时Sequence也会连带删除，这样源表的Sequence将不可用。如果用户希望多个表共享Sequence，建议创建共享的Sequence。
  > - 对于分区表EXCLUDING，需要配合INCLUDING ALL使用，如INCLUDING ALL EXCLUDING DEFAULTS，除源分区表的DEFAULTS，其它全包含。

- WITH ( { storage_parameter = value } [, … ] )：这个子句为表或索引指定一个可选的存储参数。

  > <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
  > 使用任意精度类型Numeric定义列时，建议指定精度p以及刻度s。在不指定精度和刻度时，会按输入的显示出来。
  
  参数的详细描述如下所示。

  - FILLFACTOR：一个表的填充因子（fillfactor）是一个介于10和100之间的百分数。100（完全填充）是默认值。如果指定了较小的填充因子，INSERT操作仅按照填充因子指定的百分率填充表页。每个页上的剩余空间将用于在该页上更新行，这就使得UPDATE有机会在同一页上放置同一条记录的新版本，这比把新版本放置在其他页上更有效。对于一个从不更新的表将填充因子设为100是最佳选择，但是对于频繁更新的表，选择较小的填充因子则更加合适。该参数对于列存表没有意义。

    取值范围：10~100

  - ORIENTATION：指定表数据的存储方式，即行存方式、列存方式、ORC格式的方式，该参数设置成功后就不再支持修改。

    取值范围：

    - ROW，表示表的数据将以行式存储。

      行存储适合于OLTP业务，适用于点查询或者增删操作较多的场景。

    - COLUMN，表示表的数据将以列式存储。

      列存储适合于数据仓库业务，此类型的表上会做大量的汇聚计算，且涉及的列操作较少。

    默认值：若指定表空间为普通表空间，默认值为ROW。

  - STORAGE_TYPE：指定存储引擎类型，该参数设置成功后就不再支持修改。

    取值范围：USTORE，表示表支持Inplace-Update存储引擎。ASTORE表示表支持Append-Only存储引擎。

    默认值：不指定表时，默认是Append-Only存储。

  
  - INIT_TD：创建Ustore表时，指定初始化的TD个数，该参数只在创建Ustore表时才能设置生效。
  
    取值范围：2~128
  
    默认值：4。
  
  - COMPRESSION：指定表数据的压缩级别，它决定了表数据的压缩比以及压缩时间。一般来讲，压缩级别越高，压缩比也越大，压缩时间也越长；反之亦然。实际压缩比取决于加载的表数据的分布特征。行存表默认增加COMPRESSION=NO字段。
  
    取值范围：列存表的有效值为YES/NO/LOW/MIDDLE/HIGH 。

    默认值：LOW。

  - COMPRESSLEVEL：指定表数据同一压缩级别下的不同压缩水平，它决定了同一压缩级别下表数据的压缩比以及压缩时间。对同一压缩级别进行了更加详细的划分，为用户选择压缩比和压缩时间提供了更多的空间。总体来讲，此值越大，表示同一压缩级别下压缩比越大，压缩时间越长；反之亦然。

    取值范围：0~3

    默认值：0。

  - COMPRESSTYPE：行存表参数，设置行存表压缩算法。1代表pglz算法，2代表zstd算法，默认不压缩。（仅支持ASTORE下的普通表）

    取值范围：0~2

    默认值：0。

  - COMPRESS_LEVEL：行存表参数，设置行存表压缩算法等级，仅当COMPRESSTYPE为2时生效。压缩等级越高，表的压缩效果越好，表的访问速度越慢。（仅支持ASTORE下的普通表）

    取值范围：-31~31

    默认值：0。

  - COMPRESS_CHUNK_SIZE：行存表参数，设置行存表压缩chunk块大小。chunk数据块越小，预期能达到的压缩效果越好，同时数据越离散，影响表的访问速度。（仅支持ASTORE下的普通表）

    取值范围：与页面大小有关。在页面大小为8k场景，取值范围为：512、1024、2048、4096。

    默认值：4096
  
  
    - COMPRESS_PREALLOC_CHUNKS：行存表参数，设置行存表压缩chunk块预分配数量。预分配数量越大，表的压缩率相对越差，离散度越小，访问性能越好。（仅支持ASTORE下的普通表）。
  
      取值范围：0~7
  
      默认值：0
  
      当COMPRESS_CHUNK_SIZE为512和1024时，支持预分配设置最大为7。
  
      当COMPRESS_CHUNK_SIZE为2048时，支持预分配设置最大为3。
  
      当COMPRESS_CHUNK_SIZE为4096时，支持预分配设置最大为1。
  


  - COMPRESS_BYTE_CONVERT：行存表参数，设置行存表压缩字节转换预处理。在一些场景下可以提升压缩效果，同时会导致一定性能劣化。

    取值范围：布尔值

    默认值：关闭。
  
  - COMPRESS_DIFF_CONVERT：行存表参数，设置行存表压缩字节差分预处理。只能与compress_byte_convert一起使用。在一些场景下可以提升压缩效果，同时会导致一定性能劣化。
  
    取值范围：布尔值
  
    默认值：关闭。
  
  - MAX_BATCHROW：指定了在数据加载过程中一个存储单元可以容纳记录的最大数目。该参数只对列存表有效。
  
    取值范围：10000~60000
  
    默认值：60000。
  
  - PARTIAL_CLUSTER_ROWS：指定了在数据加载过程中进行将局部聚簇存储的记录数目。该参数只对列存表有效。
  
    取值范围：大于等于MAX_BATCHROW，建议取值为MAX_BATCHROW的整数倍。
  
  - DELTAROW_THRESHOLD：指定列存表导入时小于多少行的数据进入delta表，只在GUC参数enable_delta_store开启时生效。该参数只对列存表有效。
  
    取值范围：0～9999
  
    默认值：100
  
  - VERSION：指定ORC存储格式的版本。
  
    取值范围：0.12，目前支持ORC 0.12格式，后续会随着ORC格式的发展，支持更多格式。
  
    默认值：0.12
  
  - segment
  
    使用段页式的方式存储。本参数仅支持行存表。不支持列存表、临时表、unlog表。不支持ustore存储引擎。
  
    取值范围：on/off
  
    默认值：off
  
  - dek_cipher
  
    透明数据加密密钥的密文。当开启enable_tde选项时会自动申请创建，用户不可单独指定。通过密钥轮转功能可以对密钥进行更新。
  
    取值范围：字符串。
  
    默认值：不开启加密时默认为空。
  
  - hasuids
  
    参数开启：更新表元组时，为元组分配表级唯一标识id。
  
    取值范围：on/off。
  
    默认值：off。
  
- ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP }：ON COMMIT选项决定在事务中执行创建临时表操作，当事务提交时，此临时表的后续操作。有以下三个选项，当前支持PRESERVE ROWS和DELETE ROWS选项。

  - PRESERVE ROWS（缺省值）：提交时不对临时表做任何操作，临时表及其表数据保持不变。
  - DELETE ROWS：提交时删除临时表中数据。
  - DROP：提交时删除此临时表。只支持本地临时表，不支持全局临时表。

- COMPRESS | NOCOMPRESS：创建新表时，需要在CREATE TABLE语句中指定关键字COMPRESS，这样，当对该表进行批量插入时就会触发压缩特性。该特性会在页范围内扫描所有元组数据，生成字典、压缩元组数据并进行存储。指定关键字NOCOMPRESS则不对表进行压缩。行存表不支持压缩。

  缺省值：NOCOMPRESS，即不对元组数据进行压缩。

- TABLESPACE tablespace_name：创建新表时指定此关键字，表示新表将要在指定表空间内创建。如果没有声明，将使用默认表空间。

- CONSTRAINT constraint_name：列约束或表约束的名称。可选的约束子句用于声明约束，新行或者更新的行必须满足这些约束才能成功插入或更新。定义约束有两种方法：

  - 列约束：作为一个列定义的一部分，仅影响该列。
  - 表约束：不和某个列绑在一起，可以作用于多个列。

- NOT NULL：字段值不允许为NULL。

- NULL：字段值允许为NULL ，这是缺省值。这个子句只是为和非标准SQL数据库兼容。不建议使用。

- CHECK ( expression )：CHECK约束声明一个布尔表达式，每次要插入的新行或者要更新的行的新值必须使表达式结果为真或未知才能成功，否则会抛出一个异常并且不会修改数据库。声明为字段约束的检查约束应该只引用该字段的数值，而在表约束里出现的表达式可以引用多个字段。

  > <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   
  > expression表达式中，如果存在“<>NULL”或“！=NULL”，这种写法是无效的，需要写成“is NOT NULL”。

- DEFAULT default_expr：DEFAULT子句给字段指定缺省值。该数值可以是任何不含变量的表达式(不允许使用子查询和对本表中的其他字段的交叉引用)。缺省表达式的数据类型必须和字段类型匹配。缺省表达式将被用于任何未声明该字段数值的插入操作。如果没有指定缺省值则缺省值为NULL 。

- UNIQUE ( column_name [, … ] ) index_parameters：UNIQUE约束表示表里的一个字段或多个字段的组合必须在全表范围内唯一。对于唯一约束，NULL被认为是互不相等的。

- PRIMARY KEY ( column_name [, … ] ) index_parameters：主键约束声明表中的一个或者多个字段只能包含唯一的非NULL值。一个表只能声明一个主键。

- REFERENCES reftable [ ( refcolum ) ] [ MATCH matchtype ] [ ON DELETE action ] [ ON UPDATE action ] (column constraint)

  FOREIGN KEY ( column_name [, … ] ) REFERENCES reftable [ ( refcolumn [, … ] ) ] [ MATCH matchtype ] [ ON DELETE action ] [ ON UPDATE action ] (table constraint)：外键约束要求新表中一列或多列构成的组应该只包含、匹配被参考表中被参考字段值。若省略refcolum，则将使用reftable的主键。被参考列应该是被参考表中的唯一字段或主键。外键约束不能被定义在临时表和永久表之间。：参考字段与被参考字段之间存在三种类型匹配，分别是：

  - MATCH FULL：不允许一个多字段外键的字段为NULL，除非全部外键字段都是NULL。
  - MATCH SIMPLE（缺省）：允许任意外键字段为NULL。
  - MATCH PARTIAL：目前暂不支持。

  另外，当被参考表中的数据发生改变时，某些操作也会在新表对应字段的数据上执行。ON DELETE子句声明当被参考表中的被参考行被删除时要执行的操作。ON UPDATE子句声明当被参考表中的被参考字段数据更新时要执行的操作。对于ON DELETE子句、ON UPDATE子句的可能动作：

  - NO ACTION（缺省）：删除或更新时，创建一个表明违反外键约束的错误。若约束可推迟，且若仍存在任何引用行，那这个错误将会在检查约束的时候产生。
  - RESTRICT：删除或更新时，创建一个表明违反外键约束的错误。与NO ACTION相同，只是动作不可推迟。
  - CASCADE：删除新表中任何引用了被删除行的行，或更新新表中引用行的字段值为被参考字段的新值。
  - SET NULL：设置引用字段为NULL。
  - SET DEFAULT：设置引用字段为它们的缺省值。

- DEFERRABLE | NOT DEFERRABLE：这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马上检查。可推迟约束可以推迟到事务结尾使用SET CONSTRAINTS命令检查。缺省是NOT DEFERRABLE。目前，UNIQUE约束、主键约束、外键约束可以接受这个子句。所有其他约束类型都是不可推迟的。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> Ustore表不支持DEFERRABLE以及INITIALLY DEFERRED关键字。

- PARTIAL CLUSTER KEY：局部聚簇存储，列存表导入数据时按照指定的列(单列或多列)，进行局部排序。

- INITIALLY IMMEDIATE | INITIALLY DEFERRED：如果约束是可推迟的，则这个子句声明检查约束的缺省时间。

  - 如果约束是INITIALLY IMMEDIATE（缺省），则在每条语句执行之后就立即检查它；
- 如果约束是INITIALLY DEFERRED ，则只有在事务结尾才检查它。
  
  约束检查的时间可以用SET CONSTRAINTS命令修改。

- USING INDEX TABLESPACE tablespace_name：为UNIQUE或PRIMARY KEY约束相关的索引声明一个表空间。如果没有提供这个子句，这个索引将在default_tablespace中创建，如果default_tablespace为空，将使用数据库的缺省表空间。

- ENCRYPTION_TYPE = encryption_type_value：为ENCRYPTED WITH约束中的加密类型，encryption_type_value的值为[ DETERMINISTIC | RANDOMIZED ]

**示例**

- 创建简单的表。 
```
CREATE TABLE warehouse_t1 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
);  
```

- 创建表，并指定W_STATE字段的缺省值为GA。 

```
CREATE TABLE warehouse_t2 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)      DEFAULT 'GA', 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

- 创建表，并在事务结束时检查W_WAREHOUSE_NAME字段是否有重复。 

```
CREATE TABLE warehouse_t3 
( 
  W_WAREHOUSE_SK       INTEGER         NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)  UNIQUE DEFERRABLE, 
  W_WAREHOUSE_SQ_FT     INTEGER             , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)           , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)           , 
  W_COUNTY          VARCHAR(30)           , 
  W_STATE          CHAR(2)             , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)           , 
  W_GMT_OFFSET        DECIMAL(5,2)  
);
```

- 创建一个带有70%填充因子的表。 

```
CREATE TABLE warehouse_t4 
( 
  W_WAREHOUSE_SK       INTEGER         NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)           , 
  W_WAREHOUSE_SQ_FT     INTEGER             , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)           , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)           , 
  W_COUNTY          VARCHAR(30)           , 
  W_STATE          CHAR(2)             , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)           , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  UNIQUE(W_WAREHOUSE_NAME) WITH(fillfactor=70) 
); 
```

- 或者用下面的语法。 

```
CREATE TABLE warehouse_t5 
( 
  W_WAREHOUSE_SK       INTEGER         NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)        UNIQUE, 
  W_WAREHOUSE_SQ_FT     INTEGER             , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)           , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)           , 
  W_COUNTY          VARCHAR(30)           , 
  W_STATE          CHAR(2)             , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)           , 
  W_GMT_OFFSET        DECIMAL(5,2) 
) WITH(fillfactor=70);
```

- 创建表，并指定该表数据不写入预写日志。 

```
CREATE UNLOGGED TABLE warehouse_t6 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

- 创建表临时表。 

```
CREATE TEMPORARY TABLE warehouse_t7 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

- 事务中创建表临时表，并指定提交事务时删除该临时表数据。 

```
CREATE TEMPORARY TABLE warehouse_t8 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
) ON COMMIT DELETE ROWS; 
```

 

- 创建表时，不希望因为表已存在而报错。 

```
CREATE TABLE IF NOT EXISTS warehouse_t9 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

- 创建带有自增列的表。 

```
create table test_b
(
id serial PRIMARY KEY,
name character varying(64) 
);
```

- 创建普通表空间。 

```
CREATE TABLESPACE DS_TABLESPACE1 RELATIVE LOCATION 'tablespace/tablespace_1'; 
```

- 创建表时，指定表空间。 

```
CREATE TABLE warehouse_t10 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
) TABLESPACE DS_TABLESPACE1; 
```

- 创建表时，单独指定W_WAREHOUSE_NAME的索引表空间。 

```
CREATE TABLE warehouse_t11
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)      UNIQUE USING INDEX TABLESPACE DS_TABLESPACE1, 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
);
```

- 创建一个有主键约束的表。 

```
CREATE TABLE warehouse_t12 
( 
  W_WAREHOUSE_SK       INTEGER       PRIMARY KEY, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

- 或是用下面的语法，效果完全一样。 

```
CREATE TABLE  warehouse_t13
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  PRIMARY KEY(W_WAREHOUSE_SK) 
); 
```

- 或是用下面的语法，指定约束的名称。 

```
CREATE TABLE warehouse_t14 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  CONSTRAINT W_CSTR_KEY1 PRIMARY KEY(W_WAREHOUSE_SK) 
);
```

- 创建一个有复合主键约束的表。 

```
CREATE TABLE warehouse_t15
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  CONSTRAINT W_CSTR_KEY2 PRIMARY KEY(W_WAREHOUSE_SK, W_WAREHOUSE_ID) 
); 
```

- 创建列存表。 

```
CREATE TABLE warehouse_t16 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
) WITH (ORIENTATION = COLUMN); 
```

- 创建局部聚簇存储的列存表。 

```
CREATE TABLE warehouse_t17 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  PARTIAL CLUSTER KEY(W_WAREHOUSE_SK, W_WAREHOUSE_ID) 
) WITH (ORIENTATION = COLUMN); 
```

- 定义一个带压缩的列存表。 

```
CREATE TABLE warehouse_t18 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
) WITH (ORIENTATION = COLUMN, COMPRESSION=HIGH); 
```

- 定义一个带压缩的表。 

```
CREATE TABLE warehouse_t19 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
) COMPRESS; 
```

- 定义一个检查列约束。 

```
CREATE TABLE warehouse_t20 
( 
  W_WAREHOUSE_SK       INTEGER        PRIMARY KEY CHECK (W_WAREHOUSE_SK > 0), 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)      CHECK (W_WAREHOUSE_NAME IS NOT NULL), 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

```
CREATE TABLE warehouse_t21
( 
  W_WAREHOUSE_SK       INTEGER        PRIMARY KEY, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)      CHECK (W_WAREHOUSE_NAME IS NOT NULL), 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            ,
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  CONSTRAINT W_CONSTR_KEY2 CHECK(W_WAREHOUSE_SK > 0 AND W_WAREHOUSE_NAME IS NOT NULL)  
); 
```

- 定义一个表，表中每一个行存在数据库节点中。 

```
CREATE TABLE warehouse_t22 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2) 
); 
```

- 定义一个表，使用HASH分布。 

```
CREATE TABLE warehouse_t23 
( 
  W_WAREHOUSE_SK       INTEGER        NOT NULL, 
  W_WAREHOUSE_ID       CHAR(16)        NOT NULL, 
  W_WAREHOUSE_NAME      VARCHAR(20)          , 
  W_WAREHOUSE_SQ_FT     INTEGER            , 
  W_STREET_NUMBER      CHAR(10)            , 
  W_STREET_NAME       VARCHAR(60)          , 
  W_STREET_TYPE       CHAR(15)            , 
  W_SUITE_NUMBER       CHAR(10)            , 
  W_CITY           VARCHAR(60)          , 
  W_COUNTY          VARCHAR(30)          , 
  W_STATE          CHAR(2)            , 
  W_ZIP           CHAR(10)            , 
  W_COUNTRY         VARCHAR(20)          , 
  W_GMT_OFFSET        DECIMAL(5,2), 
  CONSTRAINT W_CONSTR_KEY3 UNIQUE(W_WAREHOUSE_SK) 
);  
```

- 向warehouse_t20表中增加一个varchar列。

```
ALTER TABLE warehouse_t20 ADD W_GOODS_CATEGORY varchar(30); 
```

- 给tpcds.warehouse_t20表增加一个检查约束。 

```
ALTER TABLE warehouse_t20 ADD CONSTRAINT W_CONSTR_KEY4 CHECK (W_STATE IS NOT NULL); 
```

- 在一个操作中改变两个现存字段的类型。 

```
ALTER TABLE warehouse_t20 
ALTER COLUMN W_GOODS_CATEGORY TYPE varchar(80), 
ALTER COLUMN W_STREET_NAME TYPE varchar(100); 
```

- 此语句与上面语句等效。 
```
ALTER TABLE warehouse_t20 MODIFY (W_GOODS_CATEGORY varchar(30), W_STREET_NAME varchar(60)); 
```
- 给一个已存在字段添加非空约束。 
```
ALTER TABLE warehouse_t20 ALTER COLUMN W_GOODS_CATEGORY SET NOT NULL; 
```
- 移除已存在字段的非空约束。 
```
ALTER TABLE warehouse_t20 ALTER COLUMN W_GOODS_CATEGORY DROP NOT NULL; 
```
- 如果列存表中还未指定局部聚簇，向在一个列存表中添加局部聚簇列。 

```
ALTER TABLE warehouse_t18 ADD PARTIAL CLUSTER KEY(W_WAREHOUSE_SK); 
```

- 删除一个列存表中的局部聚簇列。 

```
ALTER TABLE warehouse_t18 DROP CONSTRAINT warehouse_t18_cluster; 
```

- 将表移动到另一个表空间。 

```
ALTER TABLE warehouse_t20 SET TABLESPACE PG_DEFAULT;  
```

- 创建模式joe。 

```
CREATE SCHEMA joe; 
```

- 将表移动到另一个模式中。 

```
ALTER TABLE warehouse_t20 SET SCHEMA joe; 
```

- 重命名已存在的表。 

```
ALTER TABLE joe.warehouse_t20 RENAME TO warehouse_t23; 
```

- 从warehouse_t23表中删除一个字段。 

```
ALTER TABLE joe.warehouse_t23 DROP COLUMN W_STREET_NAME; 
```

- 创建虚拟列表，虚拟列作为一级分区键。
```
CREATE TABLE t_virtual
      (
         object_id number,
         object_name varchar2(100),
         created date,
         create_year int GENERATED ALWAYS AS (to_number(to_char(created,'MM')))STORED
         )
         partition by list(create_year)
         (
         partition P1 VALUES (1),
         partition P2 VALUES (2),
         partition P3 VALUES (3),
         partition P4 VALUES (4),
         partition P5 VALUES (5)
         );
```

- 删除表空间、模式joe和模式表warehouse。 

```
DROP TABLE warehouse_t1; 
DROP TABLE warehouse_t2; 
DROP TABLE warehouse_t3; 
DROP TABLE warehouse_t4; 
DROP TABLE warehouse_t5; 
DROP TABLE warehouse_t6; 
DROP TABLE warehouse_t7; 
DROP TABLE warehouse_t8; 
DROP TABLE warehouse_t9; 
DROP TABLE warehouse_t10; 
DROP TABLE warehouse_t11; 
DROP TABLE warehouse_t12; 
DROP TABLE warehouse_t13; 
DROP TABLE warehouse_t14; 
DROP TABLE warehouse_t15; 
DROP TABLE warehouse_t16; 
DROP TABLE warehouse_t17; 
DROP TABLE warehouse_t18; 
DROP TABLE warehouse_t20; 
DROP TABLE warehouse_t21; 
DROP TABLE warehouse_t22; 
DROP TABLE joe.warehouse_t23; 
DROP TABLESPACE DS_TABLESPACE1; 
DROP SCHEMA IF EXISTS joe CASCADE;
```

##### CREATE INDEX

**功能描述**

在指定的表上创建索引。索引可以用来提高数据库查询性能，但是不恰当的使用将导致数据库性能下降。建议仅在匹配如下某条原则时创建索引：

- 经常执行查询的字段。
- 在连接条件上创建索引，对于存在多字段连接的查询，建议在这些字段上建立组合索引。例如，select * from t1 join t2 on t1.a=t2.a and t1.b=t2.b，可以在t1表上的a、b字段上建立组合索引。
- where子句的过滤条件字段上（尤其是范围条件）。
- 经常出现在order by、group by和distinct后的字段。

在分区表上创建索引与在普通表上创建索引的语法不太一样，使用时请注意，如分区表上不支持并行创建索引，不支持创建部分索引。

**注意事项**

- 索引自身也占用存储空间、消耗计算资源，创建过多的索引将对数据库性能造成负面影响（尤其影响数据导入的性能，建议在数据导入后再建索引）。因此，仅在必要时创建索引。
- 索引定义里的所有函数和操作符都必须是immutable类型的，即它们的结果必须只能依赖于它们的输入参数，而不受任何外部的影响（如另外一个表的内容或者当前时间）。这个限制可以确保该索引的行为是定义良好的。要在一个索引上或WHERE中使用用户定义函数，请把它标记为immutable类型函数。
- 分区表索引分为LOCAL索引与GLOBAL索引，LOCAL索引与某个具体分区绑定，而GLOBAL索引则对应整个分区表。
- 列存表支持的PSORT和B-tree索引都不支持创建表达式索引、部分索引，PSORT不支持创建唯一索引，B-tree支持创建唯一索引。
- 列存表支持的GIN索引支持创建表达式索引，但表达式不能包含空分词、空列和多列，不支持创建部分索引和唯一索引。
- HASH索引目前仅限于行存表索引、临时表索引和分区表LOCAL索引，且不支持创建多字段索引。
- 被授予CREATE ANY INDEX权限的用户，可以在public模式和用户模式下创建索引。

**语法格式**

- 在表上创建索引。

  ```
  CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [IF NOT EXISTS] [ [schema_name.]index_name ] ON table_name [ USING method ]
    ({ { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] }[, ...] )
    [ INCLUDE ( column_name [, ...] )]    
    [ WITH ( {storage_parameter = value} [, ... ] ) ]
    [ TABLESPACE tablespace_name ]
    [ WHERE predicate ];
  ```

- 在分区表上在线创建全局索引和在线创建一级分区索引。

  ```
  CREATE [ UNIQUE ] INDEX [ CONCURRENTLY] [ [schema_name.]index_name ] ON table_name [ USING method ]
      ( {{ column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS LAST ] }[, ...] )
      [ LOCAL [ ( { PARTITION index_partition_name  [ TABLESPACE index_partition_tablespace ] } [, ...] ) ] | GLOBAL ]
      [ WITH ( { storage_parameter = value } [, ...] ) ]
      [ TABLESPACE tablespace_name ];
  ```

**参数说明**

- UNIQUE：创建唯一性索引，每次添加数据时检测表中是否有重复值。如果插入或更新的值会引起重复的记录时，将导致一个错误。目前只有B-tree及UBTree索引支持唯一索引。

- CONCURRENTLY：以不阻塞DML的方式创建索引（加ShareUpdateExclusiveLock锁）。创建索引时，一般会阻塞其他语句对该索引所依赖表的访问。指定此关键字，可以实现创建过程中不阻塞DML。

  - 此选项只能指定一个索引的名称。
  - 普通CREATE INDEX命令可以在事务内执行，但是CREATE INDEX CONCURRENTLY不可以在事务内执行。
  - 列存表和临时表不支持CONCURRENTLY方式创建索引。
  - 支持在行存一级分区表上在线创建全局索引和本地分区索引。


> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> - 创建索引时指定此关键字，需要执行先后两次对该表的全表扫描来完成build，第一次扫描的时候创建索引，不阻塞读写操作；第二次扫描的时候合并更新第一次扫描到目前为止发生的变更。
> - 由于需要执行两次对表的扫描和build，而且必须等待现有的所有可能对该表执行修改的事务结束。这意味着该索引的创建比正常耗时更长，同时因此带来的CPU和I/O消耗对其他业务也会造成影响。
> - 如果在索引构建时发生失败，那会留下一个“不可用”的索引。这个索引会被查询忽略，但它仍消耗更新开销。这种情况推荐的恢复方法是删除该索引并尝试再次CONCURRENTLY建索引。
> - 由于在第二次扫描之后，索引构建必须等待任何持有早于第二次扫描拿的快照的事务终止，而且建索引时加的ShareUpdateExclusiveLock锁（4级）会和大于等于4级的锁冲突，在创建这类索引时，容易引发卡住（hang）或者死锁问题。例如：
>   - 两个会话对同一个表创建CONCURRENTLY索引，会引起死锁问题；
>   - 两个会话，一个对表创建CONCURRENTLY索引，一个drop table，会引起死锁问题；
>   - 三个会话，会话1先对表a加锁，不提交，会话2接着对表b创建CONCURRENTLY索引，会话3接着对表a执行写入操作，在会话1事务未提交之前，会话2会一直被阻塞；
>   - 将事务隔离级别设置成可重复读（默认为读已提交），起两个会话，会话1起事务对表a执行写入操作，不提交，会话2对表b创建CONCURRENTLY索引，在会话1事务未提交之前，会话2会一直被阻塞。

- IF NOT EXISTS：用于判断是否存在同名索引。

- schema_name：模式的名称。

  取值范围：已存在模式名。

- index_name：要创建的索引名，索引的模式与表相同。

  取值范围：字符串，要符合标识符的命名规范。

- table_name：需要为其创建索引的表的名称，可以用模式修饰。

  取值范围：已存在的表名。

- USING method：指定创建索引的方法。

  取值范围：
  
  - btree：B-tree索引使用一种类似于B+树的结构来存储数据的键值，通过这种结构能够快速的查找索引。btree适合支持比较查询以及查询范围。
  - hash：Hash索引使用Hash函数对索引的关键字进行散列。只能处理简单等值比较，比较适合在索引值较长的情况下使用。
  - gin：GIN索引是倒排索引，可以处理包含多个键的值（比如数组）。
  - gist：Gist索引适用于几何和地理等多维数据类型和集合数据类型。目前支持的数据类型有box、point、poly、circle、tsvector、tsquery、range。
  - Psort：Psort索引是针对列存表进行局部排序的索引。
  - ubtree：仅供ustore表使用的多版本B-tree索引，索引页面上包含事务信息，能并自主回收页面。
  
  > <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
  > 列存表对GIN索引支持仅限于对于tsvector类型的支持，即创建列存GIN索引入参需要为to_tsvector函数（的返回值)。此方法为GIN索引比较普遍的使用方式。
  >
  > 行存表（ASTORE存储引擎）支持的索引类型：btree（行存表缺省值）、hash、gin、gist。行存表（USTORE存储引擎）支持的索引类型：ubtree。列存表支持的索引类型：Psort（列存表缺省值）、btree、gin。全局临时表不支持GIN索引和Gist索引。
  
- column_name：表中需要创建索引的列的名称（字段名）。如果索引方式支持多字段索引，可以声明多个字段。全局索引最多可以声明31个字段，其他索引最多可以声明32个字段。

- expression：创建一个基于该表的一个或多个字段的表达式索引，通常必须写在圆括弧中。如果表达式有函数调用的形式，圆括弧可以省略。表达式索引可用于获取对基本数据的某种变形的快速访问。比如，一个在upper(col)上的函数索引将允许WHERE upper(col) = 'JIM'子句使用索引。在创建表达式索引时，如果表达式中包含IS NULL子句，则这种索引是无效的。此时，建议用户尝试创建一个部分索引。

- COLLATE collation：COLLATE子句指定列的排序规则（该列必须是可排列的数据类型）。如果没有指定，则使用默认的排序规则。排序规则可以使用“select * from pg_collation”命令从pg_collation系统表中查询，默认的排序规则为查询结果中以default开始的行。

- opclass：操作符类的名称。对于索引的每一列可以指定一个操作符类，操作符类标识了索引那一列的使用的操作符。例如一个B-tree索引在一个四字节整数上可以使用int4_ops；这个操作符类包括四字节整数的比较函数。实际上对于列上的数据类型默认的操作符类是足够用的。操作符类主要用于一些有多种排序的数据。例如，用户想按照绝对值或者实数部分排序一个复数。能通过定义两个操作符类然后当建立索引时选择合适的类。

- ASC：指定按升序排序（默认）。

- DESC：指定按降序排序。

- NULLS FIRST：指定空值在排序中排在非空值之前，当指定DESC排序时，本选项为默认的。

- NULLS LAST：指定空值在排序中排在非空值之后，未指定DESC排序时，本选项为默认的。

- LOCAL：指定创建的分区索引为LOCAL索引。

- GLOBAL：指定创建的分区索引为GLOBAL索引，当不指定LOCAL、GLOBAL关键字时，默认创建GLOBAL索引。

- INCLUDE ( column_name [, …] )：可选的 INCLUDE 子句指定将一些非键列（non-key columns）包含在索引中。

  - 非键列不能用于作为索引扫描的加速搜索条件，同时在检查索引的唯一性约束时会忽略它们。
  - 仅索引扫描 (Index Only Scan) 可以直接返回非键列中的内容，而不必去访问索引所对应的堆表。
  - 将非键列添加为 INCLUDE 列需要保守一些，尤其是对于宽列。如果索引元组超过索引类型允许的最大大小，数据将插入失败。需要注意的是，任何情况下为索引添加非键列都会增加索引的空间占用，从而可能减慢搜索速度。
  - 目前只有ubtree索引访问方式支持该特性。非键列会被保存在与堆元组对应的索引叶子元组中，不会包含在索引上层页面的元组中。


- WITH ( {storage_parameter = value} [, … ] )：指定索引方法的存储参数。取值范围：
  - FILLFACTOR：一个索引的填充因子（fillfactor）是一个介于10和100之间的百分数。
  	取值范围：10~100
  - FASTUPDATE：GIN索引是否使用快速更新。
  	取值范围：ON，OFF
  	默认值：ON
  - GIN_PENDING_LIST_LIMIT：当GIN索引启用fastupdate时，设置该索引pending list容量的最大值。
  	取值范围：64~INT_MAX，单位KB。
  	默认值：gin_pending_list_limit的默认取决于GUC中gin_pending_list_limit的值（默认为4MB）
  - INDEXSPLIT：UBTREE索引选择采取哪种分裂策略。其中DEFAULT策略指的是与BTREE相同的分裂策略。INSERTPT策略能在某些场景下显著降低索引空间占用。
  	取值范围：INSERTPT，DEAFAULT
  	默认值：INSERTPT
  

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 只有GIN索引支持FASTUPDATE、GIN_PENDING_LIST_LIMIT参数。GIN和Psort之外的索引都支持FILLFACTOR参数。只有UBTREE索引支持INDEXSPLIT参数。

- TABLESPACE tablespace_name：指定索引的表空间，如果没有声明则使用默认的表空间。

  取值范围：已存在的表空间名。

- WHERE predicate：创建一个部分索引。部分索引是一个只包含表的一部分记录的索引，通常是该表中比其他部分数据更有用的部分。例如，有一个表，表里包含已记账和未记账的订单，未记账的订单只占表的一小部分而且这部分是最常用的部分，此时就可以通过只在未记账部分创建一个索引来改善性能。另外一个可能的用途是使用带有UNIQUE的WHERE强制一个表的某个子集的唯一性。

  取值范围：predicate表达式只能引用表的字段，它可以使用所有字段，而不仅是被索引的字段。目前，子查询和聚集表达式不能出现在WHERE子句里。不建议使用int等数值类型作为predicate，因为int等数值类型可以隐式转换为bool值（非0值隐式转换为true，0转换为false），可能导致非预期的结果。

- PARTITION index_partition_name：索引分区的名称。

  取值范围：字符串，要符合标识符的命名规范。

- SUBPARTITION index_subpartition_name：索引二级分区的名称。

  取值范围：字符串，要符合标识符的命名规范

- TABLESPACE index_partition_tablespace：索引分区的表空间。

  取值范围：如果没有声明，将使用分区表索引的表空间index_tablespace。

- COMPRESSTYPE：索引参数，设置索引压缩算法。1代表pglz算法，2代表zstd算法，默认不压缩。（仅支持B-TREE索引）

  取值范围：0~2，默认值为0

- COMPRESS_LEVEL：索引参数，设置索引压缩算法等级，仅当COMPRESSTYPE为2时生效。压缩等级越高，索引的压缩效果越好，索引的访问速度越慢。（仅支持B-TREE索引）

  取值范围：-31~31，默认值为0

- COMPRESS_CHUNK_SIZE：索引参数，设置索引压缩chunk块大小。chunk数据块越聚集，预期能达到的压缩效果越好；chunk数据块越离散，索引的访问速度越受影响。（仅支持B-TREE索引）

  取值范围：与页面大小有关。在页面大小为8k场景，取值范围为：512、1024、2048、4096。

  默认值：4096

- COMPRESS_PREALLOC_CHUNKS：索引参数，设置索引压缩chunk块预分配数量。预分配数量越大，索引的压缩率相对越差，离散度越小，访问性能越好。（仅支持B-TREE索引）

  取值范围：0~7，默认值为0

  - 当COMPRESS_CHUNK_SIZE为512和1024时，支持预分配设置最大为7。
  - 当COMPRESS_CHUNK_SIZE为2048时，支持预分配设置最大为3。
  - 当COMPRESS_CHUNK_SIZE为4096时，支持预分配设置最大为1。

- COMPRESS_BYTE_CONVERT：索引参数，设置索引压缩字节转换预处理。在一些场景下可以提升压缩效果，同时会导致一定性能劣化。

  取值范围：布尔值，默认关闭。

- COMPRESS_DIFF_CONVERT：索引参数，设置索引压缩字节差分预处理。只能与compress_byte_convert一起使用。在一些场景下可以提升压缩效果，同时会导致一定性能劣化。

  取值范围：布尔值，默认关闭。

**示例**

- 创建表tpcds.ship_mode_t1。

```
  CREATE schema tpcds;
  CREATE TABLE tpcds.ship_mode_t1
  (
      SM_SHIP_MODE_SK           INTEGER               NOT NULL,
      SM_SHIP_MODE_ID           CHAR(16)              NOT NULL,
      SM_TYPE                   CHAR(30)                      ,
      SM_CODE                   CHAR(10)                      ,
      SM_CARRIER                CHAR(20)                      ,
      SM_CONTRACT               CHAR(20)
  ) 
  ;
```

- 在表tpcds.ship_mode_t1上的SM_SHIP_MODE_SK字段上创建普通的唯一索引。

```
  CREATE UNIQUE INDEX ds_ship_mode_t1_index1 ON tpcds.ship_mode_t1(SM_SHIP_MODE_SK);
```

- 在表tpcds.ship_mode_t1上的SM_SHIP_MODE_SK字段上创建指定B-tree索引。

```
  CREATE INDEX ds_ship_mode_t1_index4 ON tpcds.ship_mode_t1 USING btree(SM_SHIP_MODE_SK);
```

- 在表tpcds.ship_mode_t1上SM_CODE字段上创建表达式索引。

```
  CREATE INDEX ds_ship_mode_t1_index2 ON tpcds.ship_mode_t1(SUBSTR(SM_CODE,1 ,4));
```

- 在表tpcds.ship_mode_t1上的SM_SHIP_MODE_SK字段上创建SM_SHIP_MODE_SK大于10的部分索引。

```
  CREATE UNIQUE INDEX ds_ship_mode_t1_index3 ON tpcds.ship_mode_t1(SM_SHIP_MODE_SK) WHERE SM_SHIP_MODE_SK>10;
```

- 重命名一个现有的索引。

```
  ALTER INDEX tpcds.ds_ship_mode_t1_index1 RENAME TO ds_ship_mode_t1_index5;
```

- 设置索引不可用。

```
  ALTER INDEX tpcds.ds_ship_mode_t1_index2 UNUSABLE;
```

- 重建索引。

```
  ALTER INDEX tpcds.ds_ship_mode_t1_index2 REBUILD;
```

- 删除一个现有的索引。

```
  DROP INDEX tpcds.ds_ship_mode_t1_index2;
```

- 删除表。

```
  DROP TABLE tpcds.ship_mode_t1;
```

- 创建表空间。

```
  CREATE TABLESPACE example1 RELATIVE LOCATION 'tablespace1/tablespace_1';
  CREATE TABLESPACE example2 RELATIVE LOCATION 'tablespace2/tablespace_2';
  CREATE TABLESPACE example3 RELATIVE LOCATION 'tablespace3/tablespace_3';
  CREATE TABLESPACE example4 RELATIVE LOCATION 'tablespace4/tablespace_4';
```

- 创建表tpcds.customer_address_p1。

```
  CREATE TABLE tpcds.customer_address_p1
  (
      CA_ADDRESS_SK             INTEGER               NOT NULL,
      CA_ADDRESS_ID             CHAR(16)              NOT NULL,
      CA_STREET_NUMBER          CHAR(10)                      ,
      CA_STREET_NAME            VARCHAR(60)                   ,
      CA_STREET_TYPE            CHAR(15)                      ,
      CA_SUITE_NUMBER           CHAR(10)                      ,
      CA_CITY                   VARCHAR(60)                   ,
      CA_COUNTY                 VARCHAR(30)                   ,
      CA_STATE                  CHAR(2)                       ,
      CA_ZIP                    CHAR(10)                      ,
      CA_COUNTRY                VARCHAR(20)                   ,
      CA_GMT_OFFSET             DECIMAL(5,2)                  ,
      CA_LOCATION_TYPE          CHAR(20)
  )
  TABLESPACE example1
  PARTITION BY RANGE(CA_ADDRESS_SK)
  ( 
     PARTITION p1 VALUES LESS THAN (3000),
     PARTITION p2 VALUES LESS THAN (5000) TABLESPACE example1,
     PARTITION p3 VALUES LESS THAN (MAXVALUE) TABLESPACE example2
  )
  ENABLE ROW MOVEMENT;
```


- 在线在CA_STREET_NAME字段创建全局索引。

```
  CREATE INDEX CONCURRENTLY idx_global_name ON tpcds.customer_address_p1(CA_STREET_NAME);
```

- 在线在CA_CITY字段创建一级分区索引。

```
  CREATE INDEX CONCURRENTLY idx_local_city ON tpcds.customer_address_p1(CA_CITY);
```

- 创建分区表索引ds_customer_address_p1_index1，不指定索引分区的名称。

```
  CREATE INDEX ds_customer_address_p1_index1 ON tpcds.customer_address_p1(CA_ADDRESS_SK) LOCAL; 
```

- 创建分区表索引ds_customer_address_p1_index2，并指定索引分区的名称。

```
  CREATE INDEX ds_customer_address_p1_index2 ON tpcds.customer_address_p1(CA_ADDRESS_SK) LOCAL
    (
        PARTITION CA_ADDRESS_SK_index1,
        PARTITION CA_ADDRESS_SK_index2 TABLESPACE example3,
        PARTITION CA_ADDRESS_SK_index3 TABLESPACE example4
    ) 
  TABLESPACE example2;
```

- 创建GLOBAL分区索引。
  
```
  CREATE INDEX ds_customer_address_p1_index3 ON tpcds.customer_address_p1(CA_ADDRESS_ID) GLOBAL;
```

- 不指定关键字，默认创建GLOBAL分区索引。

```
  CREATE INDEX ds_customer_address_p1_index4 ON tpcds.customer_address_p1(CA_ADDRESS_ID);
```

- 修改分区表索引CA_ADDRESS_SK_index2的表空间为example1。

```
  ALTER INDEX tpcds.ds_customer_address_p1_index2 MOVE PARTITION CA_ADDRESS_SK_index2 TABLESPACE example1;
```

- 修改分区表索引CA_ADDRESS_SK_index3的表空间为example2。

```
  ALTER INDEX tpcds.ds_customer_address_p1_index2 MOVE PARTITION CA_ADDRESS_SK_index3 TABLESPACE example2;
```

- 重命名分区表索引。

```
  ALTER INDEX tpcds.ds_customer_address_p1_index2 RENAME PARTITION CA_ADDRESS_SK_index1 TO CA_ADDRESS_SK_index4;
```

- 删除索引和分区表。

```
  DROP INDEX tpcds.ds_customer_address_p1_index1;
  DROP INDEX tpcds.ds_customer_address_p1_index2;
  DROP TABLE tpcds.customer_address_p1;
```

- 删除表空间。

```
  DROP TABLESPACE example1;
  DROP TABLESPACE example2;
  DROP TABLESPACE example3;
  DROP TABLESPACE example4;
```

- 创建列存表以及列存表GIN索引。

```
  create table cgin_create_test(a int, b text) with (orientation = column);
  create index cgin_test on cgin_create_test using gin(to_tsvector('ngram', b));
```

**优化建议**

create index

建议仅在匹配如下条件之一时创建索引：

- 经常执行查询的字段。
- 在连接条件上创建索引，对于存在多字段连接的查询，建议在这些字段上建立组合索引。例如，select * from t1 join t2 on t1.a=t2.a and t1.b=t2.b，可以在t1表上的a、b字段上建立组合索引。
- where子句的过滤条件字段上（尤其是范围条件）。
- 在经常出现在order by、group by和distinct后的字段。

约束限制：

- 分区表上不支持创建部分索引。
- 分区表创建GLOBAL索引时，存在以下约束条件：
  - 不支持表达式索引、部分索引
  - 不支持列存表
  - 仅支持B-tree索引
- 在相同属性列上，分区LOCAL索引与GLOBAL索引不能共存。
- GLOBAL索引，最大支持31列。
- 如果alter语句不带有UPDATE GLOBAL INDEX，那么原有的GLOBAL索引将失效，查询时将使用其他索引进行查询；如果alter语句带有UPDATE GLOBAL INDEX，原有的GLOBAL索引仍然有效，并且索引功能正确。

#### 数据类型

##### JSON/JSONB类型

JSON（JavaScript Object Notation）数据，可以是单独的一个标量，也可以是一个数组，也可以是一个键值对象，其中数组和对象可以统称容器（container）：

- 标量（scalar）：单一的数字、bool、string、null都可以叫做标量。
- 数组（array）：[]结构，里面存放的元素可以是任意类型的JSON，并且不要求数组内所有元素都是同一类型。
- 对象（object）：{}结构，存储key:value的键值对，其键只能是用“”包裹起来的字符串，值可以是任意类型的JSON，对于重复的键，按最后一个键值对为准。

Vastbase内存在两种数据类型JSON和JSONB，可以用来存储JSON数据。其中JSON是对输入的字符串的完整拷贝，使用时再去解析，所以它会保留输入的空格、重复键以及顺序等；JSONB解析输入后保存的二进制，它在解析时会删除语义无关的细节和重复的键，对键值也会进行排序，使用时不用再次解析。

因此可以发现，两者其实都是JSON，它们接受相同的字符串作为输入。它们实际的主要差别是效率。JSON数据类型存储输入文本的精确拷贝，处理函数必须在每个执行上重新解析； 而JSONB数据以分解的二进制格式存储，这使得它由于添加了转换机制而在输入上稍微慢些，但是在处理上明显更快，因为不需要重新解析。同时由于JSONB类型存在解析后的格式归一化等操作，同等的语义下只会有一种格式，因此可以更好更强大的支持很多其他额外的操作，比如按照一定的规则进行大小比较等。JSONB也支持索引，这也是一个明显的优势。

**输入格式示例**

输入必须是一个符合JSON数据格式的字符串，此字符串用单引号 ' ' 声明。

- null（null-json）：仅null，全小写。


```
select 'null'::json;  
```

结果显示如下：

```
 json 
--------------
 null
(1 row)
```

- 数字（num-json）：正负整数、小数、0，支持科学计数法，不支持多余的前导0，正数的+号，以及NaN和infinity。


```
select '1'::json,'-1.5'::json,'-1.5e-5'::jsonb, '-1.5e+2'::jsonb;
```

结果显示如下：

```
 json | json |  jsonb   | jsonb 
------+------+----------+-------
 1    | -1.5 | -.000015 | -150
(1 row)
```

- 布尔（bool-json）：仅true、false，全小写。


```
select 'true'::json;
select 'false'::jsonb;  
```

结果显示如下：

```
 json 
 -----------
 true
(1 row)
 jsonb 
 -----------
 false
(1 row)
```

- 字符串（str-json）：必须是加双引号的字符串。


```
select '"a"'::json;
select '"abc"'::jsonb;
```

结果显示如下：

```
 json 
---------
 "a"
(1 row)
 jsonb 
----------
 "abc"
(1 row)
```

- 数组（array-json）：使用中括号[]包裹，满足数组书写条件。数组内元素类型可以是任意合法的JSON，且不要求类型一致。


```
select '[1, 2, "foo", null]'::json;select '[]'::json;
select '[1, 2, "foo", null, [[]], {}]'::jsonb; 
```

结果显示如下：

```
        json  
---------------------
 [1, 2, "foo", null]
(1 row)
 json
-----------
 []
(1 row)
             jsonb
--------------------------------
 [1, 2, "foo", null, [[]], {}]
(1 row)
```

- 对象（object-json）：使用大括号{}包裹，键必须是满足JSON字符串规则的字符串，值可以是任意合法的JSON。

```
select '{}'::json;select '{"a": 1, "b": {"a": 2,  "b": null}}'::json;
select '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::jsonb;  
```

结果显示如下：

```
  json 
------
 {}
(1 row)
                json                 
-------------------------------------
 {"a": 1, "b": {"a": 2,  "b": null}}
(1 row)
                        jsonb                        
-----------------------------------------------------
 {"foo": [true, "bar"], "tags": {"a": 1, "b": null}}
(1 row)

```



> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> - 区分 'null'::json 和 null::json 是两个不同的概念，类似于字符串 str=“” 和 str=null。
> - 对于数字，当使用科学计数法的时候，jsonb类型会将其展开，而json会精准拷贝输入。

**JSONB高级特性**

JSON和JSONB的主要差异在于存储方式上的不同，JSONB存储的是解析后的二进制，能够体现JSON的层次结构，更方便直接访问等，因此JSONB会有很多JSON所不具有的高级特性。

- 注意事项
  - 不支持列存。
  - 不支持作为分区键。
  - 不支持外表、mot。

- 格式归一化，对于输入的object-json字符串，解析成jsonb二进制后，会天然的丢弃语义上无关紧要的细节，比如空格：

```
    select '   [1, " a ", {"a"   :1    }]  '::jsonb;     
```
结果显示如下： 
```
        jsonb         
----------------------
 [1, " a ", {"a": 1}]
(1 row)
```

  - 对于object-json，键值会重新进行排序，排序规则：长度长的在后、长度相等则ascii码大的在后，如：

```
select '{"aa" : 1, "b" : 2, "a" : 3}'::jsonb;   
```

结果显示如下：
```
          jsonb           
---------------------------
 {"a": 3, "b": 2, "aa": 1}
(1 row)
```

  - 对于object-json，会删除重复的键值，只保留最后一个出现的，如：

```
select '{"a" : 1, "a" : 2}'::jsonb; 
```
结果显示如下：

```
  jsonb   
----------
 {"a": 2}
(1 row)
```

- 大小比较：由于经过了格式归一化，保证了同一种语义下的jsonb只会有一种存在形式，因此按照制定的规则，可以比较大小。

  - 首先比较类型：object-jsonb > array-jsonb > bool-jsonb > num-jsonb > str-jsonb > null-jsonb

  - 同类型则比较内容：

    - str-json类型：依据text比较的方法，使用数据库默认排序规则进行比较，返回值正数代表大于，负数代表小于，0表示相等。
    - num-json类型：数值比较。
    - bool-json类型：true > false。
    - array-jsonb类型：长度长的 > 长度短的，长度相等则依次比较每个元素。
    - object-jsonb类型：长度长的 > 长度短的，长度相等则依次比较每个键值对，先比较键，在比较值。
  
    > <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
    >
    > object-jsonb类型内比较时，比较时使用的是格式整理后的最终结果进行比较，因此相对于我们直接的输入未必会很直观。
  
- 创建索引、主外键

  - BTREE索引

    jsonb类型支持创建btree索引，支持创建主键、外键。

  - GIN索引

    GIN索引可以用来有效的搜索出现在大量jsonb文档（datums）中的键或者键/值对。提供了两个GIN操作符类（jsonb_ops、jsonb_hash_ops），提供了不同的性能和灵活性取舍。缺省的GIN操作符类支持使用@>、<@、?、 ?&和?|操作符查询，非缺省的GIN操作符类jsonb_path_ops只支持索引@>、<@操作符。

    相关的操作符请参见JSON/JSONB函数和操作符

- 包含存在

查询一个JSON之中是否包含某些元素，或者某些元素是否存在于某个JSON中是jsonb的一个重要能力。简单的标量/原始值只包含相同的值。

```
SELECT '"foo"'::jsonb @> '"foo"'::jsonb;
```
结果显示如下：
```
 ?column? 
----------
 t
(1 row)
```
  - 左侧数组包含了右侧字符串。

```
SELECT '[1, "aa", 3]'::jsonb ? 'aa';
```
结果显示如下：
```
 ?column? 
----------
 t
(1 row)
```

  - 左侧数组包含了右侧的数组所有元素，顺序、重复不重要。
```
SELECT '[1, 2, 3]'::jsonb @> '[1, 3, 1]'::jsonb;
```
结果显示如下：
```
 ?column? 
----------
 t
(1 row)
```

  - 左侧object-json包含了右侧object-json的所有键值对。

```
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb":true}'::jsonb @> '{"version":9.4}'::jsonb;
```
结果显示如下：
```
 ?column? 
----------
 t
(1 row)
```

  - 左侧数组并没有包含右侧的数组所有元素，因为左侧数组的三个元素为1、2、[1,3]，右侧的为1、3。

```
SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb; 
```
结果显示如下：
```
 ?column? 
----------
 f
(1 row)
```

  相关的操作符请参见JSON/JSONB函数和操作符。

- 函数和操作符

  json/jsonb类型相关支持的函数和操作符请参见JSON/JSONB函数和操作符。

#### 函数和操作符

##### JSON/JSONB函数和操作符

JSON/JSONB通用操作符参考[表1](#JSON/JSONB通用操作符)，JSONB额外支持操作符参考[表2](#JSONB额外支持操作符)

**表 1** JSON/JSONB通用操作符<a id="JSON/JSONB通用操作符"></a>

| 操作符 | 左操作数类型       | 右操作数类型 | 返回类型 | 描述                                             | 例子                                             | 例子结果     |
| :----- | :----------------- | :----------- | :------- | :----------------------------------------------- | :----------------------------------------------- | :----------- |
| ->     | Array-json(b)      | int          | json(b)  | 获得array-json元素。下标不存在返回空。           | '[{“a”:“foo”},{“b”:“bar”},{“c”:“baz”}]'::json->2 | {“c”:“baz”}  |
| ->     | object-json(b)     | text         | json(b)  | 通过键获得值。不存在则返回空。                   | '{“a”: {“b”:“foo”}}'::json->'a'                  | {“b”:“foo”}  |
| ->>    | Array-json(b)      | int          | text     | 获得 JSON 数组元素。下标不存在返回空。           | '[1,2,3]'::json->>2                              | 3            |
| ->>    | object-json(b)     | text         | text     | 通过键获得值。不存在则返回空。                   | '{“a”:1,“b”:2}'::json->>'b'                      | 2            |
| #>     | container-json (b) | text[]       | json(b)  | 获取在指定路径的 JSON 对象，路径不存在则返回空。 | '{“a”: {“b”:{“c”: “foo”}}}'::json #>'{a,b}'      | {“c”: “foo”} |
| #>>    | container-json (b) | text[]       | text     | 获取在指定路径的 JSON 对象，路径不存在则返回空。 | '{“a”:[1,2,3],“b”:[4,5,6]}'::json #>>'{a,2}'     | 3            |



> <div align="left"><img src="image/image2.png" style="zoom:20%")</div> 
> 对于 #> 和 #>> 操作符，当给出的路径无法查找到数据时，不会报错，会返回空。

**表 2**  JSONB额外支持操作符<a id="JSONB额外支持操作符"></a>

| 操作符 | 右操作数类型 | 描述                                              | 例子                                               |
| :----- | :----------- | :------------------------------------------------ | :------------------------------------------------- |
| @>     | jsonb        | 左边的 JSON的顶层是否包含右边JSON的顶层所有项。   | '{“a”:1, “b”:2}'::jsonb @> '{“b”:2}'::jsonb        |
| <@     | jsonb        | 左边的 JSON的所有项是否全部存在于右边JSON的顶层。 | '{“b”:2}'::jsonb <@ '{“a”:1, “b”:2}'::jsonb        |
| ?      | text         | 键/元素的字符串是否存在于 JSON 值的顶层。         | '{“a”:1, “b”:2}'::jsonb ? 'b'                      |
| ?\|    | text[]       | 这些数组字符串中的任何一个是否做为顶层键存在。    | '{“a”:1, “b”:2, “c”:3}'::jsonb ?\| array['b', 'c'] |
| ?&     | text[]       | 是否所有这些数组字符串都作为顶层键存在。          | '[“a”, “b”]'::jsonb ?& array['a', 'b']             |
| =      | jsonb        | 判断两个jsonb的大小关系，同函数jsonb_eq。         | /                                                  |
| <>     | jsonb        | 判断两个jsonb的大小关系，同函数jsonb_ne。         | /                                                  |
| <      | jsonb        | 判断两个jsonb的大小关系，同函数jsonb_lt。         | /                                                  |
| >      | jsonb        | 判断两个jsonb的大小关系，同函数jsonb_gt。         | /                                                  |
| <=     | jsonb        | 判断两个jsonb的大小关系，同函数jsonb_le。         | /                                                  |
| >=     | jsonb        | 判断两个jsonb的大小关系，同函数jsonb_ge。         | /                                                  |

**JSON/JSONB支持的函数**

- array\_to\_json\(anyarray \[, pretty\_bool\]\)

  描述：返回JSON类型的数组。一个多维数组成为一个JSON数组的数组。如果pretty\_bool为true，将在一维元素之间添加换行符。

  返回类型：json

  示例：

  ```
  SELECT array_to_json('{{1,5},{99,100}}'::int[]);
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
    array_to_json   
  ------------------
   [[1,5],[99,100]]
  (1 row)
  ```

- row\_to\_json\(record \[, pretty\_bool\]\)

  描述：返回JSON类型的行。如果pretty\_bool为true，将在第一级元素之间添加换行符。

  返回类型：json

  示例：

  ```
  SELECT row_to_json(row(1,'foo'));
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     row_to_json     
  ---------------------
    {"f1":1,"f2":"foo"}   
    (1 row)
  ```

- json_array_element(array-json, integer)、jsonb_array_element(array-jsonb, integer)

  描述：同操作符'->', 返回数组中指定下标的元素。

  返回类型：json、jsonb

  示例：

  ```
  select json_array_element('[1,true,[1,[2,3]],null]',2);
  ```

  当结果显示如下信息，则表示函数调用成功。
  ```
    json_array_element
    --------------------
    [1,[2,3]]
    (1 row)
  ```

- json_array_element_text(array-json, integer)、jsonb_array_element_text(array-jsonb, integer)

  描述：同操作符'->>', 返回数组中指定下标的元素。

  返回类型：text、text

  示例：

  ```
  select json_array_element_text('[1,true,[1,[2,3]],null]',2);
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
  json_array_element_text
  -----------------------
    [1,[2,3]]
    (1 row)
  ```

- json_object_field(object-json, text)、jsonb_object_field(object-jsonb, text)

  描述：同操作符'->', 返回对象中指定键对应的值。

  返回类型：json、json

  示例：

  ```
  select json_object_field('{"a": {"b":"foo"}}','a');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
  json_object_field
  -------------------
  {"b":"foo"}
  (1 row)
  ```

  json_object_field_text(object-json, text)、jsonb_object_field_text(object-jsonb, text)

  描述：同操作符'->>', 返回对象中指定键对应的值。

  返回类型：text、text

  示例：

  ```
  select json_object_field_text('{"a": {"b":"foo"}}','a');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
    json_object_field_text
    ----------------------
    {"b":"foo"}
    (1 row)
  ```

- json_extract_path(json, VARIADIC text[])、jsonb_extract_path((jsonb, VARIADIC text[])

  描述：等价于操作符'#>'。根据$2所指的路径，查找json，并返回。

  返回类型：json、jsonb

  示例：

  ```
   select json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', 'f4','f6');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     json_extract_path
    -------------------
     "stringy"
    (1 row)
  ```

- json_extract_path_text(json, VARIADIC text[])、jsonb_extract_path_text((jsonb, VARIADIC text[])

  描述：等价于操作符'#>>'。根据$2所指的路径，查找json，并返回。

  返回类型：text、text

  示例：

  ```
  select json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', 'f4','f6');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   json_extract_path_text
  -----------------------
   "stringy"
    (1 row)
  ```

- json_array_elements(array-json)、jsonb_array_elements(array-jsonb)

  描述：拆分数组，每一个元素返回一行。

  返回类型：json、jsonb

  示例：

  ```
  select json_array_elements('[1,true,[1,[2,3]],null]');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
  json_array_elements
  ---------------------
  1
  true
  [1,[2,3]]
  null
  (4 rows)
  ```

- json_array_elements_text(array-json)、jsonb_array_elements_text(array-jsonb)

  描述：拆分数组，每一个元素返回一行。

  返回类型：text、text

  示例：

  ```
  select * from  json_array_elements_text('[1,true,[1,[2,3]],null]');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     value
  -----------
   1
   true
   [1,[2,3]]   
   (4 rows)
  ```
  
  
  
- json_array_length(array-json)、jsonb_array_length(array-jsonb)

  描述：返回数组长度。

  返回类型：integer

  示例：

  ```
  SELECT json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4,null]');
  ```

  当结果显示如下信息，则表示函数调用成功。
  ```
  json_array_length
  -------------------
                    6
  (1 row)
  ```

  

- json_each(object-json)、jsonb_each(object-jsonb)

  描述：将对象的每个键值对拆分转换成一行两列。

  返回类型：setof(key text, value json)、setof(key text, value jsonb)

  示例：

  ```
  select * from  json_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     key |  value
    -----+----------
     f1  | [1,2,3]
     f2  | {"f3":1}
     f4  | null
    (3 rows)
  ```

- json_each_text(object-json)、jsonb_each_text(object-jsonb)

  描述：将对象的每个键值对拆分转换成一行两列。

  返回类型：setof(key text, value text)、setof(key text, value text)

  示例：

  ```
  select * from  json_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     key |  value
    -----+----------
     f1  | [1,2,3]
     f2  | {"f3":1}
     f4  |
    (3 rows)
  ```

- json_object_keys(object-json)、jsonb_object_keys(object-jsonb)

  描述：返回对象中顶层的所有键。

  返回类型：SETOF text

  示例：

  ```
  select json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}, "f1":"abcd"}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     json_object_keys
    ------------------
     f1
     f2
     f1
    (3 rows)
  ```

- jsonb中会有去重操作

  ```
  select jsonb_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}, "f1":"abcd"}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_object_keys
    -------------------
     f1
     f2
    (2 rows)
  ```

- json_populate_record(anyelement, object-json [, bool])、jsonb_populate_record(anyelement, object-jsonb [, bool])

  描述：$1必须是一个复合类型的参数。将会把object-json里的每个对键值进行拆分，以键当做列名，与$1中的列名进行匹配查找，并填充到$1的格式中。

  返回类型：anyelement、anyelement

  示例：

  1、创建类型jpop。

  ```
  create type jpop as (a text, b int, c bool);
  ```

  2、查询验证。

  ```
  select * from json_populate_record(null::jpop,'{"a":"blurfl","x":43.2}');
  ```

   当结果显示如下信息，则表示函数调用成功。

  ```
      a    | b | c
    --------+---+---
     blurfl |   |
    (1 row)
  ```

  3、查询验证。

  ```
  select * from json_populate_record((1,1,null)::jpop,'{"a":"blurfl","x":43.2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
       a    | b | c
    --------+---+---
     blurfl | 1 |
    (1 row)
  ```

  

- json_populate_record_set(anyelement, array-json [, bool])、jsonb_populate_record_set(anyelement, array-jsonb [, bool])

  描述：参考上述函数json_populate_record、jsonb_populate_record，对$2数组的每一个元素进行上述参数函数的操作，因此这也要求$2数组的每个元素都是object-json类型的。

  返回类型：setof anyelement、setof anyelement

  示例：

  1、创建类型jpop

  ```
  create type jpop as (a text, b int, c bool);
  ```

  2、查询验证

  ```
  select * from json_populate_recordset(null::jpop, '[{"a":1,"b":2},{"a":3,"b":4}]');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     a | b | c
    ---+---+---
     1 | 2 |
     3 | 4 |
    (2 rows)
  ```

- json_typeof(json)、jsonb_typeof(jsonb)

  描述：检测json类型

  返回类型：text、text

  示例：

  ```
  select value, json_typeof(value) from (values (json '123.4'), (json '"foo"'), (json 'true'), (json 'null'), (json '[1, 2, 3]'), (json '{"x":"foo", "y":123}'), (NULL::json))  as data(value);
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
            value         | json_typeof
    ----------------------+-------------
     123.4                | number
     "foo"                | string
     true                 | boolean
     null                 | null
     [1, 2, 3]            | array
     {"x":"foo", "y":123} | object
                          |
    (7 rows)
  ```

- json_build_array( [VARIADIC “any”] )

  描述：从一个可变参数列表构造出一个JSON数组。

  返回类型：array-json

  示例：

  ```
  select json_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}','');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
                                json_build_array                               
  -----------------------------------------------------------------------------
   ["a", 1, "b", 1.2, "c", true, "d", null, "e", {"x": 3, "y": [1,2,3]}, null]
  (1 row)
  ```

- json_build_object( [VARIADIC “any”] )

  描述：从一个可变参数列表构造出一个JSON对象，其入参必须为偶数个，两两一组组成键值对。注意键不可为null。

  返回类型：object-json

  示例：

  ```
  select json_build_object(1,2);
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     json_build_object
    -------------------
     {"1" : 2}
    (1 row)
  ```

- json_to_record(object-json, bool)

  描述：正如所有返回record 的函数一样，调用者必须用一个AS子句显式地定义记录的结构。会将object-json的键值对进行拆分重组，把键当做列名，去匹配填充as显示指定的记录的结构。

  返回类型：record

  示例：

  ```
  select * from json_to_record('{"a":1,"b":"foo","c":"bar"}',true) as x(a int, b text, d text);
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     a |  b  | d
    ---+-----+---
     1 | foo |
    (1 row)
  ```

- json_to_recordset(array-json, bool)

  描述：参考函数json_to_record，对数组内个每个元素，执行上述函数的操作，因此这要求数组内的每个元素都得是object-json。

  返回类型：setof record

  示例：

  ```
  select * from json_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]',false) as x(a int, b text, c boolean);
  
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     a |  b  | c
    ---+-----+---
     1 | foo |
     2 | bar | t
    (2 rows)
  ```

- json_object(text[])、json_object(text[], text[])

  描述：从一个文本数组构造一个object-json。这是个重载函数，当入参为一个文本数组的时候，其数组长度必须为偶数，成员被当做交替出现的键/值对。两个文本数组的时候，第一个数组认为是键，第二个认为是值，两个数组长度必须相等。键不可为null。

  返回类型：object-json

  示例1：

  ```
   select json_object('{a,1,b,2,3,NULL,"d e f","a b c"}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
                          json_object
    -------------------------------------------------------
     {"a" : "1", "b" : "2", "3" : null, "d e f" : "a b c"}
    (1 row)
  ```

  示例2：

  ```
  select json_object('{a,b,"a b c"}', '{a,1,1}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
                  json_object
    ---------------------------------------
     {"a" : "a", "b" : "1", "a b c" : "1"}
    (1 row)
  ```

- json_agg(any)

  描述：将值聚集为json数组。

  返回类型：array-json

  示例：

  1、创建测试表class。

  ```
  CREATE TABLE class(name varchar,score int);
  INSERT INTO class(name,score) values ('A' ,'2');
  INSERT INTO class(name,score) values ('A' ,'3');
  INSERT INTO class(name,score) values ('D' ,'5');
  INSERT INTO class(name,score) values ('D' ,'');
  ```

  2、调用函数进行验证。

  ```
  select name, json_agg(score),score from classes group by name order by name;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   name | json_agg  
  ------+-----------
   A    | [2, 3]
   D    | [5, null]
  (2 rows)
  ```

- json_object_agg(any, any)

  描述：将值聚集为json对象。

  返回类型：object-json

  示例：

  1、创建测试表class。

  ```
  CREATE TABLE class(name varchar,score int);
  INSERT INTO class(name,score) values ('A' ,'2');
  INSERT INTO class(name,score) values ('A' ,'3');
  INSERT INTO class(name,score) values ('D' ,'5');
  INSERT INTO class(name,score) values ('D' ,'');
  ```

  2、调用函数进行验证。

  ```
  select json_object_agg(name, score) from class group by name order by name;
  ```

  当结果显示如下信息，则表示函数调用成功。
  ```
         json_object_agg
    -------------------------
     { "A" : 2, "A" : 3 }
     { "D" : 5, "D" : null }
    (2 rows)
  ```

- jsonb_contained(jsonb, jsonb)

  描述：同操作符 '<@', 判断$1中的所有元素是否在$2的顶层存在。

  返回类型：bool

  示例：

  ```
  select jsonb_contained('[1,2,3]', '[1,2,3,4]');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_contained
    -----------------
     t
    (1 row)
  ```

- jsonb_contains(jsonb, jsonb)

  描述：同操作符 '@>', 判断$1中的顶层所有元素是否包含在$2的所有元素。

  返回类型：bool

  示例：

  ```
  select jsonb_contains('[1,2,3,4]', '[1,2,3]');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_contains
    ----------------
     t
    (1 row)
  ```

- jsonb_exists(jsonb, text)

  描述：同操作符 '?', 字符串$2是否存在$1的顶层以key\elem\scalar的形式存在。

  返回类型：bool

  示例：

  ```
  select jsonb_exists('["1",2,3]', '1');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_exists
    --------------
     t
    (1 row)
  ```

- jsonb_exists_all(jsonb, text[])

  描述：同操作符 '?&', 字符串数组$2里面，是否所有的元素，都在$1的顶层以key\elem\scalar的形式存在。

  返回类型：bool

  示例：

  ```
  select jsonb_exists_all('["1","2",3]', '{1, 2}');
  ```

  当结果显示如下信息，则表示函数调用成功。
  ```
     jsonb_exists_all
    ------------------
     t
    (1 row)
  ```

- jsonb_exists_any(jsonb, text[])

  描述：同操作符 '?|', 字符串数组$2里面，是否存在的元素，在$1的顶层以key\elem\scalar的形式存在。

  返回类型：bool

  示例：

  ```
  select jsonb_exists_any('["1","2",3]', '{1, 2, 4}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_exists_any
    ------------------
     t
    (1 row)
  ```

  

- jsonb_cmp(jsonb, jsonb)

  描述：比较大小，正数代表大于，负数代表小于，0表示相等。

  返回类型：integer

  示例：

  ```
  select jsonb_cmp('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   jsonb_cmp
   -----------
            -1
    (1 row)
  ```

- jsonb_eq(jsonb, jsonb)

  描述：同操作符 '=', 比较两个值的大小。

  返回类型：bool

  示例：

  ```
  select jsonb_eq('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_eq
    ----------
     f
    (1 row)
  ```

  

- jsonb_ne(jsonb, jsonb)

  描述：同操作符 '<>', 比较两个值的大小。

  返回类型：bool

  示例：

  ```
  select jsonb_ne('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_ne
    ----------
     t
    (1 row)
  ```

- jsonb_gt(jsonb, jsonb)

  描述：同操作符 '>', 比较两个值的大小。

  返回类型：bool

  示例：

  ```
  select jsonb_gt('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_gt
    ----------
     f
    (1 row)
  ```

- jsonb_ge(jsonb, jsonb)

  描述：同操作符 '>=', 比较两个值的大小。

  返回类型：bool

  示例：

  ```
  select jsonb_ge('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_ge
    ----------
     f
    (1 row)
  ```

- jsonb_lt(jsonb, jsonb)

  描述：同操作符 '<', 比较两个值的大小。

  返回类型：bool

  示例：

  ```
  select jsonb_lt('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。
  ```
     jsonb_lt
    ----------
     t
    (1 row)
  ```

- jsonb_le(jsonb, jsonb)

  描述：同操作符 '<=', 比较两个值的大小。

  返回类型：bool

  示例：

  ```
  select jsonb_le('["a", "b"]', '{"a":1, "b":2}');
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     jsonb_le
    ----------
     t
    (1 row)
  ```

- to_json(anyelement)

  描述：把参数转换为'json'。

  返回类型：json

  示例：

  ```
  select to_json('{1,5}'::text[]);
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
      to_json
    -----------
     ["1","5"]
    (1 row)
  ```

- jsonb_hash(jsonb)

  描述：对jsonb进行hash运算。

  返回类型：integer

  示例：

  ```
  select jsonb_hash('[1,2,3]');
  ```

  当结果显示如下信息，则表示函数调用成功。
  ```
   jsonb_hash
  ------------
   -559968547
  (1 row)
  ```

- 其他函数

  描述：gin索引以及json\jsonb聚集函数所用到的内部函数，功能不过多赘述。

  ```
   gin_compare_jsonb
   gin_consistent_jsonb
   gin_consistent_jsonb_hash
   gin_extract_jsonb
   gin_extract_jsonb_hash
   gin_extract_jsonb_query
   gin_extract_jsonb_query_hash
   gin_triconsistent_jsonb
   gin_triconsistent_jsonb_hash
       
   json_agg_transfn
   json_agg_finalfn
   json_object_agg_transfn
   json_object_agg_finalfn
  ```

##### 数组函数和操作符

**数组操作符**

| 操作符 | 描述                                       | 例子                                     |
| :----- | :----------------------------------------- | :--------------------------------------- |
| =      | 两个数组是否相等                           | ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3] |
| <>     | 两个数组是否不相等                         | ARRAY[1,2,3] <> ARRAY[1,2,4]             |
| <      | 一个数组是否小于另一个数组                 | ARRAY[1,2,3] < ARRAY[1,2,4]              |
| >      | 一个数组是否大于另一个数组                 | ARRAY[1,4,3] > ARRAY[1,2,4]              |
| <=     | 一个数组是否小于或等于另一个数组           | ARRAY[1,2,3] <= ARRAY[1,2,3]             |
| >=     | 一个数组是否大于或等于另一个数组           | ARRAY[1,4,3] >= ARRAY[1,4,3]             |
| @>     | 一个数组是否包含另一个数组                 | ARRAY[1,4,3] @> ARRAY[3,1]               |
| <@     | 一个数组是否被包含于另一个数组             | ARRAY[2,7] <@ ARRAY[1,7,4,2,6]           |
| &&     | 一个数组是否和另一个数组重叠（有共同元素） | ARRAY[1,4,3] && ARRAY[2,1]               |
| \|\|   | 数组与数组进行连接                         | ARRAY[1,2,3] \|\| ARRAY[4,5,6]           |
| \|\|   | 元素与数组进行连接                         | 3 \|\| ARRAY[4,5,6]                      |
| \|\|   | 数组与元素进行连接                         | ARRAY[4,5,6] \|\| 7                      |

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 数组比较是使用默认的B-tree比较函数对所有元素逐一进行比较的。多维数组的元素按照行顺序进行访问。如果两个数组的内容相同但维数不等，决定排序顺序的首要因素是维数。

**数组函数**

| 函数名                                                       | 描述                                                         | 返回类型         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :--------------- |
| [array_append(anyarray, anyelement)](#array_append)          | 向数组末尾添加元素，只支持一维数组。                         | anyarray         |
| [array_prepend(anyelement, anyarray)](#array_prepend(anyelement, anyarray)) | 向数组开头添加元素，只支持一维数组。                         | anyarray         |
| [array_cat(anyarray, anyarray)](#array_cat(anyarray, anyarray)) | 连接两个数组，支持多维数组。                                 | anyarray         |
| [array_ndims(anyarray)](#array_ndims(anyarray))              | 返回数组的维数。                                             | int              |
| [array_dims(anyarray)](#array_dims(anyarray))                | 返回数组各个维度中的低位下标值和高位下标值。                 | text             |
| [array_length(anyarray, int)](#array_length(anyarray, int))  | 返回指定数组维度的长度。int为指定数组维度。                  | int              |
| [array_lower(anyarray, int)](#array_lower(anyarray, int))    | 返回指定数组维数的下界。int为指定数组维度。                  | int              |
| [array_upper(anyarray, int)](#array_upper(anyarray, int))    | 返回指定数组维数的上界。int为指定数组维度。                  | int              |
| [array_to_string(anyarray, text [, text])](#array_to_string(anyarray, text [, text])) | 使用第一个text作为数组的新分隔符，使用第二个text替换数组值为null的值。 | text             |
| [string_to_array(text, text [, text])](#string_to_array(text, text [, text])) | 使用第二个text指定分隔符，使用第三个可选的text作为NULL值替换模板，如果分隔后的子串与第三个可选的text完全匹配，则将其替换为NULL。 | text[]           |
| [unnest(anyarray)](#unnest(anyarray))                        | 扩大一个数组为一组行。                                       | setof anyelement |
| [array_position(anyarray,anyelement,[,integer])](#array_position(anyarray,anyelement,[,integer])) | 实现在数组搜索元素，返回该元素在数组中第一次出现的下标       | -                |

**示例**

- array_append(anyarray, anyelement)<a id='array_append'></a>

  ```
  SELECT array_append(ARRAY[1,2], 3) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result  
  ---------
   {1,2,3}
  (1 row)
  ```

- array_prepend(anyelement, anyarray)<a id='array_prepend(anyelement, anyarray)'></a>

  ```
  SELECT array_prepend(1, ARRAY[2,3]) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result  
  ---------
   {1,2,3}
  (1 row)
  ```

- array_cat(anyarray, anyarray)<a id='array_cat(anyarray, anyarray)'></a>

  ```
  SELECT array_cat(ARRAY[1,2,3], ARRAY[4,5]) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     result    
  -------------
   {1,2,3,4,5}
  (1 row)
  ```

  示例2：

  ```
  SELECT array_cat(ARRAY[[1,2],[4,5]], ARRAY[6,7]) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
         result        
  ---------------------
   {{1,2},{4,5},{6,7}}
  (1 row)
  ```

- array_ndims(anyarray)<a id='array_ndims(anyarray)'></a>

  ```
  SELECT array_ndims(ARRAY[[1,2,3], [4,5,6]]) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result 
  --------
        2
  (1 row)
  ```

- array_dims(anyarray)<a id='array_dims(anyarray)'></a>

  ```
  SELECT array_dims(ARRAY[[1,2,3], [4,5,6]]) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     result   
  ------------
   [1:2][1:3]
  (1 row)
  ```

- array_length(anyarray, int)<a id='array_length(anyarray, int)'></a>

  示例1：

  ```
  SELECT array_length(array[1,2,3], 1) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result 
  --------
       3
  (1 row)
  ```

   示例2：

  ```
  SELECT array_length(array[[1,2,3],[4,5,6]], 2) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result
  --------
        3
  (1 row)
  ```

- array_lower(anyarray, int)<a id='array_lower(anyarray, int)'></a>

  ```
  SELECT array_lower('[0:2]={1,2,3}'::int[], 1) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result 
  --------
        0
  (1 row)
  ```

- array_upper(anyarray, int)<a id='array_upper(anyarray, int)'></a>

  ```
  SELECT array_upper(ARRAY[1,8,3,7], 1) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result 
  --------
        4
  (1 row)
  ```

- array_to_string(anyarray, text [, text])<a id='array_to_string(anyarray, text [, text])'></a>

  描述：

  返回类型：

  ```
  SELECT array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*') AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
    result   
  -----------
   1,2,3,*,5
  (1 row)
  ```

  > <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
  >
  > 在array_to_string中，如果省略null字符串参数或为NULL，运算中将跳过在数组中的任何null元素，并且不会在输出字符串中出现。

- string_to_array(text, text [, text])<a id='string_to_array(text, text [, text])'></a>

  示例1：

  ```
  SELECT string_to_array('xx~^~yy~^~zz', '~^~', 'yy') AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
      result    
  --------------
   {xx,NULL,zz}
  (1 row)
  ```

  示例2：

  ```
  SELECT string_to_array('xx~^~yy~^~zz', '~^~', 'y') AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
     result   
  ------------
   {xx,yy,zz}
  (1 row)
  ```

  > <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
  >
  > 在string_to_array中，如果分隔符参数是NULL，输入字符串中的每个字符将在结果数组中变成一个独立的元素。如果分隔符是一个空白字符串，则整个输入的字符串将变为一个元素的数组。否则输入字符串将在每个分隔字符串处分开。如果省略null字符串参数或为NULL，将字符串中没有输入内容的子串替换为NULL。

- unnest(anyarray)<a id='unnest(anyarray)'></a>

  ```
  SELECT unnest(ARRAY[1,2]) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result 
  --------
        1
        2
  (2 rows)
  ```

- array_position(anyarray,anyelement,[,integer])<a id='array_position(anyarray,anyelement,[,integer])'></a>

  ```
  SELECT array_position(array[1,4,2,5,7],2) AS RESULT;
  ```

  当结果显示如下信息，则表示函数调用成功。

  ```
   result 
  --------
        3
  (1 row)
  ```




#### 类型转换

##### 概述

在SQL语言中，每个数据都与一个决定其行为和用法的数据类型相关。Vastbase提供一个可扩展的数据类型系统，该系统比其它SQL实现更具通用性和灵活性。因而，Vastbase中大多数类型转换是由通用规则来管理的，这种做法允许使用混合类型的表达式。

Vastbase扫描/分析器只将词法元素分解成五个基本种类：整数、浮点数、字符串、标识符和关键字。大多数非数字类型首先表现为字符串。SQL语言的定义允许将常量字符串声明为具体的类型。例如下面查询：

```
SELECT text 'Origin' AS "label", point '(0,0)' AS "value"; 
 label  | value 
--------+------- 
 Origin | (0,0) 
(1 row)
```

示例中有两个文本常量，类型分别为text和point。如果没有为字符串文本声明类型，则该文本首先被定义成一个unknown类型。

在Vastbase分析器里，有四种基本的SQL结构需要独立的类型转换规则：

- 函数调用

多数SQL类型系统是建筑在一套丰富的函数上的。函数调用可以有一个或多个参数。因为SQL允许函数重载，所以不能通过函数名直接找到要调用的函数，分析器必须根据函数提供的参数类型选择正确的函数。

- 操作符

SQL允许在表达式上使用前缀或后缀（单目）操作符，也允许表达式内部使用双目操作符（两个参数）。像函数一样，操作符也可以被重载，因此操作符的选择也和函数一样取决于参数类型。

- 值存储

INSERT和UPDATE语句将表达式结果存入表中。语句中的表达式类型必须和目标字段的类型一致或者可以转换为一致。

- UNION，CASE和相关构造

因为联合SELECT语句中的所有查询结果必须在一列里显示出来，所以每个SELECT子句中的元素类型必须相互匹配并转换成一个统一类型。类似地，一个CASE构造的结果表达式必须转换成统一的类型，这样整个CASE表达式会有一个统一的输出类型。同样的要求也存在于ARRAY构造以及GREATEST和LEAST函数中。

系统表pg_cast存储了有关数据类型之间的转换关系以及如何执行这些转换的信息。详细信息请参见“PG_CAST”章节。

语义分析阶段会决定表达式的返回值类型并选择适当的转换行为。数据类型的基本类型分类，包括：Boolean，numeric，string，bitstring，datetime，timespan，geometric和network。每种类型都有一种或多种首选类型用于解决类型选择的问题。根据首选类型和可用的隐含转换，就可能保证有歧义的表达式（那些有多个候选解析方案的）得到有效的方式解决。

所有类型转换规则都是建立在下面几个基本原则上的：

- 隐含转换决不能有奇怪的或不可预见的输出。

- 如果一个查询不需要隐含的类型转换，分析器和执行器不应该进行更多的额外操作。这就是说，任何一个类型匹配、格式清晰的查询不应该在分析器里耗费更多的时间，也不应该向查询中引入任何不必要的隐含类型转换调用。

- 另外，如果一个查询在调用某个函数时需要进行隐式转换，当用户定义了一个有正确参数的函数后，解释器应该选择使用新函数。

##### 操作符

**操作符类型解析**

1、从系统表pg_operator中选出要考虑的操作符。如果可以找到一个参数类型以及参数个数都一致的操作符，那么这个操作符就是最终使用的操作符。如果找到了多个备选的操作符，我们将从中选择一个最合适的。

2、寻找最优匹配。

- 抛弃那些输入类型不匹配并且也不能隐式转换成匹配的候选操作符。unknown文本在这种情况下可以转换成任何东西。如果只剩下一个候选项，则用之，否则继续下一步。
- 遍历所有候选操作符，保留那些输入类型匹配最准确的。此时，域被看作和他们的基本类型相同。如果没有一个操作符能被保留，则保留所有候选。如果只剩下一个候选项，则用之，否则继续下一步。
- 遍历所有候选操作符，保留那些需要类型转换时接受(属于输入数据类型的类型范畴的)首选类型位置最多的操作符。如果没有接受首选类型的操作符，则保留所有候选。如果只剩下一个候选项，则用之，否则继续下一步。
- 如果有任何输入参数是unknown类型，检查剩余的候选操作符对应参数位置的类型范畴。在每一个能够接受字符串类型范畴的位置使用string类型（这种对字符串的偏爱是合适的，因为unknown文本确实像字符串）。另外，如果所有剩下的候选操作符都接受相同的类型范畴，则选择该类型范畴，否则抛出一个错误（因为在没有更多线索的条件下无法作出正确的选择）。现在抛弃不接受选定的类型范畴的候选操作符，然后，如果任意候选操作符在某个给定的参数位置接受一个首选类型，则抛弃那些在该参数位置接受非首选类型的候选操作符。如果没有一个操作符能被保留，则保留所有候选。如果只剩下一个候选项，则用之，否则继续下一步。
- 如果同时有unknown和已知类型的参数，并且所有已知类型的参数都是相同的类型，那么假设unknown参数也是那种类型，并检查哪个候选操作符在unknown参数位置接受那个类型。如果只有一个操作符符合，那么使用它。否则，产生一个错误。

**示例**

- 阶乘操作符类型解析。在系统表中里只有一个阶乘操作符（后缀!），它以bigint作为参数。扫描器给下面查询表达式的参数赋予bigint的初始类型：


```
SELECT 40 ! AS "40 factorial"; 
```

 结果显示如下：

```
          40 factorial 
-------------------------------------------------- 
 815915283247897734345611269596115894272000000000 
(1 row)
```

分析器对参数做类型转换，查询等效于：

```
SELECT CAST(40 AS bigint) ! AS "40 factorial";
```

- 字符串连接操作符类型分析。一种字符串风格的语法既可以用于字符串也可以用于复杂的扩展类型。未声明类型的字符串将被所有可能的候选操作符匹配。有一个未声明的参数的例子：


```
SELECT text 'abc' || 'def' AS "text and unknown"; 
```

 结果显示如下：

```
 text and unknown 
------------------ 
 abcdef 
(1 row)
```

本例中分析器寻找两个参数都是text的操作符。确实有这样的操作符，两个参数都是text类型。

下面是连接两个未声明类型的值：

```
SELECT 'abc' || 'def' AS "unspecified"; 
```

  结果显示如下：

```
unspecified 
------------- 
 abcdef 
(1 row)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> 因为查询中没有声明任何类型，所以本例中对类型没有任何初始提示。因此，分析器查找所有候选操作符，发现既存在接受字符串类型范畴的操作符也存在接受位串类型范畴的操作符。因为字符串类型范畴是首选，所以选择字符串类型范畴的首选类型text作为解析未知类型文本的声明类型。

- 绝对值和取反操作符类型分析。Vastbase操作符表里面有几条记录对应于前缀操作符@，它们都用于为各种数值类型实现绝对值操作。其中之一用于float8类型，它是数值类型范畴中的首选类型。因此，在面对unknown输入的时候， Vastbase会使用该类型：


```
SELECT @ '-4.5' AS "abs"; 
```

   结果显示如下：

```
abs 
----- 
 4.5 
(1 row)
```

此处，系统在应用选定的操作符之前隐式的转换unknown类型的文字为float8类型。

- 数组包含操作符类型分析。这里是解决一个操作符带有一个已知和一个未知类型输入的例子：


```
SELECT array[1,2] <@ '{1,2,3}' as "is subset"; 
```

 结果显示如下：

```
 is subset 
----------- 
 t 
(1 row)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> Vastbase操作符表有几条记录对应于中缀操作符<@，但是只有两个可以在左侧接受一个整数数组的操作符是数组包含(anyarray <@ anyarray) 和范围包含(anyelement <@ anyrange)的。因为没有多态的伪类型(参阅12.3.15伪类型)是首选的，所以解析器不能解决这个基础上的歧义。然而，最后一个解析规则告诉用户，假设未知类型的文字是和另外一个输入相同的类型，也就是，整数数组。现在只有两个操作符中的一个可以匹配，所以选择数组包含。（如果用户选择了范围包含，用户将得到一个错误，因为字符串没有正确的格式成为范围的文字。）

##### 函数

**函数类型解析**

1、从系统表pg_proc中选择所有可能被选到的函数。如果使用了一个不带模式修饰的函数名称，那么认为该函数是那些在当前搜索路径中的函数。如果给出一个带修饰的函数名，那么只考虑指定模式中的函数。如果搜索路径中找到了多个不同参数类型的函数。将从中选择一个合适的函数。

2、查找和输入参数类型完全匹配的函数。如果找到一个，则用之。如果输入的实参类型都是unknown类型，则不会找到匹配的函数。

3、如果未找到完全匹配，请查看该函数是否为一个特殊的类型转换函数。

4、寻找最优匹配。

- 抛弃那些输入类型不匹配并且也不能隐式转换成匹配的候选函数。unknown文本在这种情况下可以转换成任何东西。如果只剩下一个候选项，则用之，否则继续下一步。

- 遍历所有候选函数，保留那些输入类型匹配最准确的。此时，域被看作和它们的基本类型相同。如果没有一个函数能准确匹配，则保留所有候选。如果只剩下一个候选项，则用之，否则继续下一步。

- 遍历所有候选函数，保留那些需要类型转换时接受首选类型位置最多的函数。如果没有接受首选类型的函数，则保留所有候选。如果只剩下一个候选项，则用之，否则继续下一步。

- 如果有任何输入参数是unknown类型，检查剩余的候选函数对应参数位置的类型范畴。在每一个能够接受字符串类型范畴的位置使用string类型（这种对字符串的偏爱是合适的，因为unknown文本确实像字符串）。另外，如果所有剩下的候选函数都接受相同的类型范畴，则选择该类型范畴，否则抛出一个错误（因为在没有更多线索的条件下无法作出正确的选择）。现在抛弃不接受选定的类型范畴的候选函数，然后，如果任意候选函数在那个范畴接受一个首选类型，则抛弃那些在该参数位置接受非首选类型的候选函数。如果没有一个候选符合这些测试则保留所有候选。如果只有一个候选函数符合，则使用它；否则，继续下一步。

- 如果同时有unknown和已知类型的参数，并且所有已知类型的参数有相同的类型，假设unknown参数也是这种类型，检查哪个候选函数可以在unknown参数位置接受这种类型。如果正好一个候选符合，那么使用它。否则，产生一个错误。

**示例**

- 圆整函数参数类型解析。只有一个round函数有两个参数（第一个是numeric，第二个是integer）。所以下面的查询自动把第一个类型为integer的参数转换成numeric类型。


```
 SELECT round(4, 4); 
```

结果显示如下：

```
 round 
-------- 
 4.0000 
(1 row)
```

实际上它被分析器转换成：

```
SELECT round(CAST (4 AS numeric), 4);
```

因为带小数点的数值常量初始时被赋予numeric类型，因此下面的查询将不需要类型转换，并且可能会略微高效一些：

```
SELECT round(4.0, 4);
```

- 子字符串函数类型解析。有好几个substr函数，其中一个接受text和integer类型。如果用一个未声明类型的字符串常量调用它，系统将选择接受string类型范畴的首选类型（也就是text类型）的候选函数。


```
SELECT substr('1234', 3); 
```

结果显示如下：

```
 substr 
-------- 
   34 
(1 row)
```

如果该字符串声明为varchar类型，就像从表中取出来的数据一样，分析器将试着将其转换成text类型：

```
SELECT substr(varchar '1234', 3); 
```

结果显示如下：

```
 substr 
-------- 
   34 
(1 row)
```

被分析器转换后实际上变成：

```
SELECT substr(CAST (varchar '1234' AS text), 3);
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>    
>
> 分析器从pg_cast表中了解到text和varchar是二进制兼容的，意思是说一个可以传递给接受另一个的函数而不需要做任何物理转换。因此，在这种情况下，实际上没有做任何类型转换。

如果以integer为参数调用函数，分析器将试图将其转换成text类型：

```
SELECT substr(1234, 3); 
```

结果显示如下：

```
substr 
-------- 
 34 
(1 row)
```

被分析器转换后实际上变成：

```
SELECT substr(CAST (1234 AS text), 3); 
```

结果显示如下：

```
 substr 
-------- 
   34 
(1 row)
```

##### 值存储

**值存储数据类型解析**

1、查找与目标字段准确的匹配。

2、试着将表达式直接转换成目标类型。如果已知这两种类型之间存在一个已注册的转换函数，那么直接调用该转换函数即可。如果表达式是一个未知类型文本，该文本字符串的内容将交给目标类型的输入转换过程。

3、检查一下看目标类型是否有长度转换。长度转换是一个从某类型到自身的转换。如果在pg_cast表里面找到一个，那么在存储到目标字段之前先在表达式上应用。这样的转换函数总是接受一个额外的类型为integer的参数，它接收目标字段的atttypmod值（实际上是其声明长度，atttypmod的解释随不同的数据类型而不同），并且它可能接受一个Boolean类型的第三个参数，表示转换是显式的还是隐式的。转换函数负责施加那些长度相关的语义，比如长度检查或者截断。

**示例**

character存储类型转换。对一个目标列定义为character(20)的语句，下面的示例显示存储值的长度正确：

1、创建测试表。

```
CREATE TABLE value_storage_t1 ( 
  VS_COL1 CHARACTER(20) 
); 
```

2、插入测试数据。

```
INSERT INTO value_storage_t1 VALUES('abcdef'); 
```

3、查询结果。

```
SELECT VS_COL1, octet_length(VS_COL1) FROM value_storage_t1; 
```

当结果显示如下信息，则表示存储值长度正确。

```
   vs_col1     | octet_length  
----------------------+-------------- 
 abcdef        |      20 
(1 row) 
) 
```

4、删除测试表。

```
DROP TABLE value_storage_t1;
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 这里真正发生的事情是两个unknown文本缺省解析成text，这样就允许||操作符解析成text连接。然后操作符的text结果转换成bpchar("空白填充的字符型"， character类型内部名称)以匹配目标字段类型。不过，从text到bpchar的转换是二进制兼容的，这样的转换是隐含的并且实际上不做任何函数调用。最后，在系统表里找到长度转换函数bpchar(bpchar, integer, Boolean) 并且应用于该操作符的结果和存储的字段长。这个类型相关的函数执行所需的长度检查和额外的空白填充。

##### UNION,CASE和相关构造

SQL UNION构造必须把那些可能不太相似的类型匹配起来成为一个结果集。解析算法分别应用于联合查询的每个输出字段。INTERSECT和EXCEPT构造对不相同的类型使用和UNION相同的算法进行解析。CASE、ARRAY、VALUES、GREATEST和LEAST构造也使用同样的算法匹配它的部件表达式并且选择一个结果数据类型。

**UNION，CASE和相关构造解析**

- 如果所有输入都是相同的类型，并且不是unknown类型，那么解析成这种类型。
- 如果所有输入都是unknown类型则解析成text类型（字符串类型范畴的首选类型）。否则，忽略unknown输入。
- 如果输入不属于同一个类型范畴（unknown类型除外），失败。
- 如果输入类型是同一个类型范畴，则选择该类型范畴的首选类型（例外：union操作会选择第一个分支的类型作为所选类型）。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>    
>
> 系统表pg_type中typcategory表示数据类型范畴， typispreferred表示是否是typcategory分类中的首选类型。

- 把所有输入转换为所选的类型（对于字符串保持原有长度）。如果从给定的输入到所选的类型没有隐式转换则失败。
- 若输入中含json、txid_snapshot、sys_refcursor或几何类型，则不能进行union。

**对于case和coalesce，在TD兼容模式下的处理**

- 如果所有输入都是相同的类型，并且不是unknown类型，那么解析成这种类型。
- 如果所有输入都是unknown类型则解析成text类型。
- 如果输入字符串（包括unknown，unknown当text来处理）和数字类型，那么解析成字符串类型，如果是其他不同的类型范畴，则报错。
- 如果输入类型是同一个类型范畴，则选择该类型的优先级较高的类型。
- 把所有输入转换为所选的类型。如果从给定的输入到所选的类型没有隐式转换则失败。

**对于case，在ORA兼容模式下的处理**

decode(expr, search1, result1, search2, result2, …, defresult)，也即 case expr when search1 then result1 when search2 then result2 else defresult end; 在ORA兼容模式下的处理，将整个表达式最终的返回值类型定为result1的数据类型，或者与result1同类型范畴的更高精度的数据类型。（例如，numeric与int同属数值类型范畴，但numeric比int精度要高，具有更高优先级）

- 将result1的数据类型置为最终的返回值类型preferType，其所属类型范畴为preferCategory。
- 依次考虑result2、result3直至defresult的数据类型。如果其类型范畴也是preferCategory，即与result1具有相同的类型范畴，则判断其精度（优先级）是否高于preferType，如果高于，则将preferType更新为更高精度的数据类型；如果其类型范畴不是preferCategory，则判断其数据类型是否可以隐式转换为preferType，不可以则报错。
- 将最终preferType记录的数据类型作为整个表达式最终的返回值类型；表达式的结果向此类型进行隐式转换。

<div align="left"><img src="image/image2.png" style="zoom:20%")</div>    

- 为了兼容一种特殊情况，即表示了超大数字的字符类型向数值类型转换的情况，例如select decode(1, 2, 2, “53465465676465454657567678676”)，大数超过了bigint、double等的表示范围。所以，当result1的类型范畴为数值类型时，将返回值的类型直接置为numeric，以兼容此种特殊情况。

- 数值类型的优先级排序：numeric>float8>float4>int8>int4>int2>int1
字符类型的优先级排序：text>varchar=nvarchar2>bpchar>char
日期类型的优先级排序：timestamptz>timestamp>smalldatetime>date>abstime>timetz>time
日期跨度类型的优先级排序：interval>tinterval>reltime

**示例**

- Union中的待定类型解析。这里，unknown类型文本'b'将被解析成text类型。


```
SELECT text 'a' AS "text" UNION SELECT 'b'; 
```

结果显示如下：

```
text 
------ 
 a 
 b 
(2 rows)
```

- 简单Union中的类型解析。文本1.2的类型为numeric，而且integer类型的1可以隐含地转换为numeric，因此使用这个类型。


```
SELECT 1.2 AS "numeric" UNION SELECT 1; 
```

结果显示如下：

```
 numeric 
--------- 
    1 
   1.2 
(2 rows)
```

- 转置Union中的类型解析。这里，因为类型real不能被隐含转换成integer，但是integer可以隐含转换成real，那么联合的结果类型将是real。


```
 SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL); 
```

 结果显示如下：

```
real 
------ 
  1 
 2.2 
(2 rows)
```

- TD模式下，coalesce参数输入int和varchar类型，那么解析成varchar类型。 


1、在TD模式下，创建TD兼容模式的数据库td_1并切换数据库为td_1。 

```
CREATE DATABASE td_1 dbcompatibility = 'C';	
\c td_1 
```

2、创建表t1。 

```
CREATE TABLE t1(a int, b varchar(10)); 
```

3、查看coalesce参数输入int和varchar类型的查询语句的执行计划。 

```
EXPLAIN VERBOSE select coalesce(a, b) from t1; 
```

当结果显示如下信息，则表示验证完成。

```
                   QUERY PLAN 
--------------------------------------------------------------------------------------- 
 Seq Scan on public.t1 (cost=0.00..24.18 rows=1134 width=42) 
  Output: (COALESCE((a)::varchar, b)
(2 rows) 
```

4、删除测试库

```
\c vastbase
DROP DATABASE td_1;
```



##### DDL语法一览表

**功能描述**

DDL（Data Definition Language数据定义语言），用于定义或修改数据库中的对象。如：表、索引、视图等。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>    
>
> Vastbase不支持数据库主节点不完整时进行DDL操作。例如：Vastbase中有1个数据库主节点故障时执行新建数据库、表等操作都会失败。

**定义客户端加密主密钥**

客户端加密主密钥主要用于密态数据库特性，用来加密列加密密钥(cek)。客户端加密主密钥定义主要包括创建客户端加密主密钥以及删除客户端加密主密钥。所涉及的SQL语句，请参考下表：

客户端加密主密钥定义相关SQL

| 功能                 | 相关SQL                  |
| :------------------- | :----------------------- |
| 创建客户端加密主密钥 | CREATE CLIENT MASTER KEY |
| 删除客户端加密主密钥 | DROP CLIENT MASTER KEY   |

**定义列加密密钥**

列加密密钥主要用于密态数据库特性中，用来加密数据。列加密密钥定义主要包括创建列加密密钥以及删除列加密密钥。所涉及的SQL语句，请参考下表：

列加密密钥定义相关SQL

| 功能           | 相关SQL                      |
| :------------- | :--------------------------- |
| 创建列加密密钥 | CREATE COLUMN ENCRYPTION KEY |
| 删列加密密钥   | DROP COLUMN ENCRYPTION KEY   |

**定义数据库**

数据库是组织、存储和管理数据的仓库，而数据库定义主要包括：创建数据库、修改数据库属性，以及删除数据库。所涉及的SQL语句，请参考下表：

数据库定义相关SQL

| 功能           | 相关SQL         |
| -------------- | --------------- |
| 创建数据库     | CREATE DATABASE |
| 修改数据库属性 | ALTER DATABASE  |
| 删除数据库     | DROP DATABASE   |

 

**定义模式**

模式是一组数据库对象的集合，主要用于控制对数据库对象的访问。所涉及的SQL语句，请参考下表：

模式定义相关SQL

| 功能         | 相关SQL       |
| ------------ | ------------- |
| 创建模式     | CREATE SCHEMA |
| 修改模式属性 | ALTER SCHEMA  |
| 删除模式     | DROP SCHEMA   |

 

**定义表空间**

表空间用于管理数据对象，与磁盘上的一个目录对应。所涉及的SQL语句，请参考下表：

表空间定义相关SQL

| 功能           | 相关SQL           |
| -------------- | ----------------- |
| 创建表空间     | CREATE TABLESPACE |
| 修改表空间属性 | ALTER TABLESPACE  |
| 删除表空间     | DROP TABLESPACE   |

 

**定义表**

表是数据库中的一种特殊数据结构，用于存储数据对象以及对象之间的关系。所涉及的SQL语句，请参考下表：

表定义相关SQL

| 功能       | 相关SQL      |
| ---------- | ------------ |
| 创建表     | CREATE TABLE |
| 修改表属性 | ALTER TABLE  |
| 删除表     | DROP TABLE   |

 

**定义分区表**

分区表是一种逻辑表，数据是由普通表存储的，主要用于提升查询性能。所涉及的SQL语句，请参考下表：

分区表定义相关SQL

| 功能           | 相关SQL                |
| -------------- | ---------------------- |
| 创建分区表     | CREATE TABLE PARTITION |
| 创建分区       | ALTER TABLE PARTITION  |
| 修改分区表属性 | ALTER TABLE PARTITION  |
| 删除分区       | ALTER TABLE PARTITION  |
| 删除分区表     | DROP TABLE             |

 

**定义索引**

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。所涉及的SQL语句，请参考下表：

索引定义相关SQL

| 功能         | 相关SQL      |
| ------------ | ------------ |
| 创建索引     | CREATE INDEX |
| 修改索引属性 | ALTER INDEX  |
| 删除索引     | DROP INDEX   |
| 重建索引     | REINDEX      |

 

**定义存储过程**

存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数（如果该存储过程带有参数）来执行它。所涉及的SQL语句，请参考下表：

存储过程定义相关SQL

| 功能         | 相关SQL          |
| ------------ | ---------------- |
| 创建存储过程 | CREATE PROCEDURE |
| 删除存储过程 | DROP PROCEDURE   |

 

**定义函数**

在Vastbase中，它和存储过程类似，也是一组SQL语句集，使用上没有差别。所涉及的SQL语句，请参考下表：

函数定义相关SQL

| 功能         | 相关SQL         |
| ------------ | --------------- |
| 创建函数     | CREATE FUNCTION |
| 修改函数属性 | ALTER FUNCTION  |
| 删除函数     | DROP FUNCTION   |

 

**定义视图**

视图是从一个或几个基本表中导出的虚表，可用于控制用户对数据访问，请参考下表：

视图定义相关SQL

| 功能     | 相关SQL     |
| -------- | ----------- |
| 创建视图 | CREATE VIEW |
| 删除视图 | DROP VIEW   |

 **定义包**

包是模块化的思想，由包头（package specification）和包体(package body)组成，用来分类管理存储过程和函数，类似于Java、C++等语言中的类，请参考下表：

包定义相关SQL

| 功能       | 相关SQL        |
| :--------- | :------------- |
| 创建包     | CREATE PACKAGE |
| 删除包     | DROP PACKAGE   |
| 修改包属性 | ALTER PACKAGE  |



**定义游标**

为了处理SQL语句，存储过程进程分配一段内存区域来保存上下文联系。游标是指向上下文区域的句柄或指针。借助游标，存储过程可以控制上下文区域的变化，请参考下表：

游标定义相关SQL

| 功能             | 相关SQL |
| ---------------- | ------- |
| 创建游标         | CURSOR  |
| 移动游标         | MOVE    |
| 从游标中提取数据 | FETCH   |
| 关闭游标         | CLOSE   |

 **定义聚合函数**

聚合函数定义相关SQL

| 功能                 | 相关SQL          |
| :------------------- | :--------------- |
| 创建一个新的聚合函数 | CREATE AGGREGATE |
| 修改聚合函数         | ALTER AGGREGATE  |
| 删除聚合函数         | DROP AGGREGATE   |

**定义数据类型转换**

数据类型定义相关SQL

| 功能                               | 相关SQL     |
| :--------------------------------- | :---------- |
| 创建一个新的用户自定义数据类型转换 | CREATE CAST |
| 删除用户自定义数据类型转换         | DROP CAST   |

**定义插件扩展**

插件扩展定义相关SQL

| 功能                 | 相关SQL          |
| :------------------- | :--------------- |
| 创建一个新的插件扩展 | CREATE EXTENSION |
| 修改插件扩展         | ALTER EXTENSION  |
| 删除插件扩展         | DROP EXTENSION   |

**定义操作符**

操作符定义相关SQL

| 功能               | 相关SQL         |
| :----------------- | :-------------- |
| 创建一个新的操作符 | CREATE OPERATOR |
| 修改操作符         | ALTER OPERATOR  |
| 删除操作符         | DROP OPERATOR   |

**定义过程语言**

过程语言定义相关SQL

| 功能                 | 相关SQL         |
| :------------------- | :-------------- |
| 创建一个新的过程语言 | CREATE LANGUAGE |
| 修改过程语言         | ALTER LANGUAGE  |
| 删除过程语言         | DROP LANGUAGE   |

**定义数据类型**

数据类型定义相关SQL

| 功能                 | 相关SQL     |
| :------------------- | :---------- |
| 创建一个新的数据类型 | CREATE TYPE |
| 修改数据类型         | ALTER TYPE  |
| 删除数据类型         | DROP TYPE   |

##### DML语法一览表

**功能描述**

DML（Data Manipulation Language数据操作语言），用于对数据库表中的数据进行操作。如：插入、更新、查询、删除。

**插入数据**

插入数据是往数据库表中添加一条或多条记录，请参考INSERT。

**修改数据**

修改数据是修改数据库表中的一条或多条记录，请参考UPDATE。

**查询数据**

数据库查询语句SELECT是用于在数据库中检索适合条件的信息，请参考SELECT。

**删除数据**

Vastbase提供了两种删除表数据的语句：删除表中指定条件的数据，请参考DELETE；或删除表的所有数据，请参考TRUNCATE。

TRUNCATE快速地从表中删除所有行，它和在每个表上进行无条件的DELETE有同样的效果，不过因为它不做表扫描，因而快得多。在大表上最有用。

**拷贝数据**

Vastbase提供了在表和文件之间拷贝数据的语句，请参考COPY。

**锁定表**

Vastbase提供了多种锁模式用于控制对表中数据的并发访问，请参考LOCK。

**调用函数**

Vastbase提供了三个用于调用函数的语句，它们在语法结构上没有差别，请参考CALL。

**操作会话**

用户与数据库之间建立的连接称为会话，请参考下表：

会话相关SQL

| 功能     | 相关SQL                   |
| -------- | ------------------------- |
| 修改会话 | ALTER SESSION             |
| 结束会话 | ALTER SYSTEM KILL SESSION |

##### DCL语法一览表

DCL（Data Control Language数据控制语言），是用来创建用户角色、设置或更改数据库用户或角色权限的语句。

**定义角色**

角色是用来管理权限的，从数据库安全的角度考虑，可以把所有的管理和操作权限划分到不同的角色上。所涉及的SQL语句，请参考下表：

角色定义相关SQL

| 功能         | 相关SQL     |
| ------------ | ----------- |
| 创建角色     | CREATE ROLE |
| 修改角色属性 | ALTER ROLE  |
| 删除角色     | DROP ROLE   |

**定义用户**

用户是用来登录数据库的，通过对用户赋予不同的权限，可以方便地管理用户对数据库的访问及操作。所涉及的SQL语句，请参考下表：

用户定义相关SQL

| 功能         | 相关SQL     |
| ------------ | ----------- |
| 创建用户     | CREATE USER |
| 修改用户属性 | ALTER USER  |
| 删除用户     | DROP USER   |

**授权**

Vastbase提供了针对数据对象和角色授权的语句，请参考GRANT。

**收回权限**

Vastbase提供了收回权限的语句，请参考REVOKE。

**设置默认权限**

Vastbase允许设置应用于将来创建的对象的权限，请参考ALTER DEFAULT PRIVILEGES。

**关闭当前节点**

Vastbase支持使用shutdown命令关闭当前数据库节点，请参考SHUTDOWN

### 数据库使用

#### 创建和管理表空间

**功能描述**

通过使用表空间，管理员可以控制一个数据库安装的磁盘布局。这样有以下优点：

- 如果初始化数据库所在的分区或者卷空间已满，又不能逻辑上扩展更多空间，可以在不同的分区上创建和使用表空间，直到系统重新配置空间。

- 表空间允许管理员根据数据库对象的使用模式安排数据位置，从而提高性能。

  - 一个频繁使用的索引可以放在性能稳定且运算速度较快的磁盘上，比如一种固态设备。
  - 一个存储归档的数据，很少使用的或者对性能要求不高的表可以存储在一个运算速度较慢的磁盘上。

- 管理员通过表空间可以设置占用的磁盘空间。用以在和其他数据共用分区的时候，防止表空间占用相同分区上的其他空间。

- 表空间对应于一个文件系统目录，假定数据库节点数据目录/pg_location/mount1/path1是用户拥有读写权限的空目录。使用表空间配额管理会使性能有30%左右的影响，MAXSIZE指定每个数据库节点的配额大小，误差范围在500MB以内。请根据实际的情况确认是否需要设置表空间的最大值。



Vastbase自带了两个表空间：pg_default和pg_global。

- 默认表空间pg_default：用来存储非共享系统表、用户表、用户表index、临时表、临时表index、内部临时表的默认表空间。对应存储目录为实例数据目录下的base目录。
- 共享表空间pg_global：用来存放共享系统表的表空间。对应存储目录为实例数据目录下的global目录。

**示例**

- 创建表空间

1、执行如下命令创建用户jack。

```
CREATE USER jack IDENTIFIED BY 'Bigdata@123';
```

2、执行如下命令创建表空间。

```
 CREATE TABLESPACE fastspace RELATIVE LOCATION 'tablespace/tablespace_1';
```

​	其中“fastspace”为新创建的表空间，“数据库节点数据目录/pg_location/tablespace/tablespace_1”是用户拥有读写权限的空目录。

3、数据库系统管理员执行如下命令将“fastspace”表空间的访问权限赋予数据用户jack。

```
GRANT CREATE ON TABLESPACE fastspace TO jack;
```

- 在表空间中创建对象


如果用户拥有表空间的CREATE权限，就可以在表空间上创建数据库对象，比如：表和索引等。以创建表为例。

方式1：执行如下命令在指定表空间创建表。

```
CREATE TABLE foo(i int) TABLESPACE fastspace;
```

方式2：先使用set default_tablespace设置默认表空间，再创建表。

设置“fastspace”为默认表空间，然后创建表foo2。

```
SET default_tablespace = 'fastspace'; 
CREATE TABLE foo2(i int);
```

- 查询表空间


方式1：检查pg_tablespace系统表。如下命令可查到系统和用户定义的全部表空间。

```
SELECT spcname FROM pg_tablespace;
```

结果显示如下：

```
  spcname   
-------------------
 pg_default
 pg_global
 example1
 example2
 fastspace
(5 rows)
```

方式2：使用gsql程序的元命令查询表空间。

```
\db
```

结果显示如下：

```
               List of tablespaces
    Name    |  Owner   |         Location         
------------+----------+--------------------------
 example1   | vastbase | tablespace1/tablespace_1
 example2   | vastbase | tablespace2/tablespace_2
 fastspace  | vastbase | tablespace/tablespace_1
 pg_default | vastbase | 
 pg_global  | vastbase | 
(5 rows)
```

- 查询表空间使用率。


1、查询表空间的当前使用情况。

```
SELECT PG_TABLESPACE_SIZE('fastspace');
```

结果显示如下：

```
 pg_tablespace_size  
---------------------
      2146304 
(1 row)
```

其中2146304表示表空间的大小，单位为字节。

2、计算表空间使用率。

表空间使用率=PG_TABLESPACE_SIZE/表空间所在目录的磁盘大小。

- 修改表空间


重命名表空间。

```
ALTER TABLESPACE fastspace RENAME TO fspace;
```

设置表空间限额为100M。

```
ALTER TABLESPACE fspace RESIZE MAXSIZE '100M';
```

- 删除表空间


执行如下命令删除用户jack。

```
DROP USER jack CASCADE; 
```

执行如下命令删除表foo和foo2。

```
DROP TABLE foo; 
DROP TABLE foo2;
```

执行如下命令删除表空间fspace。

```
DROP TABLESPACE fspace;
```

#### 创建和管理表

##### UPSERT功能

**功能描述**

UPSERT功能用于往目标表中插入或更新数据。当插入数据因为主键或约束产生冲突时，更新数据，不冲突则插入数据。通过PG风格的upsert语句，指定insert时的冲突键，以及冲突后的处理方式。执行INSERT语句时，支持通过ON CONFLICT conflict_target DO conflict_action语法，指定insert时的冲突检测目标及冲突后的行为。

**语法格式**

- INSERT完整语法


```
[WITH [RECURSIVE] with_query[,..]]
INSERT INTO table_name [(column_name[,…])]
 { DEFAULT VALUES
 | VALUES {({ expression | DEFAULT }[,…])}[,…]
 | query }
[upsert_clause]
[RETURNING { * | {output_expression [ [AS] output_name ]}[,…]}];
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> INSERT语法参数详细说明清参考SQL语法“INSERT”章节

- upsert_clause语法


```
(1) ON DUPLICATE KEY UPDATE {{column_name = {expression | DEFAULT}}[,…] | NOTHING }
(2) ON CONFLICT [conflict_target]DO conflict_action
```

**参数说明**

- conflict_target：

1、(index_params)[where_clause]：根据该语法指定表的字段名或表达式等信息，执行时通过该信息找到对应的唯一索引进行冲突检测。

index_params为索引的参数，与CREATE INDEX时的索引参数一致。

```
{{column_name | (expression)} [COLLATE collation] [opclass] [ASC|DESC] [NULLS{FIRST|LAST}] [,…]
```

但是在upsert语句中，不支持指定ASC/DESC、NULLS FIRST/LAST。

where_clause为条件表达式，暂不支持where_caluse。

2、ON CONSTRAINT name：根据该语法指定表的唯一约束名称，执行时将根据该唯一约束找到对应的唯一索引进行冲突检测，但目前暂不支持该用法。

- conflict_action语法

1、检测到冲突时执行UPDATE。

```
 DO UPDATE SET { column_name= { expression |DEFAULT }}[,...] [where_clause]
```

在SET子句中，可以EXCLUDED来引用要插入的列值，但不支持引用系统列（比如ctid)。例如: UPDATE SET c1=EXCLUDE.c1则表示将c1更新为SQL中 insert部分计划插入的c1字段的值；而UPDATE setc1=EXCLUDE.ctid:text 则不支持。

where_clause为条件表达式，用于指定update的条件，是可选节点，但目前暂不支持指定where_clause。

2、DO NOTHING：检测到冲突时什么也不做。

- with_query：WITH子句允许指定一个或者更多子查询，再insert查询中中可以用名称引用这些子查询，由于Vastbase原upsert不支持with子句，Vastbase G100 V2.2版本兼容pg中upsert也暂不支持。

- schema_name：可选参数，模式名称。

- table_name：一个已有表的名称。

- alias：table_name的别名。当提供了一个别名时，它会完全隐藏掉表的实际名称。当ON CONFLICT DO UPDATE的目标是一个被排除的表时这特别有用，因为那将被当作表示要被插入行的特殊表的名称。

- column_name：名为table_name的表中的一个列的名称。如有必要，列名可以用一个子域名或者数组下标限定（指向一个组合列的某些列中插入会让其他域为空）。

- expression：要赋予给相应列的表达式或者值。

- DEFAULT：相应的列将填充其默认值。标识列将由关联序列生成的新值填充。对于生成的列，允许指定该值，但仅指定根据其生成表达式计算该列的正常行为。

- query：提供要被插入行的查询（SELECT语句）。

- INSERT完output_expression：在每一行被插入或更新后由INSERT命令计算并且返回的表达式。该表达式可以使用table_name指定的表中的任何列。写成*可返回被插入或更新行的所有列。在Vastbase G100 V2.2.5版本中，暂不支持。

- output_name：要用于被返回列的名称。

- ON CONFLICT子句：可选的ON CONFLICT子句为出现违背唯一性或违背约束错误时提供另一种可供选择的动作。对于每一个要插入的行，不管是插入进行下去还是由conflict_target指定的一个对象，都会采取可供选择的conflict_action。ON CONFLICT DO NOTHING简单返回，什么也不做。ON CONFLICT DO UPDATE则会更新与要插入的行冲突的已有行。conflict_target可以执行唯一索引推断。在执行推断时，它由一个或者多个index_column_name列或者index_expression表达式以及一个可选的index_predicate构成。如果推断尝试不成功，则会发生一个错误。ON CONFLICT DO UPDATE保证一个原子的INSERT或者UPDATE结果。在没有无关错误的前提下，这两种结果之一可以得到保证，即使在很高的并发度也能保证。

- conflict_target：通过选择判断目标索引来指定哪些行与ON CONFLICT在其上采取可替代动作的行相冲突。要么执行唯一索引推断，要么显式命名一个约束。对于ON CONFLICT DO NOTHING来说，它对于指定一个conflict_target是可选的。在被省略时，与所有有效约束（以及唯一索引）的冲突都会被处理。对于ON CONFLICT DO UPDATE，必须提供一个conflict_target。

- conflict_action：conflict_action指定一个可替换的ON CONFLICT动作。它可以是DO NOTHING，也可以是一个指定在冲突情况下要被执行的UPDATE动作细节的DO UPDATE子句。ON CONFLICT DO UPDATE中的SET和WHERE子句能够使用该表的名称（或者别名）访问现有的行，并且可以用特殊的excluded表访问要插入的行。注意，不支持引用系统列例如ctid作为更新值，当前版本暂时不支持sub-SELECT做更新。

- index_column_name：一个table_name列的名称。它被用来检测对象是否冲突。

- index_expression：和index_column_name类似，但是被用来判断出现在索引定义中的table_name列（非简单列）上的表达式。

- Collation：强制相应的index_column_name或index_expression使用一种特定的排序规则以便在检测冲突期间能被匹配上。默认为缺省值。排序规则不影响冲突检测，一般不指定。

- opclass：强制相应的index_column_name或index_expression使用特定的操作符类以便在检测冲突期间能被匹配上。通常会被省略。

- index_predicate：用于允许判断部分唯一索引。任何满足该谓词（不一定需要真的是部分索引）的索引都能被推断。

- constraint_name：用名称显式地指定一个判断目标对象约束，本版本中，暂不支持。

- condition：一个能返回boolean值的表达式。仅在这个表达式返回true行才将被更新，不过在采用ON CONFLICT DO UPDATE动作时所有的行都会被锁定。注意condition会被最后计算，即一个冲突被标识为要更新的候选对象之后。

**注意事项**

- ON CONFLICT语法暂不支持在视图、外部表、分区表中使用。

- conflict_target用于指定冲突检测的目标，该目标必须能关联到唯一索引。.目前暂不支持不指定conflict_target的用法。

- 支持 insert的数据类型允许在SQL的insert部分写入。

- 支持update的数据类型允许在upsext_clause中的update子句中更新。
- upsert语句暂不支持以下场景：
  - SQL中包含 upsert子句和 returning子句。
  - SQL中包含upsert子句和 with子句。
  - update set子句中包含子查询。
  - upsert子句的conflict_target为空。
  - upsert子句的conflict_target为ON CONSTRAINT name。
  - upsert子句的conflict_target中包含where子句。
  - upsert子句的conflict_action中包含where子句。
  - upsert子句的conflict_target指定了ASC/DESC 、NULLS FIRSTLAST关键字。
  - upsert语法不支持在分区表、视图、外部表中使用。

**示例**

- ON CONFLICT

1、创建测试表。

```
create table tu1(c1 int unique, c2 int);
```

2、执行如下语句，如c1值不冲突，将执行插入。

```
insert into tu1 values(3,3) on conflict(c1) do update set c2=EXCLUDED.c2;
```

3、查询结果，当结果显示为如下信息，则表示插入成功。

```
select * from tu1;
 c1 | c2 
----+----
  3 |  3
(1 row)
```

4、执行如下语句，如c1值冲突，将执行更新。

```
insert into tu1 values(3,4) on conflict(c1) do update set c2=EXCLUDED.c2;
```

5、查询结果，当结果显示为如下信息，则表示更新成功。

```
select * from tu1;
 c1 | c2 
----+----
  3 |  4
(1 row)
```

6、执行如下语句，如c1值冲突，将什么都不做。

```
insert into tu1 values(3,5) on conflict(c1) do nothing; 
```

7、查询结果，当结果显示为如下信息，则表示没有执行操作。

```
select * from tu1;
 c1 | c2 
----+----
  3 |  4
(1 row)
```

- 使用 ON DUPLICATE KEY UPDATE 根据某一字段值查询数据库中是否有记录，有则更新，没有则插入

1、创建测试数据。

```
CREATE TABLE test01 (col1 INT PRIMARY KEY, col2 INT);
insert into test01 values(1,1);
```

2、根据col1字段值判断数据库中是否有记录'1'，有则更新字段col2为'2'，没有则插入col1为'1'。

```
INSERT INTO test01(col1) VALUES(1) ON DUPLICATE KEY UPDATE col2 = 2;
```

3、验证结果，当结果显示为如下信息，则表示验证成功。

```
SELECT * FROM test01

 col1 | col2 
------+------
    1 |    2
(1 row)
```

#### 回收站

**功能描述**

回收站功能，用户通过该功能可以从回收站中闪回TRUNCATE或DROP的表对象，将数据恢复到错误操作前，大大提高了用户数据的可靠性。

**语法格式**

- 清空回收站中指定对象。

```
PURGE { TABLE table_name | RECYCLEBIN }
```

- 从回收站中恢复对象。

```
FLASHBACK TABLE [ schema_name. ] table_name [, [ schema_name. ] table_name ]...
TO BEFORE { DROP [ RENAME TO table_newname ]  |  TRUNCATE }
```

**参数说明**

- table_name：要清空的回收站中，表名称可以是dba_recyclebin中的object_name，也可以是original_name。

- schema_name：回收站中要闪回表的模式名，默认为回收站模式名称。

- table_name：回收站中要闪回的表，可以一次性闪回多个表，表与表之间使用逗号分隔。

- table_newname：重命名的表名称。

**注意事项**

- 回收站功能相关参数：

  - enable_recyclebin：
    - on：启用回收站功能。
    - off：关闭回收站功能。

  - recyclebin_retention_time：设置回收站对象保留时间，超过该时间的回收站对象将被自动清理，默认为900秒。

- 回收站中对象名称修改为以BIN$开头，在数据库中唯一的名称，命名方式如下：

  ```
  BIN${databasId}{classId}{objId}${XLogRecPtr}==$0
  ```

  参数说明：

  - databasId：数据库oid。
  - classId：pg_class的class id。
  - objId：对象的oid。
  - XLogRecPtr：XLog当前可用的位置。

- 系统视图及同义词。
  - dba_recyclebin：保存数据库中所有回收站的信息。
  - user_recyclebin：保存当前用户的回收站信息，可使用同义词recyclebin访问。

**示例**

- 回收站

1、配置参数文件：postgresql.conf增加参数配置并重启数据库。

```
enable_recyclebin=on
recyclebin_retention_time=900
```

2、创建一个表part_test，并创建索引插入数据。

```
CREATE TABLE part_test
 (
   c1 int,
 c2 text
 ) partition by range (c1)
 (
   partition p1 values less than (1000),
   partition p2 values less than (2000),
   partition p3 values less than (3000),
   partition p4 values less than (4000),
   partition p5 values less than (5000)
 );
create index il_part_test on part_test(c1) local;
create index ig_part_test on part_test(c2) global;
insert into part_test values (1, 'test01');
```

3、删除表part_test。

```
drop table part_test;
```

4、查询回收站。

```
select OBJECT_NAME,OPERATION from dba_recyclebin order by OBJECT_NAME;
```

结果返回如下：

```
     object_name     | operation
-----------------------------+-----------
 BIN$400E4EBA13C$43BBC10==$0 | DROP
 BIN$400E4EBA154$43BCE58==$0 | DROP
 BIN$400E4EBA15A$43BC418==$0 | DROP
(3 rows)
```

5、从回收站中恢复表part_test。

```
flashback table part_test to before drop;
```

当显示如下信息，则表示执行成功。

```
TimeCapsule Table
```

6、查询数据验证。

```
select * from part_test;
```

结果返回如下： 

```
c1 |  c2
----+--------
 1 | test01
(1 row)
```

7、清空回收站。

```
purge recyclebin;
```





#### 显示历史访问信息 

**功能描述**

通过设置数据库配置参数vastbase_login_info访问历史，控制用户登录时是否记录其访问信息，并在成功登录后显示访问历史信息。

**语法格式**

```
ALTER SYSTEM SET vastbase_login_info { TO | = } { true | false | DEFAULT }
```

**参数说明**

参数类型为布尔型，默认开启（ture）。

**注意事项**

- 管理员可通过配置文件或者SQL语法对参数vastbase_login_info进行设置。

- 用户访问信息记录在表pg_vastbase_login_info中，字段含义和说明如下表：

| **字段名称** | **字段属性** | 说明               |
| ------------ | ------------ | ------------------ |
| login_date   | timestamptz  | 登录时间           |
| app_name     | name         | 客户端应用程序名称 |
| ip_address   | name         | 客户端IP地址       |
| ip_port      | int          | 客户端端口号       |
| login_method | name         | 访问方法           |
| useroid      | oid          | 用户的OID          |
| username     | name         | 用户名称           |
| dbname       | name         | 连接的数据库名称   |
| login_result | boolean      | 登录结果           |
| error_msg    | text         | 登录失败原因       |

**示例**

1、使用vastbase用户登录数据库，开启访问历史。

```
alter system set vastbase_login_info = true;
show vastbase_login_info;
```

结果返回如下：

```
 vastbase_login_info 
---------------------
 on
(1 row)
```

2、重新登陆数据库。

3、查询最近一条登录记录。

```
select * from pg_vastbase_login_info order by login_date desc limit 1;
```

结果返回如下：

```
      login_date           | app_name | ip_address | ip_port | login_method | useroid | username | dbname | login_result | error_msg 

-------------------------------+----------+------------+---------+--------------+---------+----------+--------+--------------+-----------
 2022-07-15 11:49:26.582746+08 | gs_clean | ::1        | 60822   | Trust        |      10 | vastbase | lttest | t            | unknown
(1 row)
```



### 数据库安全

#### 设置密码有效期

**功能描述**

参数password_effect_time用于设置帐户密码的有效时间。

**设置方法**

```
alter system set password_effect_time = n;
```

**参数说明**

n：账户密码的有效时间，临近或超过有效期系统会提示用户修改密码。

参数类型：浮点型。

取值范围：30~100*365，单位为天。

默认值：90。

**示例**

1、查看当前账户密码的有效期。

```
show password_effect_time;
```

返回结果为：

```
 password_effect_time
----------------------
 90
(1 row)
```

2、更改密码有效期为100天并查询结果。

```
alter system set password_effect_time = 100;
show password_effect_time;
```

返回结果为：

```
 password_effect_time
----------------------
 100
(1 row)
```



#### 安全审计概述

**功能描述**

Vastbase安全审计支持记录审计日志（普通日志和告警日志）和阻断会话，当审计事件发生时，根据审计策略判断是写日志还是阻断。

**可审计对象与事件类型**

- 对象类型：Vastbase支持的审计对象类型包括：模式（schema）、表（table）、视图（view）和函数（function），只有DDL和DML语句操作的对象是上述对象时才可被审计。
- 事件类型：Vastbase中可审计的事件主要分为两大类：权限（PRIVILEGE）和访问（ACCESS）。

PRIVILEGE类型：Vastbase支持的PRIVILEGE权限审计类型如下表所示。


| PRIVILEGE类型 | 说明                 |
| ------------- | -------------------- |
| ALTER         | 修改对象属性DDL语句  |
| ANALYZE       | 表分析语句           |
| COMMENT       | 为对象添加注释       |
| CREATE        | 创建对象语句         |
| DROP          | 删除对象语句         |
| GRANT         | 授权语句             |
| REVOKE        | 权限回收语句         |
| SET           | 修改会话属性（参数） |
| SHOW          | 展示会话属性（参数） |
| LOGIN_ANY     | 任何登录事件         |
| LOGIN_FAILURE | 登录失败事件         |
| LOGIN_SUCCESS | 登录成功事件         |
| LOGOUT        | 登出（退出）事件     |
| CHECKPOINT    | 检查点事件           |
| COMMIT        | 提交                 |
| ROLLBACK      | 回滚                 |

ACCESS类型：Vastbase支持的ACCESS权限审计类型如下表所示。

| ACCESS类型 | 说明                      |
| ---------- | ------------------------- |
| COPY       | COPY命令                  |
| DELETE     | DELETE语句                |
| EXECUTE    | EXECUTE语句（函数的执行） |
| INSERT     | INSERT语句                |
| REINDEX    | REINDEX语句               |
| SELECT     | SELECT语句                |
| TRUNCATE   | TRUNCATE语句              |
| UPDATE     | UPDATE语句                |

#### 配置客户端接入认证

**功能描述**

如果主机需要远程连接数据库，必须在数据库系统的配置文件中增加此主机的信息，并且进行客户端接入认证。配置文件（默认名称为pg_hba.conf）存放在数据库的数据目录里。hba（host-based authentication）表示是基于主机的认证。

- 本产品支持如下三种认证方式，这三种方式都需要配置“pg_hba.conf”文件。
  - 基于主机的认证：服务器端根据客户端的IP地址、用户名及要访问的数据库来查看配置文件从而判断用户是否通过认证。
  - 口令认证：包括远程连接的加密口令认证和本地连接的非加密口令认证。
  - SSL加密：使用OpenSSL（开源安全通信库）提供服务器端和客户端安全连接的环境。

- “pg_hba.conf”文件的格式是一行写一条信息，表示一个认证规则，空白和注释（以#开头）被忽略。

- 每个认证规则是由若干空格和/，空格和制表符分隔的字段组成。如果字段用引号包围，则它可以包含空白。一条记录不能跨行存在。

**配置文件参考**<a id='配置文件参考'></a>

| 参数名称    | 描述                                                         | 取值范围                                                     |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| local       | 表示这条记录只接受通过Unix域套接字进行的连接。没有这种类型的记录，就不允许Unix域套接字的连接。只有在从服务器本机使用vsql连接且在不指定-U参数的情况下，才是通过Unix域套接字连接。 | -                                                            |
| host        | 表示这条记录既接受一个普通的TCP/IP套接字连接，也接受一个经过SSL加密的TCP/IP套接字连接。 | 链接地址                                                     |
| hostssl     | 表示这条记录只接受一个经过SSL加密的TCP/IP套接字连接。        | 用SSL进行安全的连接，需要配置申请数字证书并配置相关参数，详细信息请参见章节“身份认证与通信加密”。 |
| hostnossl   | 表示这条记录只接受一个普通的TCP/IP套接字连接。               | -                                                            |
| DATABASEGUC | 声明记录所匹配且允许访问的数据库。                           | all：表示该记录匹配所有数据库。<br />sameuser：表示如果请求访问的数据库和请求的用户同名，则匹配。<br />samerole：表示请求的用户必须是与数据库同名角色中的成员。<br />samegroup：与samerole作用完全一致，表示请求的用户必须是与数据库同名角色中的成员。<br />一个包含数据库名的文件或者文件中的数据库列表：文件可以通过在文件名前面加前缀@来声明。文件中的数据库列表以逗号或者换行符分隔。<br />特定的数据库名称或者用逗号分隔的数据库列表。<br />说明：值replication表示如果请求一个复制链接，则匹配，但复制链接不表示任何特定的数据库。如需使用名为replication的数据库，需在database列使用记录“replication”作为数据库名。 |
| USER        | 声明记录所匹配且允许访问的数据库用户。                       | all：表明该记录匹配所有用户。<br /> +用户角色：表示匹配任何直接或者间接属于这个角色的成员。说明：+表示前缀符号。<br /> 一个包含用户名的文件或者文件中的用户列表：文件可以通过在文件名前面加前缀@来声明。文件中的用户列表以逗号或者换行符分隔。<br /> 特定的数据库用户名或者用逗号分隔的用户列表。 |
| ADDRESS     | 指定与记录匹配且允许访问的IP地址范围。                       | 支持IPv4和IPv6，可以使用如下两种形式来表示：<br />IP地址/掩码长度。例如，10.10.0.0/24<br />IP地址子网掩码。例如，10.10.0.0 255.255.255.0<br />说明：以IPv4格式给出的IP地址会匹配那些拥有对应地址的IPv6连接，比如127.0.0.1将匹配IPv6地址 ::ffff:127.0.0.1 |
| METHOD      | 声明连接时使用的认证方法。                                   | 本产品支持如下几种认证方式，详细解释请参见下表“认证方式”：<br />trust<br />reject<br />md5（不推荐使用，默认不支持，可通过password_encryption_type参数配置<br />sha256<br />cert<br />gss（仅用于Vastbase内部节点间认证）<br />sm3 |

 

**认证方式**

| 认证方式 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| trust    | 采用这种认证模式时，本产品只完全信任从服务器本机使用vsql且不指定-U参数的连接，此时不需要口令。trust认证对于单用户工作站的本地连接是非常合适和方便的，通常不适用于多用户环境。如果想使用这种认证方法，可利用文件系统权限限制对服务器的Unix域套接字文件的访问。要使用这种限制有两个方法：<br />设置参数unix_socket_permissions和unix_socket_group。<br />设置参数unix_socket_directory，将Unix域套接字文件放在一个经过恰当限制的目录里。<br />须知：设置文件系统权限只能Unix域套接字连接，它不会限制本地TCP/IP连接。为保证本地TCP/IP安全，Vastbase不允许远程连接使用trust认证方法。 |
| reject   | 无条件地拒绝连接。常用于过滤某些主机。                       |
| md5      | 要求客户端提供一个md5加密的口令进行认证。<br />须知：不推荐使用md5认证，因为md5为不安全的加密算法，存在网络安全风险。Vastbase保留md5认证和密码存储，是为了便于第三方工具的使用（比如TPCC评测工具）。 |
| sha256   | 要求客户端提供一个sha256算法加密的口令进行认证，该口令在传送过程中结合salt（服务器发送给客户端的随机数）的单向sha256加密，增强了安全性。 |
| cert     | 客户端证书认证模式，此模式需进行SSL连接配置且需要客户端提供有效的SSL证书，不需要提供用户密码。<br />须知：该认证方式只支持hostssl类型的规则。 |
| gss      | 使用基于gssapi的kerberos认证。<br />须知：该认证方式依赖kerberos server等组件，仅支持Vastbase内部通信认证。当前版本暂不支持外部客户端通过kerberos认证连接。<br />开启Vastbase内部kerberos认证会使增加内部节点建连时间，即影响首次涉及内部建连的SQL操作性能，内部连接建立好后， 后续操作不受影响。 |
| sm3      | 国密SM3算法，目前只支持vsql、JDBC、ODBC三种连接方式          |

**操作步骤**

1、以操作系统用户vastbase登录数据库主节点。

2、在数据库主节点实例对应的“pg_hba.conf”文件中添加规则，配置客户端认证方式，允许客户端以“jack”用户连接到本机，此处远程连接禁止使用“vastbase”用户（即数据库初始化用户）。

例如，下面示例中，配置允许IP地址为10.10.0.30的客户端访问本机。

```
host all jack 10.10.0.30/32 md5;
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 使用“jack”用户前，需先本地连接数据库，并在数据库中使用如下语句建立“jack”用户：
>
> ```
> CREATE USER jack PASSWORD 'Test@123';
> ```
>
>  jack表示连接数据库的用户。
>
> 10.10.0.30/32表示只允许IP地址为10.10.0.30的主机连接。此处的IP地址不能为Vastbase内的IP，在使用过程中，请根据用户的网络进行配置修改。32表示子网掩码为1的位数，即255.255.255.255
>
> md5表示连接时jack用户的密码使用md5算法加密。

 

"pg_hba.conf"文件中的每条记录可以是下面四种格式之一，四种格式的参数说明请参见[配置文件参考](#配置文件参考)

```
local   DATABASE USER METHOD [OPTIONS] 
host    DATABASE USER ADDRESS METHOD [OPTIONS] 
hostssl  DATABASE USER ADDRESS METHOD [OPTIONS] 
hostnossl DATABASE USER ADDRESS METHOD [OPTIONS]
```

因为认证时系统是为每个连接请求顺序检查“pg_hba.conf”里的记录的，所以这些记录的顺序是非常关键的。

3、可配置“时间段”字段：

（1）表示一段时间范围，例如"[2019-10-01 09:30:28, 2020-10-01 23:59:59)"，其中 [] 表示闭区间，() 表示开区间。区间中的每个元素要求是合法的timestamptz类型，可以通过逗号分隔的方式指定多个时间段。

（2）兼容旧的配置方式，意味着在没有配置时间段时，表示允许任意时刻连接。

（3）[2020-8-14, ) 表示从2020-8-14且包含2020-8-14到永久； [2020-8-14, ] 与其含义一致。

（4） [  ,  ]  、(  ,  ) 、(  ,  ] 、[  ,  )  含义都表示任意时刻。

（5）访问控制只针对登录那一瞬间，因此连接成功后，超出这个时间不会被断开。

示例如下：

允许192.168.1.111客户端通过Unix domain方式在2020-10-01至2021-11-01和20210101至20210501时间段登录	。

```
local  all  all  192.168.1.111  "[2020-10-01, 2021-11-01]","[20210101,20210501]"  md5
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> 在配置“pg_hba.conf”文件时，请依据通讯需求按照格式内容从上至下配置记录，优先级高的需求需要配置在前面。Vastbase和扩容配置的IP优先级最高，用户手动配置的IP请放在这二者之后，如果已经进行的客户配置和扩容节点的IP在同一网段，请在扩容前删除，扩容成功后再进行配置。

因此对于认证规则的配置建议如下：

- 靠前的记录有比较严格的连接参数和比较弱的认证方法。
- 靠后的记录有比较宽松的连接参数和比较强的认证方法。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> - 一个用户要想成功连接到特定的数据库，不仅需要通过pg_hba.conf中的规则检查，还必须要有该数据库上的CONNECT权限。如果希望控制某些用户只能连接到指定数据库，赋予/撤销CONNECT权限通常比在pg_hba.conf中设置规则更为简单。
> - 对应Vastbase外部客户端连接，trust为不安全的认证方式，请将认证方式设置为sha256。 

**异常处理**

用户认证失败有很多原因，通过服务器返回给客户端的提示信息，可以看到用户认证失败的原因。常见的错误提示请参见下表。

错误提示

| 问题现象                                                     | 解决方法                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 用户名或密码错误：FATAL: invalid username/password,login denied | 这条信息说明用户名或者密码错误，请检查输入是否有误。         |
| 连接的数据库不存在：FATAL: database "TESTDB" does not exist  | 这条信息说明尝试连接的数据库不存在，请检查连接的数据库名输入是否有误。 |
| 未找到客户端匹配记录：FATAL: no pg_hba.conf entry for host "10.10.0.60", user "ANDYM", database "TESTDB" | 这条信息说明已经连接了服务器，但服务器拒绝了连接请求，因为没有在它的pg_hba.conf配置文件里找到匹配的记录。请联系数据库管理员在pg_hba.conf配置文件加入用户的信息。 |

**示例**

```
TYPE  DATABASE     USER       ADDRESS         METHOD 
"local" is for Unix domain socket connections only 
#表示只允许以安装时-U参数指定的用户从服务器本机进行连接。 
local  all       all                   trust 
IPv4 local connections: 
#表示允许vastbase用户从10.10.0.50主机上连接到任意数据库，使用sha256算法对密码进行加密。 
host   all      vastbase       10.10.0.50/32       sha256 
#表示允许任何用户从10.10.0.0/24网段的主机上连接到任意数据库，使用sha256算法对密码进行加密，并且经过SSL加密传输。 
hostssl   all       all       10.10.0.0/24       sha256 
#表示允许任何用户从10.10.0.0/24网段的主机上连接到任意数据库，使用Kerberos认证方式，当前版本暂不支持客户端kerberos认证。 
host   all       all       10.10.0.0/24       gss     include_realm=1     krb_realm=HADOOP.COM
```

#### 审计日志概述

**功能描述**

数据库安全对数据库系统来说至关重要。Vastbase将用户对数据库的所有操作写入审计日志。数据库安全管理员可以利用这些日志信息，重现导致数据库现状的一系列事件，找出非法操作的用户、时间和内容等。

关于审计功能，用户需要了解以下几点内容：

- 审计开关audit_enabled，默认值为off，表示关闭审计功能。关闭审计时，默认对数据库启停、用户删除及修改、修改系统参数这三类行为进行审计，并生成审计日志。

- 审计总开关audit_enabled及各审计项的开关支持动态加载。在数据库运行期间修改该配置项的值会立即生效，无需重启数据库。
- 当审计开启，即audit_enabled=on时，记录的审计日志根据具体的审计策略确定。
- 未开启三权分立，即enable_separation_of_duty=off时，只有初始用户和系统管理员（vbadmin）可以查看审计日志，其他用户不具备查看审计日志的权限。
- 开启三权分立，即参数enable_separation_of_duty=on时，只有审计管理员（vbaudit）具备查看审计日志权限，系统管理员（vbadmin）、安全保密管理员（vbsso）和普通用户不具备查看审计日志权限。

目前，Vastbase支持以下审计项如[表1](#配置审计项)所示。

**表1** 配置审计项<a id="配置审计项"></a>

| 配置项                                  | 描述                                                         |
| :-------------------------------------- | :----------------------------------------------------------- |
| 用户登录、注销审计                      | 参数：audit_login_logout默认值为7，表示开启用户登录、退出的审计功能。设置为0表示关闭用户登录、退出的审计功能。不推荐设置除0和7之外的值。 |
| 数据库启动、停止、恢复和切换审计        | 参数：audit_database_process默认值为1，表示开启数据库启动、停止、恢复和切换的审计功能。 |
| 用户锁定和解锁审计                      | 参数：audit_user_locked默认值为1，表示开启审计用户锁定和解锁功能。 |
| 用户访问越权审计                        | 参数：audit_user_violation默认值为0，表示关闭用户越权操作审计功能。 |
| 授权和回收权限审计                      | 参数：audit_grant_revoke默认值为1，表示开启审计用户权限授予和回收功能。 |
| 数据库对象的CREATE，ALTER，DROP操作审计 | 参数：audit_system_object默认值为12295，表示只对DATABASE、SCHEMA、USER、DATA SOURCE这四类数据库对象的CREATE、ALTER、DROP操作进行审计。 |
| 具体表的INSERT、UPDATE和DELETE操作审计  | 参数：audit_dml_state默认值为0，表示关闭具体表的DML操作（SELECT除外）审计功能。 |
| SELECT操作审计                          | 参数：audit_dml_state_select默认值为0，表示关闭SELECT操作审计功能。 |
| COPY审计                                | 参数：audit_copy_exec默认值为1，表示开启copy操作审计功能。   |
| 存储过程和自定义函数的执行审计          | 参数：audit_function_exec默认值为0，表示不记录存储过程和自定义函数的执行审计日志。 |
| SET审计                                 | 参数：audit_set_parameter默认值为1，表示记录set操作审计日志  |
| 事务ID记录                              | 参数：audit_xid_info默认值为0，表示关闭审计日志记录事务ID功能。 |

**表2** 安全相关参数及说明

| 参数名                      | 说明                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| ssl                         | 指定是否启用SSL连接。                                        |
| require_ssl                 | 指定服务器端是否强制要求SSL连接。                            |
| ssl_ciphers                 | 指定SSL支持的加密算法列表。                                  |
| ssl_cert_file               | 指定包含SSL服务器证书的文件的名称。                          |
| ssl_key_file                | 指定包含SSL私钥的文件名称。                                  |
| ssl_ca_file                 | 指定包含CA信息的文件的名称。                                 |
| ssl_crl_file                | 指定包含CRL信息的文件的名称。                                |
| password_policy             | 指定是否进行密码复杂度检查。                                 |
| password_reuse_time         | 指定是否对新密码进行可重用天数检查。                         |
| password_reuse_max          | 指定是否对新密码进行可重用次数检查。                         |
| password_lock_time          | 指定帐户被锁定后自动解锁的时间。                             |
| failed_login_attempts       | 如果输入密码错误的次数达到此参数值时，当前帐户被锁定。       |
| password_encryption_type    | 指定采用何种加密方式对用户密码进行加密存储。                 |
| password_min_uppercase      | 密码中至少需要包含大写字母的个数。                           |
| password_min_lowercase      | 密码中至少需要包含小写字母的个数。                           |
| password_min_digital        | 密码中至少需要包含数字的个数。                               |
| password_min_special        | 密码中至少需要包含特殊字符的个数。                           |
| password_min_length         | 密码的最小长度。说明：在设置此参数时，请将其设置成不大于password_max_length，否则进行涉及密码的操作会一直出现密码长度错误的提示 |
| password_max_length         | 密码的最大长度。说明：在设置此参数时，请将其设置成不小于password_min_length，否则进行涉及密码的操作会一直出现密码长度错误的提示。 |
| password_effect_time        | 密码的有效期限。                                             |
| password_notify_time        | 密码到期提醒的天数。                                         |
| audit_enabled               | 控制审计进程的开启和关闭。                                   |
| audit_directory             | 审计文件的存储目录。                                         |
| audit_data_format           | 审计日志文件的格式，当前仅支持二进制格式（binary）。         |
| audit_rotation_interval     | 指定创建一个新审计日志文件的时间间隔。当现在的时间减去上次创建一个审计日志的时间超过了此参数值时，服务器将生成一个新的审计日志文件。 |
| audit_rotation_size         | 指定审计日志文件的最大容量。当审计日志消息的总量超过此参数值时，服务器将生成一个新的审计日志文件。 |
| audit_resource_policy       | 控制审计日志的保存策略，以空间还是时间限制为优先策略，on表示以空间为优先策略。 |
| audit_file_remain_time      | 表示需记录审计日志的最短时间要求，该参数在audit_resource_policy为off时生效。 |
| audit_space_limit           | 审计文件占用磁盘空间的最大值。                               |
| audit_file_remain_threshold | 审计目录下审计文件的最大数量。                               |
| audit_login_logout          | 指定是否审计数据库用户的登录（包括登录成功和登录失败）、注销。 |
| audit_database_process      | 指定是否审计数据库启动、停止、切换和恢复的操作。             |
| audit_user_locked           | 指定是否审计数据库用户的锁定和解锁。                         |
| audit_user_violation        | 指定是否审计数据库用户的越权访问操作。                       |
| audit_grant_revoke          | 指定是否审计数据库用户权限授予和回收的操作。                 |
| audit_system_object         | 指定是否审计数据库对象的CREATE、DROP、ALTER操作。            |
| audit_dml_state             | 指定是否审计具体表的INSERT、UPDATE、DELETE操作。<br />针对显式开启事务的DML或DDL语句，记录事务的生命周期。即从begin开始，到commit或rollback或end的过程语句，需包含begin、commit、rollback、end关键字。<br />针对未显式开启事务（默认提交）的语句，只记录DML或DDL语句本身。 |
| audit_dml_state_select      | 指定是否审计SELECT操作。                                     |
| audit_copy_exec             | 指定是否审计COPY操作。                                       |
| audit_function_exec         | 指定在执行存储过程、匿名块或自定义函数（不包括系统自带函数）时是否记录审计信息。 |
| audit_set_parameter         | 指定是否审计SET操作。                                        |
| enable_Separation_Of_Duty   | 指定是否开启三权分立。                                       |
| session_timeout             | 建立连接会话后，如果超过此参数的设置时间，则会自动断开连接。 |
| auth_iteration_count        | 认证加密信息生成过程中使用的迭代次数。                       |

**操作步骤**

1、以操作系统用户vastbase登录数据库主节点。

2、使用如下命令连接数据库。

```
vsql -d vastbase -p 5432
```

vastbase为需要连接的数据库名称，5432为数据库主节点的端口号。

连接成功后，系统显示类似如下信息：

```
vsql ((Vastbase G100 V2.2 (Build 9) Alpha) compiled at 2022-06-10 02:16:40 commit 7387 last mr  )
Non-SSL connection (SSL connection is recommended when requiring high-security)
Type "help" for help.
```

3、检查审计总开关状态。

- 用show命令显示审计总开关audit_enabled的值。

  ```
  SHOW audit_enabled;
  ```

  如果显示为off，执行“\q”命令退出数据库。

- 修改postgres.conf的audit_enabled=”on”,重启数据库，使得参数生效。

4、配置具体的审计项。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
> 只有开启审计功能，用户的操作（包括用户建立的会话不符合IP段和时间段导致会话连接失败）才会被记录到审计文件中。
> 各审计项的默认参数都符合安全标准，用户可以根据需要开启其他审计功能，但会对性能有一定影响。

以开启对数据库所有对象的增删改操作的审计开关为例，其他配置项的修改方法与此相同，修改postgres.conf的audit_system_object=12295,重启数据库，使得参数生效。

其中audit_system_object代表审计项开关，12295为该审计开关的值。

#### 行级访问控制

**功能描述**

行级访问控制特性将数据库访问控制精确到数据表行级别，使数据库达到行级访问控制的能力。不同用户执行相同的SQL查询操作，读取到的结果是不同的。

行级访问控制的目的是控制表中行级数据可见性，通过在数据表上预定义Filter，在查询优化阶段将满足条件的表达式应用到执行计划上，影响最终的执行结果。

**注意事项**

- 行级访问控制策略仅可以应用到SELECT、UPDATE和DELETE操作，不支持应用到INSERT和MERGE操作。
- 支持对行存表、行存分区表、列存表、列存分区表、复制表、unlogged表、hash表定义行级访问控制策略，不支持HDFS表、外表、临时表定义行级访问控制策略。
- 不支持对视图定义行级访问控制策略。
- 同一张表上可以创建多个行级访问控制策略，一张表最多允许创建100个行级访问控制策略。
- 初始用户和系统管理员不受行级访问控制策略的影响。
- 对于设置了行级访问控制策略的表，需要谨慎授予其他用户对该表的trigger权限，以免其他用户利用触发器绕过行级访问控制策略。

**配置方法**

用户可以在数据表创建行访问控制（Row Level Security）策略，详情参考SQL语法CREATE ROW LEVEL SECURITY POLICY。该策略是指针对特定数据库用户、特定SQL操作生效的表达式。当数据库用户对数据表访问时，若SQL满足数据表特定的Row Level Security策略，在查询优化阶段将满足条件的表达式，按照属性（PERMISSIVE | RESTRICTIVE）类型，通过AND或OR方式拼接，应用到执行计划上。



**示例**

1、创建用户alice, bob, peter 。

```
CREATE USER alice PASSWORD 'Vastbase@123'; 
CREATE USER bob PASSWORD 'Vastbase@123'; 
CREATE USER peter PASSWORD 'Vastbase@123'; 
```

2、创建表all_data，包含不同用户数据信息 。

```
CREATE TABLE all_data(id int, role varchar(100), data varchar(100)); 
```

3、向数据表插入数据 。

```
INSERT INTO all_data VALUES(1, 'alice', 'alice data'); 
INSERT INTO all_data VALUES(2, 'bob', 'bob data'); 
INSERT INTO all_data VALUES(3, 'peter', 'peter data'); 
```

4、将表all_data的读取权限赋予alice，bob和peter用户 。

```
GRANT SELECT ON all_data TO alice, bob, peter; 
```

5、打开行访问控制策略开关 。

```
ALTER TABLE all_data ENABLE ROW LEVEL SECURITY; 
```

6、创建行访问控制策略，当前用户只能查看用户自身的数据 。

```
CREATE ROW LEVEL SECURITY POLICY all_data_rls ON all_data USING(role = CURRENT_USER); 
```

7、查看表详细信息 。

```
\d+ all_data 
```

结果显示如下：

```
                         Table "public.all_data"
 Column |     Type     | Modifiers | Storage  | Stats target | Description 
--------+--------------+-----------+----------+--------------+-------------
 id     | integer      |           | plain    |              | 
 role   | varchar(100) |           | extended |              | 
 data   | varchar(100) |           | extended |              | 
Row Level Security Policies:
    POLICY "all_data_rls" FOR ALL
      TO public
      USING (((role)::name = "current_user"()))
Has OIDs: no
Options: orientation=row, compression=no, fillfactor=80, enable_rowsecurity=true
```

8、验证效果，切换至用户alice，执行SQL"SELECT * FROM public.all_data" 。

```
\c - alice
SELECT * FROM public.all_data; 
```

当结果显示如下信息，则表示行级访问控制生效。

```
 id | role  |   data 
----+-------+------------ 
 1 | alice | alice data 
(1 row) 
```

查询语句执行计划。

```
EXPLAIN(COSTS OFF) SELECT * FROM public.all_data; 
```

结果显示如下，可以看到通过rolename进行过滤。

```
              QUERY PLAN 
-----------------------------------------
 Streaming (type: GATHER) 
  Node/s: All datanodes 
  ->  Seq Scan on all_data 
     Filter: ((role)::name = 'alice'::name) 
 Notice: This query is influenced by row level security feature 
(5 rows) 
```

9、验证结果，切换至用户peter，执行SQL"SELECT * FROM public.all_data" 。

```
SELECT * FROM public.all_data; 
```

当结果显示如下信息，则表示行级访问控制生效。

```
 id | role  |   data 
----+-------+------------ 
 3 | peter | peter data 
(1 row) 
```

 查询语句执行计划。

```
 EXPLAIN(COSTS OFF) SELECT * FROM public.all_data; 
```

结果显示如下，可以看到通过rolename进行过滤。

```
              QUERY PLAN 
-----------------------------------
 Streaming (type: GATHER) 
  Node/s: All datanodes 
  ->  Seq Scan on all_data 
     Filter: ((role)::name = 'peter'::name) 
 Notice: This query is influenced by row level security feature 
(5 rows)
```

#### 敏感标记

**功能描述**

为实现强制访问控制功能，数据库管理系统应维护主体和客体相关的敏感标记，为主体和客体划分安全级。这些敏感标记是等级分类和非等级类别的组合，是实施强制访问控制的依据。

**等级说明**

Vastbase中敏感标记由等级分类和非等级类别两部分组成，如表1所示。两者中间用冒号（“:”）分隔，形式如下：

```
等级分类组:非等级类别组
```

其中等级分类组由多个等级分类组成，非等级类别组由多个非等级类别组成。等级分类和非等级类别之间用逗号（“,”）分隔，用点号（“.”）表示区间。

例如敏感标记“L1,L3.L7:G2,G4.G6,G27”表示的等级分类和非等级类别分别为：

等级分类：L1,L3~L7

非等级类别：G2,G4~G6,G27

表1

| 类别       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| 等级分类   | Vastbase内置了16个等级分类，命名为Li，其中（1≤i≤16），等级标记满足偏序关系（若i≤j，则Li ≤ Lj）。 |
| 非等级类别 | Vastbase内置了32个非等级类别，命名为Gi，其中（1≤i≤32）。非等级标记无法进行大小比较，但可以进行集合运算。例如非等级标记“G1,G3”包含“G1”。 |

Vastbase中只有自主访问控制（DAC）校验通过的情况下才能进行强制访问控制（MAC）校验，强制访问控制的读写规则如表2所示。

表2

| 强制访问控制策略     | 描述                                                         |
| :------------------- | ------------------------------------------------------------ |
| 表插入（INSERT）策略 | 主体敏感等级标记小于等于表敏感等级标记，且主体敏感非等级标记是表敏感非等级标记子集则允许插入。 |
| 表修改（UPDATE）策略 | 主体敏感标记与元组的敏感标记一致则允许修改元组。             |
| 表删除（DELETE）策略 | 同修改（UPDATE）策略。                                       |
| 表查询（SELECT）策略 | 主体敏感等级标记大于等于元组敏感等级标记，且主体敏感非等级标记是元组敏感非等级标记超集则允许查询。 |
| 存储过程和触发器     | 当主体安全等级标记等于函数/存储过程安全等级标记，且主体安全非等级标记是函数/存储过程安全非等级标记超集则允许执行。 |

**语法格式**

表列：

```
SECURITY LABEL [FOR provider] ON COLUMN table_name.column_name IS 'label_name';  --设置表列的敏感标记
SECURITY LABEL [FOR provider] ON COLUMN table_name.column_name IS NULL;  --删除表列的敏感标记
```

存储过程：

```
SECURITY LABEL [ FOR vastbase ] ON PROCEDURE procedure_name [ ( [ [ argmode ] [ argname ] argtype [, ...] ] ) ] IS 'label_name' | NULL;
```

触发器：

```
SECURITY LABEL [ FOR vastbase ] ON TRIGGER object_name OF table_name IS 'label_name'' | NULL;
```

**参数说明**

label_name：敏感标记名称，在数据库中是唯一的，其长度不能超过63个字节，所有的非关键字、非保留关键字、可以做字段名称的关键字均可作为敏感标记名称。

provider：插件，数据库通过将插件（如果有）和数据库默认加载的插件ogmac组成链表。

**示例**

- 表强制访问控制策略

1、登陆进入vastbase数据库，创建用户。

```
  create user user1 with password 'vastbase@123';
  create user user2 with password 'vastbase@123';
  create user user3 with password 'vastbase@123';
  create user user4 with password 'vastbase@123';
  create user user5 with password 'vastbase@123';
  create user user6 with password 'vastbase@123';
  create user user7 with password 'vastbase@123';
  create user user8 with password 'vastbase@123';
  create user user9 with password 'vastbase@123';
  create table t1(c1 int,c2 varchar(50));
```

2、给用户授权。

```
  GRANT ALL ON TABLE t1 TO user1;
  GRANT ALL ON TABLE t1 TO user2;
  GRANT ALL ON TABLE t1 TO user3;
  GRANT ALL ON TABLE t1 TO user4;
  GRANT ALL ON TABLE t1 TO user5;
  GRANT ALL ON TABLE t1 TO user6;
  GRANT ALL ON TABLE t1 TO user7;
  GRANT ALL ON TABLE t1 TO user8;
  GRANT ALL ON TABLE t1 TO user9;
```

3、创建标签并为主体和客体授予标签。

```
CREATE SECURITY LABEL label1 'L8:G7,G2,G32,G15.G20';
CREATE SECURITY LABEL label2 'L5:G7,G2,G15.G20';
CREATE SECURITY LABEL label3 'L10:G2,G7';
CREATE SECURITY LABEL label4 'L15:G1,G2,G4,G7.G10,G32,G15.G20';
CREATE SECURITY LABEL label5 'L12:G1,G2,G7.G10,G32,G15.G20';
CREATE SECURITY LABEL label6 'L8:G7,G2,G32,G15.G20';
CREATE SECURITY LABEL label7 'L8:G7,G2,G32,G15.G20';
```
4、对数据库对象设置敏感标记。

```
SECURITY LABEL ON TABLE t1 IS 'label1';
SECURITY LABEL ON role user1 IS 'label2';
SECURITY LABEL ON role user2 IS 'label3';
SECURITY LABEL ON role user3 IS 'label4';
SECURITY LABEL ON role user4 IS 'label2';
SECURITY LABEL ON role user5 IS 'label3';
SECURITY LABEL ON role user6 IS 'label5';
SECURITY LABEL ON role user7 IS 'label6';
SECURITY LABEL ON role user8 IS 'label7';
```
5、根据情况分别用user1,user2,user3,user4,user5,user6,user7,user8用户登数据库，对表t1中的记录进行增删改查操作。
1)主体等级小于等于客体的等级，主体非等级是客体的非等级的子集时，主体(用户)对客体(表)insert数据。

  首次切换至新角色（user1）需要更新密码（密码至少需要包含三种字符）。

```
  \c - user1
```

  使用如下命令来更改密码：

```
  ALTER ROLE user1 identified by 'vastbase@12' replace 'vastbase@123';
```

  进行插入操作。

```
  insert into t1 values(1,'aaa');
  insert into t1 values(2,'bbb');
  insert into t1 values(3,'ccc');
  insert into t1 values(4,'ddd');
```

  2)主体等级大于等于客体的等级，主体非等级是客体的非等级的超集时，主体(用户)对客体(表)进行select。

  首次切换至新角色（user6）需要更新密码（密码至少需要包含三种字符）。

```
  \c - user6 
```

  使用如下命令来更改密码：

```
  ALTER ROLE user6 identified by 'vastbase@12' replace 'vastbase@123';
```

  进行查询操作。

```
  select * from t1;
```

  结果显示如下：

```
  c1 | c2  
  ----+-----
   1 | aaa
   2 | bbb
   3 | ccc
   4 | ddd
  (4 rows)
```

  3)主体等级等于客体的等级，主体非等级等于客体的非等级时，主体(用户)对客体(表)进行update操作。

首次切换至新角色（user7）需要更新密码（密码至少需要包含三种字符）。

```
\c - user7
```

使用如下命令来更改密码：

```
ALTER ROLE user7 identified by 'vastbase@12' replace 'vastbase@123';
```

进行更新操作。

```
update t1 set c2='mmm';
```

验证结果如下所示：

```
select * from t1;
 c1 | c2  
----+-----
 1 | mmm
 2 | mmm
 3 | mmm
 4 | mmm
(4 rows)
```

4)主体等级等于客体的等级，主体非等级等于客体的非等级时，主体(用户)对客体(表)进行delete操作。

首次切换至新角色（user7）需要更新密码（密码至少需要包含三种字符）。

```
\c - user8
```

使用如下命令来更改密码：

```
ALTER ROLE user8 identified by 'vastbase@12' replace 'vastbase@123';
```

执行删除。

```
delete from t1 where c1=4;
```

验证结果如下所示：

```
select * from t1;
 c1 | c2  
----+-----
 1 | mmm
 2 | mmm
 3 | mmm
(3 rows)
```



- 存储过程强制访问控制策略

1、创建存储过程。

```
CREATE OR REPLACE PROCEDURE prc_add
(
param1 IN INTEGER,
param2 IN OUT INTEGER
)
AS
BEGIN
param2:= param1 + param2;
dbms_output.put_line('result is: '||to_char(param2));
END;
/
```

2、创建安全标签。

```
CREATE SECURITY LABEL label_pro 'L5:G7,G2';
```

3、设置安全标签。

```
SECURITY LABEL ON PROCEDURE prc_add IS 'label_pro';
```

- 触发器强制访问控制策略

1、创建触发器。

```
CREATE TABLE test_trigger_src_tbl(id1 INT, id2 INT, id3 INT);
CREATE TABLE test_trigger_des_tbl(id1 INT, id2 INT, id3 INT);
CREATE OR REPLACE FUNCTION tri_insert_func() RETURNS TRIGGER AS
$$
DECLARE
BEGIN
INSERT INTO test_trigger_des_tbl VALUES(NEW.id1, NEW.id2, NEW.id3);
RETURN NEW;
END
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER insert_trigger
BEFORE INSERT ON test_trigger_src_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_insert_func();
```

2、创建安全标签。

```
CREATE SECURITY LABEL label_tri 'L5:G7,G2,G15.G21';
```

3、设置安全标签。

```
SECURITY LABEL ON TRIGGER insert_trigger OF test_trigger_src_tbl IS 'label_tri';
```

#### 管理用户及权限

##### 默认权限机制

**默认权限**

数据库对象创建后，进行对象创建的用户就是该对象的所有者。Vastbase安装后的默认情况下，未开启“三权分立”，数据库系统管理员具有与对象所有者相同的权限。也就是说对象创建后，默认只有对象所有者或者系统管理员可以查询、修改和销毁对象，以及通过GRANT将对象的权限授予其他用户。

系统表和系统视图要么只对系统管理员可见，要么对所有用户可见。标识了需要系统管理员权限的系统表和视图只有系统管理员可以查询。 有关信息，请参考系统表和系统视图。

数据库提供对象隔离的特性，对象隔离特性开启时，用户只能查看有权限访问的对象（表、视图、字段、函数），系统管理员不受影响。有关信息，请参考ALTER DATABASE。

**授予权限**

为使其他用户能够使用对象，必须向用户或包含该用户的角色授予必要的权限。

Vastbase支持以下的权限：SELECT、INSERT、UPDATE、DELETE、TRUNCATE、REFERENCES、CREATE、CONNECT、EXECUTE和USAGE。不同的权限与不同的对象类型关联。有关各权限的详细信息，请参见SQL语法GRANT。

**撤销权限**

要撤消已经授予的权限，可以使用REVOKE。对象所有者的权限（例如ALTER、 DROP、GRANT和REVOKE）是隐式的，无法授予或撤消。即只要拥有对象就可以执行对象所有者的这些隐式权限。对象所有者可以撤消自己的普通权限，例如，使表对自己以及其他人只读。

**注意事项**

在通过GRANT/REVOKE增加或减少管理员成员时，要求授权人和被授权人是同类型的管理员。

##### 管理员

**初始用户**

Vastbase安装过程中自动生成的帐户称为初始用户。初始用户也是系统管理员，拥有系统的最高权限，能够执行所有的操作。该帐户与进行Vastbase安装的操作系统用户同名。

初始用户会绕过所有权限检查。建议仅将此初始用户作为DBA管理用途，而非业务应用。

**系统管理员**

系统管理员是指具有SYSADMIN属性的帐户，默认安装情况下具有与对象所有者相同的权限，但不包括dbe_perf模式的对象权限。

要创建新的系统管理员，请以初始用户或者系统管理员用户身份连接数据库，并使用带SYSADMIN选项的CREATE USER语句或 ALTER USER语句进行设置。

```
CREATE USER sysadmin WITH SYSADMIN password "Bigdata@123";
```

或者

```
ALTER USER joe SYSADMIN;
```

ALTER USER时，要求用户已存在。

**监控管理员**

监控管理员是指具有MONADMIN属性的帐户，具有查看dbe_perf模式下视图和函数的权限，亦可以对dbe_perf模式的对象权限进行授予或收回。

要创建新的监控管理员，请以系统管理员身份连接数据库，并使用带MONADMIN选项的CREATE USER语句或ALTER USER语句进行设置。

```
CREATE USER monadmin WITH MONADMIN password "xxxxxxxxx";
```

或者

```
ALTER USER joe MONADMIN;
```

ALTER USER时，要求用户已存在。

**运维管理员**

运维管理员是指具有OPRADMIN属性的帐户，具有使用Roach工具执行备份恢复的权限。

要创建新的运维管理员，请以初始用户身份连接数据库，并使用带OPRADMIN选项的CREATE USER语句或ALTER USER语句进行设置。

```
CREATE USER opradmin WITH OPRADMIN password "xxxxxxxxx";
```

或者

```
ALTER USER joe OPRADMIN;
```

ALTER USER时，要求用户已存在。

**安全策略管理员**

安全策略管理员是指具有POLADMIN属性的帐户，具有创建资源标签、脱敏策略和统一审计策略的权限。

要创建新的安全策略管理员，请以系统管理员用户身份连接数据库，并使用带POLADMIN选项的CREATE USER语句或ALTER USER语句进行设置。

```
CREATE USER poladmin WITH POLADMIN password "xxxxxxxxx";
```

或者

```
ALTER USER joe POLADMIN;
```

ALTER USER时，要求用户已存在。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> 三个管理员，即系统管理员（vbadmin)、安全管理员（vbsso)、审计管理员（vbaudit），无论通过何种方式初始化数据库实例，在初始化实例时，随机生成管理员口令，口令生成后，打印输出。
>
> 在三个管理员首次登录时，必须修改口令方可进行正常操作，新密码要符合密码复杂度要求。

##### 三权分立

**功能描述**

默认权限机制和管理员两节的描述基于的是Vastbase创建之初的默认情况。从前面的介绍可以看出，默认情况下拥有SYSADMIN属性的系统管理员，具备系统最高权限。

在实际业务管理中，为了避免系统管理员拥有过度集中的权利带来高风险，可以设置三权分立。将系统管理员的部分权限分立给安全管理员和审计管理员，形成系统管理员、安全管理员和审计管理员三权分立。系统管理员权限主要对应数据库中日常运维，例如：创建用户、对象，修改数据库配置参数等；安全管理员权限允许用户维护敏感标记、对数据库对象设置敏感标记，无法创建表、用户和其他数据库对象；审计管理员权限允许用户维护审计策略、审计日志，无法创建表、用户和其他数据库对象。简言之，除了系统管理员和普通用户，安全管理员和审计管理员不接触用户数据。

三权分立后，系统管理员只会对自己作为所有者的对象有权限。

初始用户的权限不受三权分立设置影响。因此建议仅将此初始用户作为DBA管理用途，而非业务应用。

**配置方法**

三权分立的设置办法为：将参数enable_Separation_Of_Duty设置为on，并重启数据库。

**注意事项**

- 在启用三权分立功能情况下，不允许修改其他类型用户的属性，不允许修改用户属性使之同时具备安全员、审计员和管理员中两种或以上权限。例如不允许管理员修改安全员的用户属性。

- 不允许同时指定sysadmin、auditadmin和ssoadmin中两种或以上属性，若用户属性为auditadmin或者ssoadmin，则不允许指定createrole和createdb属性。

**权限说明**

- 三权分立前的权限详情及三权分立后的权限变化，请分别参见表1和表2。


**表 1** 默认的用户权限

<table>
    <tr>
        <td>对象名称</td> 
        <td>初始用户（id为10）</td> 
        <td>系统管理员</td>
        <td>监控管理员</td>
        <td>运维管理员</td>
        <td>安全策略管理员</td>
        <td>安全管理员</td>
        <td>审计管理员</td>
        <td>普通用户</td>
   </tr>
    <tr>
        <td >表空间</td>
        <td rowspan="7">具有除私有用户表对象访问权限外，所有的权限</td>
        <td>对表空间有创建、修改、删除、访问、分配操作的权限。</td>
        <td colspan="6">不具有对表空间进行创建、修改、删除、分配的权限，访问需要被赋权。</td>
    </tr>
    <tr>
        <td >表</td>
        <td>对所有表有所有的权限。</td>
        <td colspan="6">仅对自己的表有所有的权限，对其他用户的表无权限。</td>
    </tr>
        <tr>
        <td >索引</td>
        <td>可以在所有的表上建立索引。</td>
        <td colspan="6">仅可以在自己的表上建立索引。</td>
    </tr>
        <tr>
        <td >模式</td>
        <td>对除dbe_perf以外的所有模式有所有的权限。</td>
        <td>仅对dbe_perf模式和自己的模式有所有的权限，对其他用户的模式无权限。</td>
        <td colspan="5">仅对自己的模式有所有的权限，对其他用户的模式无权限。</td>
    </tr>
        <tr>
        <td >函数</td>
        <td>对除dbe_perf模式下的函数以外的所有的函数有所有的权限。</td>
        <td>仅对dbe_perf模式下的和自己的函数有所有的权限，对其他用户放在public这个公共模式下的函数有调用的权限，对其他用户放在其他模式下的函数无权限。</td>
        <td colspan="5">仅对自己的函数有所有的权限，对其他用户放在public这个公共模式下的函数有调用的权限，对其他用户放在其他模式下的函数无权限。</td>
    </tr>
        <tr>
        <td>自定义视图</td>
        <td>对除dbe_perf模式下的视图以外的所有的视图有所有的权限。</td>
        <td>仅对dbe_perf模式下的和自己的视图有所有的权限，对其他用户的视图无权限。</td>
        <td colspan="5">仅对自己的视图有所有的权限，对其他用户的视图无权限。</td>
    </tr>
        <tr>
        <td>系统表和系统视图</td>
        <td>可以查看所有系统表和视图。</td>
        <td colspan="6">只可以查看部分系统表和视图。详细请参见系统表和系统视图。</td>
    </tr>

**表 2** 三权分立较非三权分立权限变化说明

<table>
    <tr>
        <td>对象名称</td> 
        <td>初始用户（id为10）</td> 
        <td>系统管理员</td>
        <td>监控管理员</td>
        <td>运维管理员</td>
        <td>安全策略管理员</td>
        <td>安全管理员</td>
        <td>审计管理员</td>
        <td>普通用户</td>
   </tr>
   <tr>
       <td>表空间</td>
       <td rowspan="7">无变化。
依然具有除私有用户表对象访问权限外，所有的权限。</td>
       <td>无变化</td>
       <td colspan="6">无变化。</td>
    </tr>
    <tr>
        <td>表</td>
        <td>权限缩小。只对自己的表及其他用户放在public模式下的表有所有的权限，对其他用户放在属于各自模式下的表无权限。</td>
         <td colspan="6">无变化。</td>
    </tr>
    <tr>
        <td>索引</td>
        <td>权限缩小。只可以在自己的表及其他用户放在public模式下的表上建立索引。</td>
         <td colspan="6">无变化。</td>
    </tr>
    <tr>
        <td>模式</td>
        <td>权限缩小。只对自己的模式有所有的权限，对其他用户的模式无权限。</td>
        <td colspan="6">无变化。</td>
    </tr>
    <tr>
        <td>函数</td>
        <td>权限缩小。
只对自己的函数及其他用户放在public模式下的函数有所有的权限，对其他用户放在属于各自模式下的函数无权限。</td>
        <td colspan="6">无变化。</td>
    </tr>
    <tr>
        <td>自定义视图</td>
        <td>权限缩小。
只对自己的视图及其他用户放在public模式下的视图有所有的权限，对其他用户放在属于各自模式下的视图无权限。</td>
        <td colspan="6">无变化。</td>
    </tr>
    <tr>
        <td>系统表和系统视图</td>
        <td colspan="7">无变化。</td>
    </tr>

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> PG_STATISTIC系统表和PG_STATISTIC_EXT系统表存储了统计对象的一些敏感信息，如高频值MCV。进行三权分立后系统管理员仍可以通过访问这两张系统表，得到统计信息里的这些信息。

- 三种管理员的权限和范围如下所示

**表 3** 审计员权限列表

| 权限类型           | 说明                                           |
| ------------------ | ---------------------------------------------- |
| AUDIT.VB_AUDIT_LOG | 对外部表audit.VB_AUDIT_LOG中审计日志的查询权限 |
| pg_query_audit     | 对函数pg_query_audit中审计记录的查询权限       |
| COPY               | 使用COPY命令对审计日志进行操作                 |

**表 4** 安全员权限列表

| PRIVILEGE类型                 | 说明                                            |
| ----------------------------- | ----------------------------------------------- |
| CREATE SECURITY LABEL         | 创建敏感标记                                    |
| DROP SECURITY LABEL           | 删除敏感标记                                    |
| SECURITY LABEL ON             | 对数据库对象设置敏感标记                        |
| PG_SECLABEL                   | 对数据字典PG_SECLABEL的查询权限                 |
| PG_SHSECLABEL                 | 对数据字典PG_SHSECLABEL的查询权限               |
| PG_OGMAC_SECLABEL             | 对数据字典PG_OGMAC_SECLABEL的查询权限           |
| PG_RLSPOLICY                  | 对系统表PG_RLSPOLICY的查询权限                  |
| CREATE POLICY                 | 创建行安全策略                                  |
| ALTER POLICY                  | 修改行安全策略                                  |
| DROP POLICY                   | 删除行安全策略                                  |
| ALTER TABLE                   | 启用/禁用表上的行安全策略                       |
| CREATE RESOURCE LABEL         | 创建资源池                                      |
| ALTER RESOURCE LABEL          | 修改资源池                                      |
| DROP RESOURCE LABEL           | 删除资源池                                      |
| CREATE MASKING POLICY         | 创建审计脱敏策略                                |
| ALTER MASKING POLICY          | 修改审计脱敏策略                                |
| DROP MASKING POLICY           | 删除审计脱敏策略                                |
| CREATE AUDIT POLICY           | 创建审计策略                                    |
| ALTER AUDIT POLICY            | 修改审计策略                                    |
| DROP AUDIT POLICY             | 删除审计策略                                    |
| GS_POLICY_LABEL               | 对系统表GS_POLICY_LABEL的查询权限               |
| GS_AUDITING_POLICY            | 对系统表GS_AUDITING_POLICY的查询权限            |
| GS_AUDITING_POLICY_ACCESS     | 对系统表GS_AUDITING_POLICY_ACCESS的查询权限     |
| GS_AUDITING_POLICY_PRIVILEGES | 对系统表GS_AUDITING_POLICY_PRIVILEGES的查询权限 |
| GS_AUDITING_POLICY_FILTERS    | 对系统表GS_AUDITING_POLICY_FILTERS的查询权限    |
| GS_LABEL                      | 对视图GS_LABELS的查询权限                       |
| GS_MASKING                    | 对视图GS_MASKING的查询权限                      |
| GS_AUDITING                   | 对视图GS_AUDITING的查询权限                     |
| GS_AUDITING_ACCESS            | 对视图GS_AUDITING_ACCESS的查询权限              |
| GS_AUDITING_PRIVILEGE         | 对视图GS_AUDITING_PRIVILEGE的查询权限           |
| GA_MASKING_POLICY             | 对视图GS_MASKING_POLICY的查询权限               |
| GS_MASKING_POLICY_FILTER      | 对视图GS_MASKING_POLICY_FILTER的查询权限        |
| GS_MASKING_POLICY_ACTIONS     | 对视图GS_MASKING_POLICY_ACTION的查询权限        |

**表 5** 系统管理员权限列表 

| PRIVILEGE类型      | 说明                                                 |
| ------------------ | ---------------------------------------------------- |
| GRANT/REVOKE       | 增加/移除成员关系。要求成员和父成员管理类型一致      |
| pg_dump/pg_restore | 只允许系统管理员使用pg_dump/pg_restore对数据进行操作 |

**表 6** 共有权限列表

| PRIVILEGE类型    | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| SET              | 设置会话参数。安全管理参数和审计管理参数只允许相应的安全管理员和审计管理员进行管理 |
| CREATE ROLE/USER | 创建角色/用户，只允许创建同类型的管理员用户                  |
| ALTER ROLE/USER  | 修改角色/用户信息，要求被修改者与执行者管理类型一致          |
| DROP ROLE/USER   | 删除角色/用户， 要求执行用户与被删除者管理类型一致           |

##### 用户

**功能描述**

使用CREATE USER和ALTER USER可以创建和管理数据库用户。Vastbase包含一个或多个已命名数据库。用户和角色在整个Vastbase范围内是共享的，但是其数据并不共享。即用户可以连接任何数据库，但当连接成功后，任何用户都只能访问连接请求里声明的那个数据库。

非三权分立下，Vastbase用户帐户只能由系统管理员或拥有CREATEROLE属性的安全管理员创建和删除。三权分立时，只允许系统管理员创建系统管理员，审计员创建审计用户，安全员创建安全用户。不需要再指定用户的管理类型标识。只允许系统管理员删除系统管理员，审计员删除审计用户，安全员删除安全用户。

在用户登录Vastbase时会对其进行身份验证。用户可以拥有数据库和数据库对象（例如表），并且可以向用户和角色授予对这些对象的权限以控制谁可以访问哪个对象。除系统管理员外，具有CREATEDB属性的用户可以创建数据库并授予对这些数据库的权限。

**创建、修改和删除用户**

- 要创建用户，请使用SQL语句CREATE USER。

例如：创建用户joe，并设置用户拥有CREATEDB属性。

```
CREATE USER joe WITH CREATEDB PASSWORD "Bigdata@123";
CREATE ROLE
```

- 要创建系统管理员，请使用带有SYSADMIN选项的CREATE USER语句 。

- 要删除现有用户，请使用DROP USER。

- 要更改用户帐户（例如，重命名用户或更改密码），请使用ALTER USER。

- 要查看用户列表，请查询视图PG_USER：

  ```
  SELECT * FROM pg_user; 
  ```

- 要查看用户属性，请查询系统表15.2.14PG_AUTHID：

  ```
  SELECT * FROM pg_authid; 
  ```

**普通用户口令**

Vastbase支持设置强制新建用户首次登录修改密码，可通过设置password_force_alter参数为on实现，参数默认启用。

- 在password_force_alter参数为on时，管理员新建普通用户，为新建用户设置初始密码（初始密码复杂度受密码复杂度相关参数控制）。新建用户在首次登录时，必须修改密码后才可正常操作。
- 在password_force_alter参数为on时，管理员可以按照密码复杂度要求修改普通用户密码。普通用户在使用管理员修改的密码首次登录后，必须修改密码方可正常操作。
- 在password_force_alter参数为off时，对普通用户首次登录或连接不强制要求修改密码。

**私有用户**

对于有多个业务部门，各部门间使用不同的数据库用户进行业务操作，同时有一个同级的数据库维护部门使用数据库管理员进行维护操作的场景下，业务部门可能希望在未经授权的情况下，管理员用户只能对各部门的数据进行控制操作（DROP、ALTER、TRUNCATE），但是不能进行访问操作（INSERT、DELETE、UPDATE、SELECT、COPY）。即针对管理员用户，表对象的控制权和访问权要能够分离，提高普通用户数据安全性。

三权分立情况下，管理员对其他用户放在属于各自模式下的表无权限。但是，这种无权限包含了无控制权限，因此不能满足上面的诉求。为此，Vastbase提供了私有用户方案。即在非三权分立模式下，创建具有INDEPENDENT属性的私有用户。

```
vastbase=# CREATE USER user_independent WITH INDEPENDENT IDENTIFIED BY "1234@abc";
```

针对该用户的对象，系统管理员和拥有CREATEROLE属性的安全管理员在未经其授权前，只能进行控制操作（DROP、ALTER、TRUNCATE），无权进行INSERT、DELETE、SELECT、UPDATE、COPY、GRANT、REVOKE、ALTER OWNER操作。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> PG_STATISTIC系统表和PG_STATISTIC_EXT系统表存储了统计对象的一些敏感信息，如高频值MCV。进行三权分立后系统管理员仍可以通过访问这两张系统表，得到统计信息里的这些信息。

**永久用户**

Vastbase提供永久用户方案，即创建具有PERSISTENCE属性的永久用户。

```
vastbase=# CREATE USER user_persistence WITH persistence IDENTIFIED BY "1234@abc";
```

只允许初始用户创建、修改和删除具有PERSISTENCE属性的永久用户。



##### 角色

**功能描述**

角色是一组用户的集合。通过GRANT把角色授予用户后，用户即具有了角色的所有权限。推荐使用角色进行高效权限分配。例如，可以为设计、开发和维护人员创建不同的角色，将角色GRANT给用户后，再向每个角色中的用户授予其工作所需数据的差异权限。在角色级别授予或撤消权限时，这些更改将作用到角色下的所有成员。

Vastbase提供了一个隐式定义的拥有所有角色的组PUBLIC，所有创建的用户和角色默认拥有PUBLIC所拥有的权限。关于PUBLIC默认拥有的权限请参考GRANT。要撤销或重新授予用户和角色对PUBLIC的权限， 可通过在GRANT和REVOKE指定关键字PUBLIC实现。

**查询角色**

要查看所有角色，请查询系统表PG_ROLES：

```
SELECT * FROM PG_ROLES;
```

**创建、修改和删除角色**

非三权分立时，只有系统管理员和具有CREATEROLE属性的用户才能创建、修改或删除角色。三权分立下，只有初始用户和具有CREATEROLE属性的用户才能创建、修改或删除角色。

- 要创建角色，请使用CREATE ROLE。

- 要在现有角色中添加或删除用户，请使用ALTER ROLE。

- 要删除角色，请使用DROP ROLE。DROP ROLE只会删除角色，并不会删除角色中的成员用户帐户。

**内置角色**

Vastbase提供了一组默认角色，以gs_role开头命名。它们提供对特定的、通常需要高权限的操作的访问，可以将这些角色GRANT给数据库内的其他用户或角色，让这些用户能够使用特定的功能。在授予这些角色时应当非常小心，以确保它们被用在需要的地方。[表1](https://www.Vastbase.org/zh/docs/3.0.0/docs/Developerguide/角色.html#table2118117460)描述了内置角色允许的权限范围：

**表 1** 内置角色权限描述

| 角色                     | 权限描述                                                     |
| :----------------------- | :----------------------------------------------------------- |
| gs_role_copy_files       | 具有执行copy … to/from filename的权限，但需要先打开GUC参数enable_copy_server_files。 |
| gs_role_signal_backend   | 具有调用函数pg_cancel_backend、pg_terminate_backend和pg_terminate_session来取消或终止其他会话的权限，但不能操作属于初始用户和PERSISTENCE用户的会话。 |
| gs_role_tablespace       | 具有创建表空间（tablespace）的权限。                         |
| gs_role_replication      | 具有调用逻辑复制相关函数的权限，例如kill_snapshot、pg_create_logical_replication_slot、pg_create_physical_replication_slot、pg_drop_replication_slot、pg_replication_slot_advance、pg_create_physical_replication_slot_extern、pg_logical_slot_get_changes、pg_logical_slot_peek_changes、pg_logical_slot_get_binary_changes、pg_logical_slot_peek_binary_changes。 |
| gs_role_account_lock     | 具有加解锁用户的权限，但不能加解锁初始用户和PERSISTENCE用户。 |
| gs_role_pldebugger       | 具有执行dbe_pldebugger下调试函数的权限。                     |
| gs_role_directory_create | 具有执行创建directory对象的权限，但需要先打开GUC参数enable_access_server_directory。 |
| gs_role_directory_drop   | 具有执行删除directory对象的权限，但需要先打开GUC参数enable_access_server_directory。 |

关于内置角色的管理有如下约束：

- 以gs_role开头的角色名作为数据库的内置角色保留名，禁止新建以“gs_role”开头的用户/角色，也禁止将已有的用户/角色重命名为以“gs_role_”开头；

- 禁止对内置角色的ALTER和DROP操作；

- 内置角色默认没有LOGIN权限，不设预置密码；

- gsql元命令\du和\dg不显示内置角色的相关信息，但若显示指定了pattern为特定内置角色则会显示；

- 三权分立关闭时，初始用户、具有SYSADMIN权限的用户和具有内置角色ADMIN OPTION权限的用户有权对内置角色执行GRANT/REVOKE管理。三权分立打开时，初始用户和具有内置角色ADMIN OPTION权限的用户有权对内置角色执行GRANT/REVOKE管理。例如：

  ```
  GRANT gs_role_signal_backend TO user1;
  REVOKE gs_role_signal_backend FROM user1;
  ```

##### Schema

**功能描述**

Schema又称作模式。通过管理Schema，允许多个用户使用同一数据库而不相互干扰，可以将数据库对象组织成易于管理的逻辑组，同时便于将第三方应用添加到相应的Schema下而不引起冲突。

每个数据库包含一个或多个Schema。数据库中的每个Schema包含表和其他类型的对象。数据库创建初始，默认具有一个名为public的Schema，且所有用户都拥有此Schema的权限。可以通过Schema分组数据库对象。Schema类似于操作系统目录，但Schema不能嵌套。

相同的数据库对象名称可以应用在同一数据库的不同Schema中，而没有冲突。例如，a_schema和b_schema都可以包含名为mytable的表。具有所需权限的用户可以访问数据库的多个Schema中的对象。

在数据库创建用户时，系统会自动帮助用户创建一个同名Schema。

数据库对象是创建在数据库搜索路径中的第一个Schema内的。有关默认情况下的第一个Schema情况及如何变更Schema顺序等更多信息，请参见搜索路径。

**创建、修改和删除Schema**

- 要创建Schema，请使用章节“CREATE SCHEMA”。默认初始用户和系统管理员可以创建Schema，其他用户需要具备数据库的CREATE权限才可以在该数据库中创建Schema，赋权方式请参考章节“GRANT”中将数据库的访问权限赋予指定的用户或角色中的语法。

- 要更改Schema名称或者所有者，请使用章节“ALTER SCHEMA”。Schema所有者可以更改Schema。

- 要删除Schema及其对象，请使用“DROP SCHEMA”。Schema所有者可以删除Schema。

- 要在Schema内创建表，请以schema_name.table_name格式创建表。不指定schema_name时，对象默认创建到搜索路径中的第一个Schema内。

- 要查看Schema所有者，请对系统表PG_NAMESPACE和PG_USER执行如下关联查询。语句中的schema_name请替换为实际要查找的Schema名称。

```
SELECT s.nspname,u.usename AS nspowner FROM pg_namespace s, pg_user u WHERE nspname='schema_name' AND s.nspowner = u.usesysid;
```

- 要查看所有Schema的列表，请查询PG_NAMESPACE系统表。

```
SELECT * FROM pg_namespace;
```

- 要查看属于某Schema下的表列表，请查询系统视图PG_TABLES。例如，以下查询会返回Schema PG_CATALOG中的表列表。

```
SELECT distinct(tablename),schemaname from pg_tables where schemaname = 'pg_catalog';
```

**搜索路径**

搜索路径定义在search_path参数中，参数取值形式为采用逗号分隔的Schema名称列表。如果创建对象时未指定目标Schema，则将该对象会被添加到搜索路径中列出的第一个Schema中。当不同Schema中存在同名的对象时，查询对象未指定Schema的情况下，将从搜索路径中包含该对象的第一个Schema中返回对象。

- 要查看当前搜索路径，请使用章节“SHOW”。

```
SHOW SEARCH_PATH; 
 search_path 
---------------- 
 "$user",public 
(1 row)
```

search_path参数的默认值为："$user"，public。$user表示与当前会话用户名同名的Schema名，如果这样的模式不存在，$user将被忽略。所以默认情况下，用户连接数据库后，如果数据库下存在同名Schema，则对象会添加到同名Schema下，否则对象被添加到Public Schema下。

- 要更改当前会话的默认Schema，请使用SET命令。

执行如下命令将搜索路径设置为myschema、public，首先搜索myschema。

```
SET SEARCH_PATH TO myschema, public;
```

##### 用户权限设置

- 给用户直接授予某对象的权限，请使用GRANT。

将Schema中的表或者视图对象授权给其他用户或角色时，需要将表或视图所属Schema的USAGE权限同时授予该用户或角色。否则用户或角色将只能看到这些对象的名称，并不能实际进行对象访问。

例如，下面示例将Schema tpcds的权限赋给用户joe后，将表tpcds.web_returns的select权限赋给用户joe。

```
GRANT USAGE ON SCHEMA tpcds TO joe; 
GRANT SELECT ON TABLE tpcds.web_returns to joe;
```



- 给用户指定角色，使用户继承角色所拥有的对象权限。

1、创建角色。

新建一个角色lily，同时给角色指定系统权限CREATEDB：

```
CREATE ROLE lily WITH CREATEDB PASSWORD "Bigdata@123";
```

2、给角色赋予对象权限，清参考章节“GRANT”。

例如，将模式tpcds的权限赋给角色lily后，将表tpcds.web_returns的select权限赋给角色lily。

```
GRANT USAGE ON SCHEMA tpcds TO lily; 
GRANT SELECT ON TABLE tpcds.web_returns to lily;
```

3、将角色的权限赋予用户。

```
GRANT lily to joe;
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 当将角色的权限赋予用户时，角色的属性并不会传递到用户。

- 回收用户权限，请参考“REVOKE”。

#### 数据存储加密

**功能描述**

Vastbase数据库采用软加密方式实现数据加密功能，当用户向数据库中写入数据时，数据自动加密；当用户从数据库中查询数据时，数据被自动解密。建议开启存储加密功能，防止数据泄露。

**注意事项**

- 若需要使用gs_encrypt，key需要指定为3种类型的字符，且长度要为16。

- initdb时可使用--algothim指定加密算法。若使用非安全加密算法，可能存在安全风险，推荐使用安全加密算法，如：AES128。

- 目前支持两种国密算法，分别是：SM4-CTR-128和AES-CTR-128，默认支持的是AES-CTR-128。

**示例**

1、对密钥进行base64编码，生成存储加密密钥。

```
echo -n "12345abcde@ABCDE"|base64
```

结果显示如下：

```
MTIzNDVhYmNkZUBBQkNERQ==
```

生成主密钥。

```
echo -n "23456abcde@ABCDE"|base64
```

结果显示如下：

```
MjM0NTZhYmNkZUBBQkNERQ==
```

2、初始化实例（-K指定存储加密密钥，--masterkey指定主密钥）。

```
vb_initdb -D testdb --nodename='testdb' --algorithm=SM4-CTR-128 -K MTIzNDVhYmNkZUBBQkNERQ== --masterkey=MjM0NTZhYmNkZUBBQkNERQ==
```

3、配置密钥。

```
gs_encrypt -v ABCDEFGHIJKLMNOP -B MTIzNDVhYmNkZUBBQkNERQ== TRANS_ENCRYPT_SAMPLE_STRING
```

4、将上一步结果写入配置文件中。

```
Transparent_encrypted_string='上一步的结果'
```

5、启动实例。

```
在出现提示“please input the master key:”时，输入masterkey：MjM0NTZhYmNkZUBBQkNERQ==
```

6、vsql登录数据库，修改初始化用户密码。

```
alter user vastbase password 'Aa123456';
```

创建表并插入数据。

```
create table test_pwd (id int,name text);
insert into test_pwd values (1,'加密');
```

查询表中数据。

```
select * from test_pwd;
```

当结果显示如下信息，则表示数据插入成功。

```
 id | name 
----+------
 1 | 加密
(1 row)
```

7、进入数据目录（$PGDATA/base/）使用如下命令查看是否加密成功，没返回则表示加密成功。

```
grep -iR '加密' 
```

#### 身份认证与通信加密

**功能描述**

国密即国家密码局认定的国产密码算法，主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。Vastbase支持国密算法满足客户对数据库安全能力的要求。

国密算法支持的模块：

- 证书模块：生成国密证书并支持国密证书验证。

- 配置项：ssl_ciphers支持配置ssl_ciphers='DHE-SM2-SM4-GCM-SM3'。该配置项格式参考openssl算法原有设置形式“DHE-RSA-AES128-GCM-SHA256”，说明如下：
  - DHE：加密连接协议。
  - RSA/SM2：非对称加密算法。
  - AES128/SM4：对称加密算法。
  - GCM：指的是对称加密采用Counter模式，并带有消息验证码。
  - SHA256/SM3：摘要算法。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> ssl结构体中加解密具体实现函数需要根据ssl_ciphers配置内容将其设置为SM4对称加密，SM3摘要加密。
>
> 以上设置完成之后，可以实现通过国密证书相互验证，传输加密使用SM4算法加解密。

**前提条件**

1、在服务器安装openssl 1.1.1 。

2、配置用户认证方式。

```
认证方式	参数
md5			password_encryption_type=0
sha256+md5	password_encryption_type=1
sha256		password_encryption_type=2
sm3			password_encryption_type=3
```

在postgresql.conf文件中配置password_encryption_type，设置参数值为3，并重启数据库使该参数生效。

3、在pg_hba.conf文件中配置认证方式

```
#TYPE DATABASE         USER       ADDRESS         METHOD
host     all           test       127.0.0.1/32    sm3 
```

在METHOD中配置对于国密的认证方式，示例是sm3的国密认证配置，其他认证方式过程与SM3相同。

**注意事项**

支持openssl 1.1.1版本，1.1.1以下版本不支持。

**操作步骤**

1、申请CA证书。

（1）创建CA目录cadir并进入。

```
mkdir cadir
cd cadir
```

（2）copy配置文件openssl.cnf到当前目录。

```
cp /etc/pki/tls/openssl.cnf .
```

（3）开始搭建CA环境。

```
mkdir demoCA demoCA/newcerts demoCA/private
chmod 777 demoCA/private
```

（4）创建serial文件，写入01。

```
echo  01 > demoCA/serial
```

（5）创建文件index.txt 。

```
touch demoCA/index.txt
```

（6）修改openssl.cnf配置文件中配置项CA_default下的dir参数。

```
dir = ./demoCA
Default_md = sha256
```

​	至此CA环境搭建完成。
（7）生成CA私钥

```
openssl ecparam -out demoCA/private/cakey.pem -name SM2 -genkey
```

（8）生成根证书请求文件

```
openssl req -config openssl.cnf -key demoCA/private/cakey.pem -new -out cacert.req
```

（9）生成自签发根证书，生成根证书时，需要修改openssl.cnf文件，设置basicConstraints=CA:TRUE

```
vi openssl.cnf
```

（10）生成CA自签发根证书

```
openssl ca -config openssl.cnf  -in cacert.req -keyfile demoCA/private/cakey.pem  -selfsign -out demoCA/cacert.pem
```

（11）生成服务器私钥文件server.key

```
openssl ecparam -out server.key -name SM2 -genkey
```

（12）生成服务器证书请求文件server.req

```
openssl req -config openssl.cnf -key server.key -new -out server.req
```

（13）生成服务端/客户端证书时，修改openssl.cnf文件，设置basicConstraints=CA:FALSE

```
vi openssl.cnf
```

（14）对生成的服务器证书请求文件进行签发，签发后将生成正式的服务器证书server.crt

```
openssl ca -config openssl.cnf  -in server.req  -out server.crt  -days 3650
```

2、配置客户端参数。

- 双向认证

```
export PGSSLCERT="/home/vastdata/client.crt"
export PGSSLKEY="/home/vastdata/client.key"
export PGSSLMODE="verify-ca"
export PGSSLROOTCERT="/home/vastdata/cacert.pem"
```

-   单向认证

```
export PGSSLMODE="verify-ca"
export PGSSLROOTCERT="/home/vastdata/cacert.pem"
```

环境变量说明：

- PGSSLCERT：指定客户端证书文件，包含客户端的公钥。客户端证书用以表明客户端身份的合法性，公钥将发送给对端用来对数据进行加密。
- PGSSLKEY：指定客户端私钥文件，用以对公钥加密的数据进行解密。
- PGSSLMODE：设置是否和服务器进行SSL连接协商，以及指定SSL连接的优先级。
- PGSSLROOTCERT：指定为客户端颁发证书的根证书文件，根证书用于验证服务器证书的有效性。

- PGSSLCRL：指定证书吊销列表文件，用于验证服务器证书是否在废弃证书列表中，如果在，则服务器证书将会被视为无效证书。

3、生成客户端证书
修改客户端客户端根证书，密钥，证书以及密钥密码加密文件的权限，需保证权限为600。如果权限不满足要求，则客户端无法以SSL连接到Vastbase。
（1）生成客户端私钥。

```
openssl ecparam -out client.key -name SM2 -genkey
```

（2）生成客户端证书请求文件。

```
openssl req -config openssl.cnf -key client.key -new -out client.req
```

（3）对生成的客户端证书请求文件进行签发，签发后将生成正式的客户端证书client.crt 。

```
openssl ca -config openssl.cnf -in client.req  -out client.crt  -days 3650
```

（4）修改权限。

```
chmod 600 client.key
chmod 600 client.crt
chmod 600 cacert.pem
```

4、配置服务器端参数

```
ssl=on
require_ssl=on
ssl_cert_file='server.crt'
ssl_key_file='server.key'
ssl_ca_file='cacert.pem'
ssl_crl_file=''
ssl_ciphers='DHE-SM2-SM4-GCM-SM3'
```

参数解释：

- ssl：表示是否启动SSL功能。
- require_ssl：设置服务器端是否强制要求SSL连接。该参数只有当参数ssl为on时才有效。
- ssl_cert_file：指定服务器证书文件，包含服务器端的公钥。服务器证书用以表明服务器身份的合法性，公钥将发送给对端用来对数据进行加密。
- ssl_key_file：指定服务器私钥文件，用以对公钥加密的数据进行解密。
- ssl_ca_file：CA服务器的根证书。此参数可选择配置，需要验证客户端证书的合法性时才需要配置。
- ssl_crl_file：证书吊销列表，如果客户端证书在该列表中，则当前客户端证书被视为无效证书。
- ssl_ciphers：SSL通讯使用的加密算法。

该配置项格式参考openssl算法原有设置形式“DHE-RSA-AES128-GCM-SHA256”,说明如下：

- DHE：加密连接协议；
- RSA/SM2:非对称加密算法；
- AES128/SM4:对称加密算法；
- GCM：指的是对称加密采用Counter模式，并带有消息验证码；
- SHA256/SM3:摘要算法；

5、JDBC连接示例。

```
import java.util.Properties;

String urlWithCe = "jdbc:postgresql://192.168.254.82:15432/vastbase" ;
Properties properties = new Properties();
// 配置以ssl访问
properties.setProperty("ssl", "true");
// 配置根证书地址
properties.setProperty("sslrootcert", "cacert.pem");
// 配置客户端私钥地址

properties.setProperty("sslkey", "client.key");
// 配置客户端证书地址
properties.setProperty("sslcert", "client.crt");
Class.forName("org.postgresql.Driver");
connection = DriverManager.getConnection(urlWithCe, properties);
```



### 插件管理

#### pg_zhtrgm插件

**功能描述**

创建扩展pg_zhtrgm，其主要作用是做相似度匹配，可以简化全文索引的使用方式，并且该扩展不仅支持对英文字符全文检索，还允许对中文字符进行全文检索。

**注意事项**

- 用户需要在当前数据库中具有create权限，即可在当前数据库创建插件pg_zhtrgm。

- 若未使用安装程序安装Vastbase，为自己初始化实例，initdb时指定的 -E 和--locale参数对应的编码规则必须一致，否则将无法使用pg_zhtrgm插件。

**操作说明**

此类全文索引仅支持模糊查询，不支持等值匹配。对应的操作符如下所示：

| **操作符**     | **返回类型** | **描述**                                                     |
| -------------- | ------------ | ------------------------------------------------------------ |
| text ％ text   | boolean      | 如果其参数的相似度大于pg_trgm.similarity_threshold设置的当前相似度阈值，则返回true。 |
| text <％ text  | boolean      | 如果第一个参数的子集与第二个参数的有序集合的相似程度大于系统设定值，则返回true。当前的相似性阈值通过pg_trgm.word_similarity_threshold参数设定。 |
| text ％> text  | boolean      | <％运算符的换向器。                                          |
| text <-> text  | real         | 返回参数之间的“距离”，即1减去similarity()值。                |
| text <<-> text | real         | 返回参数之间的“距离”，即1减去word_similarity()值。           |
| text <->> text | real         | <<->运算符的换向器。                                         |

pg_zhgrtm支持使用函数。对应的函数如下所示

| **函数**              | **返回类型** | **描述**                                                     |
| --------------------- | ------------ | ------------------------------------------------------------ |
| similarity(text,text) | real         | 返回一个数字指示两个参数有多相似。该结果的范围是0（指示两个字符串完全不相似）到1（指示两个字符串完全一样）。 |
| show_trgm(text)       | text         | 返回一个给定字符串中所有的trigram组成的一个数组（实际上除了调试很少有用）。 |
| show_limit()          | real         | 返回%操作符使用的当前相似性阈值。                            |
| set_limit(real)       | real         | 设置%操作符使用的当前相似性阈值。                            |

**示例**

1、创建插件

```
create extension pg_zhtrgm;
```

2、创建中文数据表如下：

```
create table t_full_text(id int, info text);
insert into t_full_text values (1, ' Vastbase是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS），Vastbase支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等。同样，PostgreSQL也可以用许多方法扩展，例如通过增加新的数据类型、函数、操作符、聚集函数、索引方法、过程语言等。另外，因为许可证的灵活，任何人都可以以任何目的免费使用、修改和分发PostgreSQL。');
```

3、在此表上创建以pg_zhgrtm提供的gin_zhtrgm_ops、gist_zhtrgm_ops操作符类所支持的gin索引或gist索引，该索引创建不再需要借助to_tsvector函数，同样地，使用该索引进行查询时也不再需要借助to_tsquery函数。

```
create index idx_full_text1 on t_full_text using gin(info gin_zhtrgm_ops);
create index idx_full_text2 on t_full_text using gist(info gist_zhtrgm_ops);
```

4、可以进行单字、词语、条件、短句的全文搜索：

- 使用单字搜索。

```
select * from t_full_text where info like '%函%';
```

结果显示如下：

```
 id |                                                                                                                                                                                
           info                                                                                                                                                                                          
----+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------
  1 |  Vastbase是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS），Vastbase支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多
版本并发控制等。同样，PostgreSQL也可以用许多方法扩展，例如通过增加新的数据类型、函数、操作符、聚集函数、索引方法、过程语言等。另外，因为许可证的灵活，任何人都可以以任何目的免费使用、
改和分发PostgreSQL。
(1 row)
```

- 使用词语搜索。

```
select * from t_full_text where info like '%视图%';
```

结果显示如下：

```
 id |                                                                                                                                                                                  
           info                                                                                                                                                                                            
----+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------
  1 |  Vastbase是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS），Vastbase支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多
版本并发控制等。同样，PostgreSQL也可以用许多方法扩展，例如通过增加新的数据类型、函数、操作符、聚集函数、索引方法、过程语言等。另外，因为许可证的灵活，任何人都可以以任何目的免费使用、
改和分发PostgreSQL。
(1 row)
```

- not like条件搜索。

```
select * from t_full_text where info like '%查询%' and info not like '%外键%';
```

结果显示如下：

```
 id | info 
----+------
(0 rows)
```

- 使用语句搜索

```
select * from t_full_text where info like '%Vastbase是一种特性非常齐全的自由软件的对象%';
```

结果显示如下：

```
 id |                                                                                                                                                                                  
           info                                                                                                                                                                                          
----+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------
  1 |  Vastbase是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS），Vastbase支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多
版本并发控制等。同样，PostgreSQL也可以用许多方法扩展，例如通过增加新的数据类型、函数、操作符、聚集函数、索引方法、过程语言等。另外，因为许可证的灵活，任何人都可以以任何目的免费使用、
改和分发PostgreSQL。
(1 row)
```




#### PGroonga插件

**功能描述**

PGroonga是一个全文检索插件，Vastbase G100已经内置了 PGroonga扩展，您只需要创建扩展，即可使用PGroonga支持的语言进行超高速全文检索。

**语法格式**

1、使用pgroonga()创建单字段全文索引。

```
CREATE  INDEX  pgroonga_index  ON  memos  USING  pgroonga(content1）;
```

- 使用&@操作符进行全文检索。

```
SELECT * FROM memos WHERE content &@ '全文搜索关键字';
```

- 使用&@~操作符执行含pgroonga查询语法的全文检索。

```
SELECT * FROM memos WHERE content2 &@~ 'PGroonga OR PostgreSQL';
```

- 使用like操作符（数据库本身的一种查询语法，区分大小写）执行全文检索。

```
SELECT * FROM memos WHERE content2 LIKE '%全文搜索关键字%';
```

- 使用ilike操作符（数据库本身的一种查询语法，不区分大小写）执行全文检索。

```
SELECT * FROM memos WHERE content2 ILIKE '%全文搜索关键字%';
```

2、使用pgroonga()创建多字段全文索引。

```
CREATE INDEX pgroonga_index_1 ON memos USING pgroonga(content1, content2);
```

- 使用&@操作符进行多字段全文检索。

```
SELECT * FROM memos WHERE content1 &@ '全文搜索关键字' and content2 &@ '全文搜索关键字';
```

- 使用like操作符（数据库本身的一种查询语法，区分大小写）执行多字段全文检索。

```
SELECT * FROM memos WHERE content1 like '%全文搜索关键字%' and content2 like '%全文搜索关键字%';
```

- 使用ilike操作符（数据库本身的一种查询语法，不区分大小写）执行多字段全文检索。

```
SELECT * FROM memos WHERE content1 ilike '%全文搜索关键字%' and content2 ilike '%全文搜索关键字%';
```

使用pgroonga_vacuum()函数清理临时数据。

```
select pgroonga_vacuum();
```

 

**示例**

1、创建插件。

修改postgresql.conf中配置enable_pgroonga=true

```
CREATE EXTENSION pgroonga;
```

2、关闭全表扫描，为了在少量数据下体现索引效果。

```
set enable_seqscan=off;
```

3、创建表，并插入数据。

```
CREATE TABLE memos (
id integer,
content text
);
INSERT INTO memos VALUES (1, 'PostgreSQL is a relational database management system.');
INSERT INTO memos VALUES (2, 'Groonga is a fast full text search engine that supports all languages.');
INSERT INTO memos VALUES (3, 'PGroonga is a PostgreSQL extension that uses Groonga as index.');
INSERT INTO memos VALUES (4, 'There is groonga command.');
```

4、创建全文索引。

```
CREATE INDEX idxA ON memos USING pgroonga (content pgroonga_text_full_text_search_ops_v2);
```

查看执行计划。

```
explain select * from memos where content LIKE '%groonga%';
```

结果显示如下：

```
                        QUERY PLAN                             
-------------------------------------------------------------------
 Index Scan using idxa on memos  (cost=0.00..4.01 rows=1 width=36)
   Index Cond: (content ~~ '%groonga%'::text)
(2 rows)
```

5、查看表中内容。

```
select * from memos where content LIKE '%groonga%';
```

结果显示如下：

```
 id |          content          
----+---------------------------
  4 | There is groonga command.
(1 row)
```

使用ILIKE查询。

```
select * from memos where content ILIKE '%roonga%';
```

结果显示如下：

```
 id | content 
----+---------
(0 rows)
```

5、查询验证。

- 使用&@操作符

```
SELECT * FROM memos WHERE content &@ 'languages';
```

结果显示如下：

```
id | content
----+------------------------------------------------------------------------
2 | Groonga is a fast full text search engine that supports all languages.
(1 row)
```

- 使用&@~操作符

```
SELECT * FROM memos WHERE content &@~ 'PGroonga OR PostgreSQL';
```

结果显示如下：

```
id | content
----+----------------------------------------------------------------
3 | PGroonga is a PostgreSQL extension that uses Groonga as index.
1 | PostgreSQL is a relational database management system.
(2 rows)
```

- 使用like操作符

```
SELECT * FROM memos WHERE content LIKE '%groonga%';
```

结果显示如下：

```
id | content
----+---------------------------
4 | There is groonga command.
(1 row)
```

- 使用ilike操作符

```
SELECT * FROM memos WHERE content ILIKE '%groonga%';
```

结果显示如下：

```
 id |                                content                                 
----+------------------------------------------------------------------------
  2 | Groonga is a fast full text search engine that supports all languages.
  3 | PGroonga is a PostgreSQL extension that uses Groonga as index.
  4 | There is groonga command.
(3 rows)
```

#### uuid-ossp插件

**功能描述**

uuid-ossp模块提供了一些函数用来生成通用唯一识别码（UUID），兼容uuid-ossp1.1，使用该模块提供的函数，采用几种标准算法之一产生通用唯一标识符（UUID）。

兼容的uuid-ossp模块的函数分为如下两类：

- 用于产生uuid的函数：

| 函数                                        | 描述                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| uuid_generate_v1()                          | 这个函数产生一个版本 1 的 UUID。这涉及到计算机的 MAC 地址和一个时间戳。注：这种 UUID 会泄露产生该标识符的计算机标识以及产生的时间，因此它不适合某些对安全性很敏感的应用。 |
| uuid_generate_v1mc()                        | 这个函数产生一个版本 1 的 UUID，但是使用一个随机广播 MAC 地址而不是该计算机真实的 MAC 地址。 |
| uuid_generate_v3(namespace uuid, name text) | 这个函数使用指定的输入名称在给定名字的空间中产生一个版本 3 的 UUID。该名字空间应该是由uuid_ns_*()函数产生的特殊常量之一（理论上它可以是任意 UUID）。名称是选择的名字空间中的一个标识符。例如：vastbase=# SELECT uuid_generate_v3(uuid_ns_url(), 'http://www.postgresql.org');名称参数将使用 MD5 进行哈希，因此从产生的 UUID 中得不到明文。采用这种方法的 UUID 生成没有随机性并且不涉及依赖于环境的元素，因此是可以重现的。 |
| uuid_generate_v4()                          | 这个函数产生一个版本 4 的 UUID，它完全从随机数产生。         |
| uuid_generate_v5(namespace uuid, name text) | 这个函数产生一个版本 5 的 UUID，它和版本 3 的 UUID 相似，但是采用的是 SHA-1 作为哈希方法。注：版本 5 比版本 3 更好，因为 SHA-1 比 MD5 更安全。 |

- 返回 uuid常量的函数：

| 函数           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| uuid_nil()     | 一个“nil” UUID 常量，它不作为一个真正的 UUID 发生。          |
| uuid_ns_dns()  | 为 UUID 指定 DNS 名字空间的常量。                            |
| uuid_ns_url()  | 为 UUID 指定 URL 名字空间的常量。                            |
| uuid_ns_oid()  | 为 UUID 指定 ISO 对象标识符（OID） 名字空间的常量（这属于 ASN.1 OID，它与PostgreSQL使用的 OID 无关）。 |
| uuid_ns_x500() | 为 UUID 指定 X.500 可识别名（DN）名字空间的常量。Constant designating the X.500 distinguished name (DN) namespace for UUIDs。 |



**注意事项**

- Vastbase G100 V2.2版本兼容uuid-ossp插件目前仅兼容ossp，对bsd和e2fs不做硬性要求。

- Vastbase G100 V2.2已经内置了uuid-ossp扩展，您只需要创建扩展即可使用。

**示例**

示例一：

1、创建uuid-ossp扩展。

```
create extension "uuid-ossp";
```

2、使用产生uuid的函数。

- 测试uuid_generate_v1()。

```
select  uuid_generate_v1();
```

结果显示如下：

```
                 uuid_generate_v1
--------------------------------------
  bdf064b8-baef-11ec-8838-000c2948c478
  (1 row)
```

- 测试uuid_generate_v1mc()。

```
select  uuid_generate_v1mc();
```

 结果显示如下：

```
              uuid_generate_v1mc
--------------------------------------
  ce8693b0-baef-11ec-8839-83581df53531
(1 row)
```

- 测试uuid_generate_v3(namespace uuid, name text)。

```
SELECT  uuid_generate_v3(uuid_ns_url(),'http://www.postgresql.org');
```

结果显示如下：

```
                 uuid_generate_v3
--------------------------------------
  cf16fe52-3365-3a1f-8572-288d8d2aaa46
(1 row)
```

- 测试uuid_generate_v4()。

```
select  uuid_generate_v4();
```

 结果显示如下：

```
                uuid_generate_v4
--------------------------------------
  3cad2542-a2a5-43ed-9df4-0dacb2f1d52f
(1 row)
```

- 测试uuid_generate_v5(namespace uuid, name text)。

```
SELECT  uuid_generate_v5(uuid_ns_url(),'http://www.postgresql.org');
```

结果显示如下：   

```
              uuid_generate_v5
--------------------------------------
  e1ee1ad4-cd4e-5889-962a-4f605a68d94e
(1 row)
```

示例二：返回uuid常量的函数

- 测试uuid_nil()函数。

```
select  uuid_nil();
```

结果显示如下：

```
                       uuid_nil
--------------------------------------
  00000000-0000-0000-0000-000000000000
(1 row)
```

- 测试uuid_ns_dns()函数。

```
select  uuid_ns_dns();
```

结果显示如下：

```
                    uuid_ns_dns
--------------------------------------
  6ba7b810-9dad-11d1-80b4-00c04fd430c8
(1 row)
```

- 测试uuid_ns_url()函数。

```
select  uuid_ns_url();
```

结果显示如下：

```
                    uuid_ns_url
--------------------------------------
  6ba7b811-9dad-11d1-80b4-00c04fd430c8
(1 row)
```

- 测试uuid_ns_oid()函数。

```
select  uuid_ns_oid();
```

结果显示如下：

```
                    uuid_ns_oid
--------------------------------------
  6ba7b812-9dad-11d1-80b4-00c04fd430c8
(1 row)
```

- 测试uuid_ns_x500()函数。

```
select  uuid_ns_x500();
```

 结果显示如下：

```
                   uuid_ns_x500
--------------------------------------
  6ba7b814-9dad-11d1-80b4-00c04fd430c8
(1 row)
```

#### PostGIS插件

**功能描述**

PostGIS是在对象关系型数据库PostgreSQL上增加了存储管理空间数据的能力的开源GIS数据库，它在PostgreSQL的基础上增加了表达地理信息的空间数据类型和操作这些类型的函数。

Vastbase G100 V2.2版本可使用PostGIS的如下模块：

- 支持矢量分析的postgis模块。

- 支持计算几何的sfcgal模块。

- 支持栅格分析的raster模块。

- 支持拓扑分析的topology模块。

**注意事项**

- Vastbase G100 V2.2版本暂不支持的模块包括Address Standardizer和Tiger Geocoder。

- Vastbase创建函数不支持添加WINDOW关键字，所以不支持函数ST_ClusterDBSCAN和ST_ClusterKMeans。

- Vastbase不支持BRIN 索引，所以不支持geog_brin_inclusion_add_value和geom2d_brin_inclusion_add_value等相关函数。

- Vastbase不支持WITH ORDINALITY功能，所以topology.ValidateTopology提供的功能与PostGIS 3.2版本不一致。

- 不支持PostGIS 3.2版本中的ST_AsGeoJson函数。

**示例**

1、获取<a href='http://download.osgeo.org/postgis/source/'>postgis</a>插件

2、解压得到postgis文件夹，将其中的内容复制到GAUSSHOME中（GAUSSHOME为数据库的安装路径）

```
cp -r postgis/* $GAUSSHOME
```

3、yum安装相关依赖（如果不能使用yum可下载对应版本的安装包进行安装）

```
yum install -y gmp gmp-devel            （版本6.0.0）
yum install -y mpfr mpfr-devel            （版本3.1.1）
yum install -y boost boost-devel         （版本1.53.0）
```

3.启动数据库并设置guc参数behavior_compat_options（PGDATA为数据库的实例路径）

```
vb_ctl start
vb_guc reload -D $PGDATA -c " behavior_compat_options = 'bind_procedure_searchpath, display_leading_zero' "
```

4.重启并连接数据库（可能需要指定路径和端口）

```
vb_ctl restart
vsql vastbase -r
```

5、创建插件。

```
create  extension  postgis;
create  extension  postgis_sfcgal;
create  extension  postgis_raster;
create  extension  postgis_topology;
```

6、查询测试。

```
SELECT Box3D(ST_GeomFromEWKT('LINESTRING(1 2 3, 3 4 5, 5 6 5)'));
```

结果返回如下：

```
Box3d
---------
BOX3D(1 2 3,5 6 5)
```

7、删除插件

```
drop  extension  postgis  cascade;
```



### 事务特性

#### 自治事务

**功能描述**

自治事务为在主事务执行过程中，以独立的事务上下文执行指定的某一类SQL语句，在定义函数/存储过程中，在函数/存储过程的声明部分增加指令：PRAGMA AUTONOMOUS_TRANSACTION，来控制对当前的存储过程中的内部事务，能够独立提交，其commit和rollback不受主事务commit和rollback的影响。该执行方式与普通方式执行函数/存储过程的结果相同。

典型使用场景是，用一个表记录主事务执行过程中的操作信息，并且在主事务失败回退的时候，表中记录的操作信息不予回退。

**功能特性**

- 支持输入参数
- 支持嵌套调用
- 支持在触发器中使用自治事务
- 支持匿名块使用自治事务

**注意事项**

- 不支持集合作为返回值
- 不支持组合类型作为返回类型
- 不支持out参数

**示例**

- 创建测试表。

```
create table at_tb2(id int, val varchar(64));
```

- 支持声明为自治事务的存储过程。

1、创建存储过程

```
create or replace procedure at_test3(i int)
AS
DECLARE
 PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
 insert into at_tb2 values(1, 'before s1');
 insert into at_tb2 values(2, 'after s1');
 if i > 10 then
 rollback;
 else
 commit;
 end if;
end;
/
```

如果数据库未开启默认自动提交，则需要手动提交。

```
commit;  
```

2、调用存储过程。

```
call at_test3(6);
```

3、查询结果。

```
select * from at_tb2;
```

 当结果显示如下信息，则说明写入成功。

```
id |   val
----+-----------
 1 | before s1
 2 | after s1
(2 rows)
```



- 支持plpgsql块内的sql语句使用函数/存储过程参数和定义的变量

1、创建存储过程。

```
create or replace procedure at_proc(i int)
as
declare
strval varchar;
pragma autonomous_transaction;
begin
strval:= 'begin:insert by autonomous transaction procedure<at_proc>';
insert into at_tb2 values(i,strval);
commit;
end;
/
```

如果数据库未开启默认自动提交，则需要手动提交。

```
 commit; 
```

2、调用存储过程。

```
call at_proc(1);
```

3、查询结果。

```
select * from at_tb2;
```

当结果显示如下信息，则说明验证成功。

```
id |   val
----+-----------
 1 | before s1
 2 | after s1
 3 | begin:insert by autonomous transaction procedure<at_proc>
(3 rows)
```



- 支持在触发器函数内声明自治事务


1、创建源表及触发表。

```
create table test_trigger_src_tbl(id1 int, id2 int, id3 int);
create table test_trigger_des_tbl(id1 int, id2 int, id3 int);
```

2、创建触发器函数。

```
create or replace function tri_insert_func() returns trigger as
$$
declare
pragma autonomous_transaction;
begin
insert into test_trigger_des_tbl values(new.id1, new.id2, new.id3);
return new;
end
$$ language plpgsql;
```

3、创建insert触发器。

```
create trigger insert_trigger
before insert on test_trigger_src_tbl
for each row
execute procedure tri_insert_func();
```

4、执行insert触发事件。

```
insert into test_trigger_src_tbl values(100,200,300);
```

5、检查触发结果。

```
select * from test_trigger_src_tbl;
```

结果显示如下：

```
 id1 | id2 | id3 
-----+-----+-----
 100 | 200 | 300
(1 row)
```

6、查看触发操作是否生效。

```
select * from test_trigger_des_tbl; 
```

结果显示如下：

```
 id1 | id2 | id3 
-----+-----+-----
 100 | 200 | 300
(1 row)
```

- 支持在匿名块内声明自治事务


1、清空测试表数据。

```
truncate at_tb2;
```

2、匿名块声明自治事务。

```
declare
pragma autonomous_transaction;
strval varchar;
begin strval:='insert by autonomous transaction by anonymous block';
insert into at_tb2 values(1,strval);
commit;
end;
/
```

3、查询结果。

```
select * from at_tb2;
```

结果显示如下：

```
id |               val
1 | insert by autonomous transaction by anonymous block
(1 row)
```



- 支持自治事务嵌套使用

1、创建嵌套自治事务的存储过程。

```
create or replace procedure at_proc_inner(i int)
as
declare
pragma autonomous_transaction;
begin
insert into at_tb2 values(1,'insert by autonomous transaction procedure<at_proc_inner>');
if i>5 then
rollback;
else
commit;
end if;
end;
/
```

```
create or replace procedure at_proc_outer(i int)
as
declare
pragma autonomous_transaction;
begin
insert into at_tb2 values(1,'insert by autonomous transaction procedure<at_proc_outer>');
at_proc_inner(i);
if i>10 then rollback;
else
commit;
end if;
end;
/
```

2、调用存储过程。

- (1)

```
truncate at_tb2;
call at_proc_outer(11);
```

验证结果：

```
select * from at_tb2;
```

结果显示如下：

```
----+-----
(0 rows)
```

- (2)

```
truncate at_tb2;
call at_proc_outer(8);
```

验证结果：

```
select * from at_tb2;
```

结果返回如下：

```
 id |                            val                            
----+-----------------------------------------------------------
  1 | insert by autonomous transaction procedure<at_proc_outer>
```

- (3)

```
truncate at_tb2;
call at_proc_outer(2);
```

验证结果：

```
select * from at_tb2;
```

结果返回如下：

```
 id |                            val                            
----+-----------------------------------------------------------
  1 | insert by autonomous transaction procedure<at_proc_outer>
  1 | insert by autonomous transaction procedure<at_proc_inner>
(2 rows)
```



####  事务控制

**启动事务**

Vastbase通过START TRANSACTION和BEGIN语法启动事务，请参考SQL语法 START TRANSACTION和SQL语法章节 “ BEGIN”。

**设置事务**

Vastbase通过SET TRANSACTION或者SET LOCAL TRANSACTION语法设置事务，请参考SQL语法 章节“SET TRANSACTION”。

**提交事务**

Vastbase通过COMMIT或者END可完成提交事务的功能，即提交事务的所有操作，请参考SQL语法 章节“COMMIT | END”。

**回滚事务**

回滚是在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销。请参考SQL语法 ROLLBACK。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 数据库中收到的一次执行请求（不在事务块中），如果含有多条语句，将会被打包成一个事务，如果其中有一个语句失败，那么整个请求都将会被回滚。
>
> 支持在存储过程中使用COMMIT和ROLLBACK。
>
> 未执行事务控制语句进行事务控制时，事务默认自动提交，不支持修改AUTOCOMMIT参数。

### 导出数据

#### 带有安全属性的用户数据输出

**功能描述**

确保用户数据（表）输出到数据库之外时，数据库安全功能应执行DAC和MAC（如启用），且输出关联的行级敏感标记即隐藏的系统列ogmac_label（如果存在）。

**语法格式**

```
COPY { table_name [ ( column_name [, ...] ) ]  }
TO { 'filename' | PROGRAM 'command' | STDOUT }
[ [ WITH ] ( option [, ...] ) ]
```

**参数说明**

option：敏感标签MAC_LABEL。

**注意事项**

- MAC_LABEL选项仅支持copy table (column, ...) to ... 形式。

- copy (select * from ) to ... 不支持with (MAC_LABEL) 选项。
- copy to ... 不支持 FIXED FORMATTER ... with (MAC_LABEL)。

**示例**

1、创建用户user1

```
create user user_select password 'Bigdata@123';
create user user_insert password 'Bigdata@123';
create table t1(a int,b varchar2(20));
```

2、创建敏感标记

```
create security label label1 'L6:G1';
create security label u_insert 'L3:G1';
create security label u_select 'L5:G1';
SECURITY LABEL ON TABLE t1 IS 'label1';
SECURITY LABEL ON ROLE user_select IS 'u_select';
SECURITY LABEL ON ROLE user_insert IS 'u_insert';
grant all on table t1 to user_select;
grant all on table t1 to user_insert;
```

3、切换到user_insert

```
SET SESSION AUTHORIZATION user_insert PASSWORD 'Bigdata@123';
insert into t1 values(1,'a');
insert into t1 values(2,'b');
```



#### 并行导出

**功能描述**

Vastbase提供了并行导出功能，以快速高效的完成大量数据导出。

**语法格式**

```
vb_dump -h hostname -p port -U username -W password dbname -f path+filename [-j jobs];
```

**参数说明**

-j：导出并发数（选填）。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 其他参数说明可根据需求参考“导出数据库”，“导出模式”，“导出表”等章节内容

**注意事项**

执行此命令的用户需赋予导出文件目录的读写权限。

**示例**

1、创建测试库baktest并创建测试数据

```
CREATE DATABASE baktest;
\c baktest
CREATE TABLE test(id int);
INSERT INTO test(id) values(1);
INSERT INTO test(id) values(2);
INSERT INTO test(id) values(3);
```

2、退出数据库在操作系统命令行使用vb_dump导出数据

```
vb_dump -F d baktest -f test.tar -j4
```

当结果显示如下信息，则表示数据库导出完成

<div align="left"><img src="image/备份导出.png" style="zoom:50%")</div>

### 导入数据

#### 并行导入

**功能描述**

Vastbase提供了并行导入功能，以快速、高效地完成大量数据导入。

**语法格式**

```
vb_restore -p port -U username -W password -d dbname -e -c -s [-j jobs];
```

**参数说明**

-j：导出并发数（选填）。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 其他参数说明可参考“使用vb_restore命令导入数据”

**注意事项**

- 执行此命令的用户需被赋予导出文件目录的读写权限。

- 数据库相关参数如下表所示：

  | 参数                     | 说明                                                         | 取值范围                                                     | 默认值 |
  | :----------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----- |
  | raise_errors_if_no_files | 导入时是否区分“导入文件记录数为空”和“导入文件不存在”。raise_errors_if_no_files=TRUE，则“导入文件不存在”的时候，Vastbase将抛出“文件不存在的”错误。该参数属于SUSET类型参数。 | 布尔型<br /> on表示导入时区分“导入文件记录数为空”和“导入文件不存在”。<br />off表示导入时不区分“导入文件记录数为空”和“导入文件不存在”。 | off    |
  | partition_mem_batch      | 为了优化对列存分区表的批量插入，在批量插入过程中会对数据进行缓存后再批量写盘。通过partition_mem_batch可指定缓存个数。该值设置过大，将消耗较多系统内存资源；设置过小，将降低系统列存分区表批量插入性能。该参数属于USERSET类型参数。 | 1~ 65535                                                     | 256    |
  | partition_max_cache_size | 为了优化对列存分区表的批量插入，在批量插入过程中会对数据进行缓存后再批量写盘。通过partition_max_cache_size可指定数据缓存区大小。该值设置过大，将消耗较多系统内存资源；设置过小，将降低列存分区表批量插入性能。该参数属于USERSET类型参数。 | 列存分区表：4096~ INT_MAX / 2，最小单位为KB。                | 2GB    |
  | enable_delta_store       | 为了增强列存单条数据导入的性能和解决磁盘冗余问题，可通过此参数选择是否开启支持列存delta表功能。该参数开启时，数据导入列存表，会根据表定义时指定的DELTAROW_THRESHOLD决定数据进入delta表存储还是主表CU存储，当数据量小于DELTAROW_THRESHOLD时，数据进入delta表。该参数影响的操作包括insert，copy，vacuum，vacuum full，vacuum deltamerge重分布等所有涉及列存表数据移动的操作。该参数属于POSTMASTER类型参数。 | on表示开启列存delta表功能。<br />off表示不开启列存delta表功能。 | off    |

**示例**

1、参考“并行导出”示例获取测试备份文件。

2、进入数据库创建恢复目标库restore。

```
CREATE DATABASE restore;
```

3、退出数据库在操作系统命令行执行vb_restore进行恢复。

```
vb_restore test.tar -p5432 -d restore -j4
```

4、进入数据库切换至restore库。

```
\c restore
```

5、查看恢复数据。

```
SELECT * FROM test;
```

当结果显示如下信息，则表示数据库导入完成。

```
 id 
---------
  1
  2
  3
(3 rows)
```

#### pg_bulkload导入

**功能描述**

可以使用pg_bulkload命令进行数据导入操作，提供高速数据加载能力。

**语法格式**

```
pg_bulkload [ OPTIONS ] [ controlfile ]
```

**参数说明**

pg_pulkload参数详情可参考<a href="https://ossc-db.github.io/pg_bulkload/pg_bulkload.html">pg_bulkload</a>

**注意事项**

- 执行此命令的用户需被赋予导出文件目录的读写权限。
- -i 参数支持通配符，暂时不支持使用正则表达式。

- 支持客户端使用加载工具，非数据库端。
- 支持导入错误的数据放到一个文件。
- 源数据文件需要支持可以使用纯文本格式的文件，字符集支持gbk、utf-8。
- 跳过数据库shared buffer ，快速写文件到数据库。
- 支持并发导入功能。
- 支持导入前设置是否对目标表truncate的参数。
- 在鲲鹏64核256GB服务器、存储选用SSD或NVME类型，网络无瓶颈的配置下，使用接口调用bulkload或工具远程使用bulkload功能可达到100M/s导入速度。
- 支持使用控制文件，可以把要使用的参数放入控制文件中。
- 支持指定单/双字节分隔符，例如特殊分隔符'∈'、'<|>'、'$|$'、'|'、'∈∈'。
- 支持为每个日期、时间字段指定格式。
- 选择源文件支持通配符导入多个文件至一个目标表。
- 支持跳过错误数据继续入库，达到阈值提交已入库数据。错误数据输出到文件，并生成导入报告，报告中显示导入成功与失败的记录数。
- 支持向一级分区表导入数据。

**性能指标**

Vastbase G100 V2.2版本对pg_bulkload功能相关性能做了大幅提升。

以鲲鹏64核256GB服务器，4*600G，RAID 5服务器配置为例，在网络无瓶颈的配置下，不同场景中可以达到相应的性能指标如下表：

| 场景                              | 性能指标                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| 无索引表入库                      | 使用装载工具bulkload和Java API方式，在不论多文件同时导入还是单个文件导入的情况下，向无任何索引的单表(包括分区表)，入库速度达到100M/s以上。 |
| 有索引入库                        | 有索引下入库性能 > 5W(万行)/s，支持分区表且索引为全局索引的情况下也要保持这个入库速度。 |
| 创建索引性能提升                  | 针对已经创建好，并且已有入库数据的表，创建索引的速度能处理数据的速度达到30MB/s，这个速度是指索引体积的大小/创建索引的消耗时间。例如索引体积大小为300M，10秒内可以完成索引创建，即可满足要求。 |
| 全表扫描                          | 执行全表扫描时，顺序读、物理读的IO性能 > 400MB/s，允许使用并行技术。 |
| bulkload入库数据的I/O有写放大现象 | bulkload和Java API做大量数据导入时，真正在操作系统上产生的写入IO的量与导入的数据表的体积大小的比例，不能超过1.5倍，期望能控制在1.3倍以内。操作系统中IO写入总量可以用iostat等方法获取写入的总数量的估值。 |
| 入库完成后读表                    | 在bulkload导入了大量数据之后，已得到提示“导入成功”的前提下，做目标表的查询操作，数据库进程在操作系统层面给不能有大量写IO的表现。 |

**示例**

1、创建测试表。

```
drop table if exists blk_test;
create table blk_test(id int,col text);
```

2、创建导入文件。

```
vi bulkload.txt
1,张三
2,李四
```

3、导入数据。

```
pg_bulkload -i bulkload.txt -O blk_test -l output.log -o "TYPE=CSV" -o "DELIMITER=," -o "ENCODING=UTF8" -d vastbase
```

4、验证结果。

```
SELECT * FROM blk_test
```

当结果显示如下信息，则表示数据库导入完成。

```
id | col
----+------
1 | 张三
2 | 李四
(2 rows)
```

#### Bulkload出错清理

**功能描述**

vb_bulkload就是批量加载工具，可以加载表数据，批量加载可以提升加载的效率和性能。

在使用vb_bulkload工具导入出错之后，本次导入的数据都要进行回滚，所以需要将本次导入数据清理，防止这些数据被访问，造成查询、执行计划不准确等问题。

**语法格式**

```
vb_bulkload -r options
```

options支持列表如下：

| **Options选项**                  | **说明**                                        |
| -------------------------------- | ----------------------------------------------- |
| -o "DIRS=val"--option="DIRS=val" | val可指定含.loadstatus为后缀的文件目录。        |
| -d dbname--dbname dbname         | 要连接的数据库的名称。                          |
| -h host--host host               | 正在运行服务器的计算机的主机名。                |
| -p port--port port               | 服务器侦听连接的TCP端口。                       |
| -U username--username username   | 连接的用户名。                                  |
| -W--password                     | 强制vb_bulkload在连接到数据库之前提示输入密码。 |
| -e--echo                         | 显示发送到服务端的命令。                        |
| --help                           | 显示帮助信息。                                  |
| --version                        | 显示版本信息。                                  |

**注意事项**

- 使用此功能需安装pg_bulkload插件。

- 实现vb_bulkload导入时，将在导入报错时清理本次导入数据，需要指定-o “ERROR_RECOVERY=YES”,该参数默认值为NO。

- vb_bulkload不支持ustore表格式。

**示例：**

1、在操作系统执行定义脚本文件bk1oadx4_one：

```
wanghp@localhost hztestj$ more bkloadx4_one 
path='/data3/wanghp/loaddata'
logfile='/home/wanghp/bkload_log.log'
bk_load(){

pg_bulkload -o "INFILE=$path/g2021-${1}*" -O $3 -l $logfile -o "SET_COMMITTED=YES" -O "WRITER=VASTLOADER" -O "NREADERS=$2" -O "TYPE=CSV" -O "DELIMITER=," -O "FILTER=DATETIME_FORMAT(1.YYYYMMDDHH24MISS)" -p5417 -d $4 -u wanghp 

}

date

bk 1oad $1 $2 $3 $4
```

2、执行一次错误的语法：

```
sh bkloadx4_one 01-01 16 bkld_t2 vastbase > x.log 
```

3、此时由于01-01没有用引号包裹起来，会引起sh报错：

```
NOTICE: Last successful login info login time:2022-03-25 01:52:43 application name:gs_clean Ip address:::1 method:Trust
Failed o times since last successful login
NOTICE: BULK LOAD START
ERROR:query failed: ERROR: invalid input syntax for type numeric:"01-01"
```

4、随后再进行一次正确的导入操作：

```
sh bkloadx4_one '01-01'  16 bkld_t2 vastbase > x.log 
```



### 外部数据封装器

#### JDBC_FDW

**功能描述**
支持基于JDBC驱动的FDW，可以通过不同数据源的JDBC驱动在外部表访问数据。
**前置条件**
1、安装JDK1.8，并配置好JAVA_HOME环境变量。
2、数据库环境变量LD_LIBRARY_PATH动态库路径加入JAVA_HOME配置。
通过如下命令配置环境变量：

```
x86：export LD_LIBRARY_PATH=$GAUSSHOME/jre/lib/amd64/server/:$LD_LIBRARY_PATH
ARM：export LD_LIBRARY_PATH=$GAUSSHOME/jre/lib/aarch64/server/:$LD_LIBRARY_PATH
```

3、修改数据库配置参数：在shared_preload_libraries参数配置中加上jdbc_fdw，然后重启数据库。

4、驱动包ojdbc7.jar放置到$GAUSSHOME/lib/postgresql/下并执行如下命令授权

```
chmod 777 $GAUSSHOME/lib/postgresql/ojdbc7.jar
```

**示例**
1、加载jdbc_fdww扩展。

```
create extension jdbc_fdw;
```

2、在创建测试表。

```
create table emp_fdw(empno int,ename varchar(30));
insert into emp_fdw values(1,'foo');
insert into emp_fdw values(2,'bar');
```

3、创建连接。

```
create server ora_jdbc foreign data wrapper jdbc_fdw options(
drivername 'oracle.jdbc.driver.OracleDriver',
url 'jdbc:oracle:thin:@//172.16.103.104:1521/orcl',
querytimeout '100',
jarfile '/home/vastbase/bin/ojdbc7.jar',
maxheapsize '200'
);
```

4、新建用户并授权。

```
create user use_ora_jdbc password 'Bigdata@123';
grant usage on foreign server ora_jdbc to use_ora_jdbc;
```

5、创建到oracle的映射。

```
create user mapping for use_ora_jdbc server ora_jdbc options(username 'system',password 'root');
```

6、创建需要访问的oracle中对应表的结构。

```
create foreign table emp_fdw_ora(empno int,ename varchar(30))
server ora_jdbc options(table_name 'EMP_FDW');
```

7、将权限赋予emp_fdw_ora。

```
grant all on emp_fdw_ora to use_ora_jdbc;
```

8、查看外部表。

```
\c - use_ora_jdbc
select * from emp_fdw_ora;
```

当结果显示如下信息，则表示外部表访问成功。

```
id | info
----+-----------
1 | bar
2 | foo
(2 row)
```

#### PostgreSQL_FDW

**功能描述**

postgres_fdw功能提供了外部数据封装器postgres_fdw插件，它可以被用来访问存储在外部Vastbase服务器中的数据。

**语法格式**

1、加载postgres_fdw扩展

```
CREATE EXTENSION [ IF NOT EXISTS ] extension_name
  [ WITH ] [ SCHEMA schema_name ]
       [ VERSION version ]
       [ FROM old_version ]
```

2、创建一个新的外部服务器

```
CREATE SERVER server_name
FOREIGN DATA WRAPPER fdw_name
  	OPTIONS ( { option_name ' value ' } [, ...] ) ;
```

3、创建一个用户到一个外部服务器的新映射

```
CREATE USER MAPPING FOR { user_name | USER | CURRENT_USER | PUBLIC }
  SERVER server_name
[ OPTIONS ( option 'value' [ , ... ] ) ]
```

4、创建外表

```
CREATE FOREIGN TABLE [ IF NOT EXISTS ] table_name ( [
column_name type_name [ OPTIONS ( option 'value' [, ... ] ) ] [ COLLATE collation ] [ column_constraint [ ... ] ]
 [, ... ]
] )
 SERVER server_name
[ OPTIONS ( option 'value' [, ... ] ) ]
```

这里column_constraint 可以是:

```
[ CONSTRAINT constraint_name ]
{ NOT NULL |
NULL |
DEFAULT default_expr }
```

**参数说明**

- server_name：server的名称。取值范围：长度必须小于等于63。

- fdw_name：指定外部数据封装器的名称。取值范围：oracle_fdw，mysql_fdw，postgres_fdw，mot_fdw。

- CREATE SERVER中OPTIONS参数包括：

  - host（必选）：要连接的主机名，本功能填写远端服务器的IP地址。


  - port（必选）：主机服务器的端口号，本功能填写远端服务器上集群的端口号。


  - dbname（必选）：数据库名，本功能填写远端服务器上的数据库名。


  - hostaddr(非必选)：与之链接的主机的IP地址，是标准的IPv4地址格式，比如，172.28.40.9。如果机器支持IPv6，那么也可以使用IPv6的地址。如果声明了一个非空的字符串，那么使用TCP/IP通讯机制。


  - connect_timeout(非必选)：链接的最大等待时间，以秒计（用十进制整数字符串书写），0或者不声明表示无穷。不建议把链接超时的值设置得小于2秒。


  - options(非必选)：添加命令行选项以在运行时发送到服务器。


  - keepalives(非必选)：控制客户端侧的TCP保持激活是否使用。缺省值是1，意思为打开，但是如果不想要保持激活，你可以更改为0，意思为关闭。通过Unix域套接字做的链接忽略这个参数。


  - keepalives_idle(非必选)：在TCP应该发送一个保持激活的信息给服务器之后，控制不活动的秒数。0值表示使用系统缺省。通过Unix域套接字做的链接或者如果禁用了保持激活则忽略这个参数。


  - keepalives_interval(非必选)：在TCP保持激活信息没有被应该传播的服务器承认之后，控制秒数。0值表示使用系统缺省。通过Unix域套接字做的链接或者如果禁用了保持激活则忽略这个参数。


  - keepalives_count(非必选)：添加命令行选项以在运行时发送到服务器。例如，设置为-c comm_debug_mode=off设置guc参数comm_debug_mode参数的会话的值为off。


  - use_remote_estimate(非必选)：控制postgres_fdw是否发出EXPLAIN命令以获取运行消耗估算。默认值为false。


  - fdw_startup_cost(非必选)：执行一个外表扫描时的启动耗时估算。这个值通常包含建立连接、远端对请求的分析和生成计划的耗时。默认值为100。


  - fdw_typle_cost(非必选)：在远端服务器上对每一个元组进行扫描时的额外消耗。这个值通常表示数据在server间传输的额外消耗。默认值为0.01。


- user_name：要映射到外部服务器的一个现有用户的名称。 CURRENT_USER和USER匹配当前用户的名称。 当PUBLIC被指定时，一个所谓的公共映射会被创建，当没有特定用户的映射可用时将会使用它。

- server_name：将为其创建用户映射的现有服务器的名称。

- CREATE USER MAPPING中OPTIONS参数包括：

  - user(必选)：远端服务器上Vastbase的用户名，属于普通用户。


  - password（必选）：远端服务器上Vastbase用户对应的密码


- table_name：外表的表名。取值范围：字符串，要符合标识符的命名规范。

- column_name：外表中的字段名。取值范围：字符串，要符合标识符的命名规范。

- type_name：字段的数据类型。

- SERVER server_name：外表的server名称。

- OPTIONS 参数包括：

  - schema_name（必选）：远端server的schema名称。如果不指定的话，将使用外表自身的schema名称作为远端的schema名称。


  - table_name（必选）：远端server的表名。如果不指定的话，将使用外表自身的表名作为远端的表名。


  - column_name（非必选）：远端server的表的列名。如果不指定的话，将使用外表自身的列名作为远端的的表的列名。


**注意事项**

- 两个postgres_fdw外表间的SELECT JOIN不支持下推到远端Vastbase执行，会被分成两条SQL语句传递到远端Vastbase执行，然后在本地汇总处理结果。
- 不支持IMPORT FOREIGN SCHEMA语法。
- 不支持对外表进行CREATE TRIGGER操作。

**示例**

1、在本地服务器创建用户。

```
create user hzy with sysadmin password '123456Aa';
grant all on database postgres to hzy;
```

2、远端服务器修改配置文件pg_hba.conf的配置参数，新增下列参数。

```
host  all   all       0.0.0.0/0         sha256
```

3、远端服务器修改配置文件postgres.conf中的listen_address 参数，值为本地服务器的IP地址。

4、远端服务器中创建用户。

```
create user hzy with sysadmin password '123456Aa';
grant all on database postgres to hzy;
```

5、远端服务器使用hzy用户创建测试表。

```
create table student( student_no int4 primary key, student_name varchar(30), age int2 ); 
insert into student values(1,'xiaoming',12); 
```

6、在本地服务器中，使用新建的用户登录系统。

7、加载postgres_fdw扩展。

```
create extension postgres_fdw ;
```

8、创建外部服务器。

```
create server server_to_200 foreign data wrapper postgres_fdw options (host '172.16.103.82',port '64322',dbname 'postgres');
```

9、创建一个用户到外部服务器的映射。

```
create user MAPPING FOR hzy SERVER server_to_200 OPTIONS (user 'hzy',password '123456Aa');
```

10、创建外表。

```
create foreign table local_foreign_table_student( student_no int4 , student_name varchar(30), age int2) server server_to_200 options(schema_name 'public', table_name 'student');
```

11、访问外表。

```
select * from local_foreign_table_student;
insert into local_foreign_table_student values (2,'xiaohong',11);
update local_foreign_table_student set student_name = 'xiaoqing' where student_no = 1;
delete from local_foreign_table_student where age = 11;
explain select * from local_foreign_table_student ;
```

12、查看外表结构。

```
\d+ local_foreign_table_student;
```



#### MySQL_FDW

**功能描述**

支持创建外部数据封装器mysql_fdw，连接MySQL数据库，并能在外部表上进行查询、插入、更新和删除操作。

**编译MySQL_FDW**

1、编译mysql_fdw需要安装MariaDB的开发库和头文件，推荐使用MariaDB的<a href='http://downloads.mariadb.org/mariadb/repositories'>官方源</a>进行安装。

2、配置好源后，使用yum install MariaDB-devel MariaDB-shared安装相关开发库。另外MariaDB-client是MariaDB的客户端工具，也可以根据需要安装，用于连接MariaDB进行测试。

3、安装好开发包后，就可以开始编译mysql_fdw了。编译时需要在执行configure时，加入–enable-mysql-fdw选项。后续按照正常的Vastbase安装方式安装即可。（Vastbase的安装参考章节“字符安装”）

4、编译完成后，编译产物为mysql_fdw.so，位于安装目录的lib/postgresql/ 下。mysql_fdw相关的sql文件和control文件，位于安装目录的share/postgresql/extension/下。

5、如果编译安装时，没有加入–enable-mysql-fdw选项，可以在Vastbase安装完成后，再次编译mysql_fdw，然后手动将编译产物mysql_fdw.so放到对应的安装目录lib/postgresql/，将mysql_fdw–1.0–1.1.sql、mysql_fdw–1.1.sql、mysql_fdw–1.0.sql、mysql_fdw.control放到对应的安装目录share/postgresql/extension/ ，然后重启数据库即可。

**使用MySQL_FDW**

- 使用mysql_fdw需要连接MariaDB或者MySQL Server，MariaDB或MySQL Server请自行安装。
- 加载mysql_fdw扩展。

```
CREATE EXTENSION mysql_fdw;
```

- 创建服务器对象。

```
CREATE SERVER
```

- 创建用户映射。

```
CREATE USER MAPPING
```

- 创建外表：外表的表结构需要与MySQL/MariaDB侧的表结构保持一致。注意MySQL/MariaDB侧的表的第一个字段必须具有唯一性约束（如PRIMARY KEY、UNIQUE等）。

```
CREATE FOREIGN TABLE
```

- 对外表做正常的操作，如INSERT、UPDATE、DELETE、SELECT、EXPLAIN、ANALYZE、COPY等。
- 删除外表。

```
DROP FOREIGN TABLE
```

- 删除用户映射。

```
DROP USER MAPPING
```

- 删除服务器对象：

```
DROP SERVER
```

- 删除扩展。

```
DROP EXTENSION mysql_fdw
```

**注意事项**

- 两个mysql外表间的SELECT JOIN不支持下推到MariaDB/MySQL Server执行，会被分成两条SQL语句传递到MariaDB/MySQL Server执行，然后在Vastbase处汇总处理结果。
- 不支持IMPORT FOREIGN SCHEMA语法。
- 不支持对外表进行CREATE TRIGGER操作。

**示例**

1、创建扩展。

```
create extension mysql_fdw;
```

2、创建FDW Server用于识别外部数据源。

```
create server mysql_fdw_server foreign data wrapper mysql_fdw options(HOST '172.16.103.108',PORT '20001');
```

3、新建用户并授权。

```
create user use_mysql password 'Bigdata@123';
grant usage on foreign server mysql_fdw_server to use_mysql;
```

4、创建USER MAPPING用于映射MySQL数据库用户。

```
create user mapping for use_mysql server mysql_fdw_server options(username 'root',password 'root');
```

5、在MySQL创建表。

```
create table test.emp_fdw(empno int,ename varchar(30));
insert into emp_fdw values(1,'foo');
insert into emp_fdw values(2,'bar');
```

6、在vastbase创建外部表，切换到用户use_mysql。

```
create foreign table emp_fdw_mysql(empno int,ename varchar(30)) server mysql_fdw_server options(DBNAME 'test',table_name 'emp_fdw');
\c - use_mysql
```

7、查询外部表数据。

```
select * from emp_fdw_mysql;
```

#### Oracle_FDW

**功能描述**

支持创建外部数据封装器oracle_fdw，连接Oracle数据库，并能在外部表上进行查询、插入、更新和删除操作。

**编译Oracle_FDW**

编译oracle_fdw需要安装Oracle的开发库和头文件。

1、选择合适的运行环境和版本，下载Basic Package和SDK Package并安装。另外SQLPlus Package是Oracle的客户端工具，也可以根据需要安装，用于连接Oracle Server进行测试。

2、安装好开发包后，就可以开始编译oracle_fdw了。编译时需要在执行configure时，加入 –enable-oracle-fdw选项。后续按照正常的Vstbase安装方式安装即可。（Vastbase的编译参考章节"字符安装"）

3、编译完成后，编译产物为oracle_fdw.so，位于安装目录的 lib/postgresql/下。oracle_fdw相关的sql文件和control文件，位于安装目录的 share/postgresql/extension/下。

4、如果编译安装时，没有加入 –enable-oracle-fdw选项，可以在Vastbase安装完成后，再次编译oracle_fdw，然后手动将编译产物 oracle_fdw.so放到对应的安装目录 lib/postgresql/ ，将 oracle_fdw–1.0–1.1.sql、oracle_fdw–1.1.sql、oracle_fdw.control放到对应的安装目录 share/postgresql/extension/即可。

**使用Oracle_FDW**

- 使用oracle_fdw需要连接Oracle，Oracle server请自行安装。
- 加载oracle_fdw扩展：

```
CREATE EXTENSION oracle_fdw
```

- 创建服务器对象：

```
CREATE SERVER
```

- 创建用户映射：

```
CREATE USER MAPPING
```

- 创建外表： 外表的表结构需要与Oracle数据库中的表结构保持一致。注意Oracle server侧的表的第一个字段必须具有唯一性约束（如PRIMARY KEY、UNIQUE等）。

```
CREATE FOREIGN TABLE
```

- 对外表做正常的操作，如INSERT、UPDATE、DELETE、SELECT、EXPLAIN、ANALYZE、COPY等。
- 删除外表：

```
DROP FOREIGN TABLE
```

- 删除用户映射：

```
DROP USER MAPPING
```

- 删除服务器对象：

```
DROP SERVER
```

- 删除扩展：

```
DROP EXTENSION oracle_fdw
```

**注意事项**

- 两个Oracle外表间的SELECT JOIN不支持下推到Oracle server执行，会被分成两条SQL语句传递到Oracle执行，然后在Vastbase处汇总处理结果。
- 不支持IMPORT FOREIGN SCHEMA语法。
- 不支持对外表进行CREATE TRIGGER操作。

**示例**

1、创建扩展。

```
create extension oracle_fdw;
```

2、创建FDW Server用于识别外部数据源。

```
create server ora_fdw_server foreign data wrapper oracle_fdw
options(dbserver '172.16.103.104:1521/orcl');
```

3、新建用户并授权。

```
create user use_ora password 'Bigdata@123';
grant usage on foreign server ora_fdw_server to use_ora;
```

4、创建USER MAPPING用于映射Oracle数据库用户。

```
create user mapping for use_ora server ora_fdw_server options(user 'system',password 'root');
```

5、在oracle创建表。

```
create table system.emp_fdw(empno int,ename varchar(30));
insert into emp_fdw values(1,'foo');
insert into emp_fdw values(2,'bar');
```

6、在vastbase创建外部表，切换到用户use_ora。

```
create foreign table emp_fdw_ora(empno int,ename varchar(30))
server ora_fdw_server
options(schema 'SYSTEM',table 'EMP_FDW');
\c - use_ora
```

7、插入外部表数据

```
insert into emp_fdw_ora values(3,'bar3');
```

8、查询外部表数据

```
select * from emp_fdw_ora;
```



#### DBLINK

**功能描述**

当用户需要跨越本地数据库，访问远程数据库的数据时，可以通过DBLINK像访问本地数据库一样访问远程数据库表中的数据。

**语法格式**

- 打开一个到远程数据库的持久连接。

```
SELECT dblink_connect(dblink_name,connstr);
```

- 关闭一个到远程数据库的持久连接。

```
SELECT dblink_disconnect();
```

- 在远程数据库执行查询。

```
SELECT * FROM dblink(dblink_name, sql_statement);
```

- 在远程数据库执行命令。

```
SELECT dblink_exec(dblink_name, sql_statement);
```

- 返回所有打开的命名dblink连接的名称。

```
SELECT dblink_get_connections();
```

- 发送一个异步查询到远程数据库。

```
SELECT dblink_send_query(dblink_name, sql_statement);
```

- 检查连接是否正在忙于一个异步查询。

```
SELECT dblink_is_busy(dblink_name);
```

- 创建private dblink或public dblink。

```
CREATE [public] DATABASE LINK ${dblink_name} CONNECT TO ${username} IDENTIFIED BY '${password}' USING ${fdw_name} (
url 'jdbc:oracle:thin:@//${ip}:${port}/${dbname}',
jarfile '${driver_path}'
);
```

- 远程Oracle函数和存储过程。

```
${schema_name}.${function_name | procedure_name}@${dblink_name}[(parameter,[...])]
```

**参数说明**

- dblink_name：连接名称，可自定义。
- connstr：连接信息，例如：hostaddr=172.16.103.92 port=6036 dbname=vastbase user=vastbase password='Bigdata@123'
- sql_statement：执行的语句。

- ${schema_name}：目标函数或存储过程所在的模式名（或者package名称）。可不指定，不指定时默认访问database link中Oracle用户对应的模式。

- ${function_name}：函数名称。

-	${procedure_name}：存储过程名称。

- parameter：函数或存储过程中的参数，只考虑传入参数，不考虑out输出参数。

**注意事项**

- 不同的用户可以创建同名的private dblink，且用户只能访问自己创建的DBLINK。

- 同一用户可以创建同名的private dblink和，在访问时，优先访问private dblink。
- 为支持不同用户创建同名dblink，需禁用GRANT FOREIGN SERVER，不再允许将server权限给予其他用户，以防一个用户能访问多个同名server，造成混乱。
- 不支持访问远程Oracle包变量和常量。（注：数据也不支持）

- 不支持将远程函数和存储过程创建为同义词方式使用。

- 创建private dblink或public dblink时，必须提前创建jdbc_fdw，并具备DBLINK相关权限。

**示例**

- 示例1：常用函数操作

1、创建扩展。

```
create extension dblink;
```

2、先执行dblink_connect保持连接。

```
SELECT dblink_connect('mycoon','hostaddr=172.16.103.92 port=6036 dbname=vastbase user=lst password=Bigdata@123');
```

3、执行BEGIN命令。

```
SELECT dblink_exec('mycoon', 'BEGIN');
```

4、执行数据操作。

```
SELECT dblink_exec('mycoon', 'create table people(id int,info varchar(10))');
SELECT dblink_exec('mycoon', 'insert into people values(1,''foo'')');
SELECT dblink_exec('mycoon', 'insert into people values(2,''foo'')');
SELECT dblink_exec('mycoon', 'update people set info=''bar'' where id=1');
```

5、执行事务提交。

```
SELECT dblink_exec('mycoon', 'COMMIT');
```

6、执行查询。

```
select * from dblink('mycoon','select * from people') as testTable (id int,info varchar(10));
```

7、解除连接。

```
SELECT dblink_disconnect('mycoon')
```

- private dblink和public dblink

1、修改postgresql.conf参数，将jdbc_fdw配置到shared_preload_libraries参数中。

```
shared_preload_libraries = 'jdbc_fdw'
```

2、创建插件。

```
create extension jdbc_fdw;
```

3、创建dblink。

（1）创建私有private dblink。

```
create  database  link  oradb1  connect  to  SYSTEM  identified  by  'root'  
using  jdbc_fdw(
url  'jdbc:oracle:thin:@//172.16.103.120:1521/utf8',
jarfile  '/home/vastbase2/ojdbc7.jar'
);
```

（2）创建公共public dblink。

```
vastbase=# create  public  database  link  oradb2  connect  to  SYSTEM  identified  by  'root'  
using  jdbc_fdw(
url  'jdbc:oracle:thin:@//172.16.103.104:1521/orcl',
jarfile  '/home/vastbase2/ojdbc7.jar'
);
```

4、dblink使用查询。

```
select  *  from  fdw_t1@oradb1;
select  *  from  fdw_t1@oradb2;
```

5、ALTER SERVER。

```
ALTER  SERVER  oradb1  VERSION  '8.4';
ALTER  PUBLIC  SERVER  oradb2  VERSION  '8.5';
```

6、删除DBLINK。

```
DROP  DATABASE  LINK  oradb1;
DROP  PUBLIC  DATABASE  LINK  oradb2;
```

- Oracle函数和存储过程

调用函数。

```
select * from test_func@test_dblink(100);
```

调用存储过程。

```
call test_proc@test_dblink(100);
```



### GUC参数说明

#### 预写式日志

**wal_level**

参数说明：设置写入WAL信息量的级别。

该参数属于POSTMASTER类型参数，请参考章节“重设参数”中对应设置方法进行设置。

>   <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> - 如果需要启用WAL日志归档和主备机的数据流复制，必须将此参数设置为archive或者hot_standby。
> - 如果此参数设置为minimal, archive_mode必须设置为off, hot_standby必须设置为off，max_wal_senders参数设置为0, 且需为单机环境, 否则将导致数据库无法启动。
> - 如果此参数设置为archive，hot_standby必须设置为off，否则将导致数据库无法启动。但是，hot_standby在双机环境中不能设置为off，具体参见hot_standby参数说明。

取值范围：枚举类型

- minimal

优点：一些重要操作（包括创建表、创建索引、簇操作和表的复制）都能安全的跳过，这样就可以使操作变得更快。

缺点：WAL仅提供从数据库服务器崩溃或者紧急关闭状态恢复时所需要的基本信息，无法用WAL归档日志恢复数据。

- archive

这个参数增加了WAL归档需要的日志信息，从而可以支持数据库的归档恢复。

- v hot_standby
  - 这个参数进一步增加了在备机上运行的SQL查询的信息，这个参数只能在数据库服务重新启动后生效。
  - 为了在备机上开启只读查询，wal_level必须在主机上设置成hot_standby ，并且备机必须打开hot_standby参数。hot_standby和archive级别之间的性能只有微小的差异，如果它们的设置对产品的性能影响有明显差异，欢迎反馈。

- logical

  这个参数表示WAL日志支持逻辑复制。

默认值：hot_standby



**fsync**

参数说明：设置Vastbase服务器是否使用fsync()系统函数（请参见wal_sync_method）确保数据的更新及时写入物理磁盘中。

该参数属于SIGHUP类型参数，请参考表“重设参数”中对应设置方法进行设置。

>   <div align="left"><img src="image/image2.png" style="zoom:20%")</div> 
>
> - 使用fsync()系统函数可以保证在操作系统或者硬件崩溃的情况下将数据恢复到一个已知的状态。
>
> - 如果将此参数关闭，可能会在系统崩溃时无法恢复原来的数据，导致数据库不可用。

取值范围：布尔型

- on表示使用fsync()系统函数。
- off表示不使用fsync()系统函数。

默认值：on



**synchronous_commit**

参数说明：设置当前事务的同步方式。开启后支持从库在主库commit后可直接读取已提交的数据。

该参数属于USERSET类型参数，请参考“重设参数”中对应设置方法进行设置。

通常情况下，一个事务产生的日志的同步顺序如下：

1. 主机将日志内容写入本地内存。
2. 主机将本地内存中的日志写入本地文件系统。
3. 主机将本地文件系统中的日志内容刷盘。
4. 主机将日志内容发送给备机。
5. 备机接受到日志内容，存入备机内存。
6. 备机将备机内存中的日志写入备机文件系统。
7. 备机将备机文件系统中的日志内容刷盘。
8. 备机回放日志，完成对数据文件的增量更新。

取值范围：枚举类型

- on：表示主机事务提交需要等待备机将对应日志刷新到磁盘。
- off：表示主机事务提交无需等待主机自身将对应日志刷新到磁盘，通常也称为异步提交。
- local：表示主机事务提交需要等待主机自身将对应日志刷新到磁盘，通常也称为本地提交。
- remote_write：表示主机事务提交需要等待备机将对应日志写到文件系统（无需刷新到磁盘）。
- remote_receive：表示主机事务提交需要等待备机接收到对应日志数据（无需写入文件系统）。
- remote_apply：表示主机事务提交需要等待备机完成对应日志的回放操作。
- true：同on。
- false：同off。
- yes：同on。
- no：同off。
- 1：同on。
- 0：同off。
- 2：同remote_apply。

默认值：on

**wal_sync_method**

参数说明：设置向磁盘强制更新WAL数据的方法。

该参数属于SIGHUP类型参数，请参考表11-1中对应设置方法进行设置。

   <div align="left"><img src="image/image2.png" style="zoom:20%")</div>  

如果将 fsync 关闭，这个参数的设置就没有意义，因为所有数据更新都不会强制写入磁盘。

取值范围：枚举类型

- open_datasync表示用带O_DSYNC选项的open()打开“WAL”文件。
- fdatasync表示每次提交的时候都调用fdatasync()。（支持suse10和suse11）。
- fsync_writethrough表示每次提交的时候调用fsync()强制把缓冲区任何数据写入磁盘。

>  <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 由于历史原因，我们允许在Windows平台上将wal_sync_method设置为fsync_writethrough，尽管它和fsync等效。
>

- fsync表示每次提交的时候调用fsync()。（支持suse10和suse11）
- open_sync表示用带O_SYNC选项的open()写“WAL”文件。（支持suse10和suse11）

默认值：fdatasync

**full_page_writes**

参数说明：设置Vastbase服务器在检查点之后对页面的第一次修改时，是否将每个磁盘页面的全部内容写到WAL日志中。当增量检查点开关和enable_double_write同时打开时，则不使用full_page_writes。

该参数属于SIGHUP类型参数，请参考“重设参数”中对应设置方法进行设置。

<div align="left"><img src="image/image2.png" style="zoom:20%")</div>  

- 设置这个参数是因为在操作系统崩溃过程中可能磁盘页面只写入了一部分内容，从而导致在同一个页面中包含新旧数据的混合。在崩溃后的恢复期间，由于在WAL日志中存储的行变化信息不够完整，因此无法完全恢复该页。把完整的页面影像保存下来就可以保证页面被正确还原，代价是增加了写入WAL日志的数据量。
- 关闭此参数，在系统崩溃的时候，可能无法恢复原来的数据。如果服务器硬件的特质（比如电池供电的磁盘控制器）可以减小部分页面的写入风险，或者文件系统特性支持（比如ReiserFS 4），并且清楚知道写入风险在一个可以接受的范畴，可以关闭这个参数。

取值范围：布尔型

- on表示启用此特性。
- off表示关闭此特性。

默认值：on

**wal_log_hints**

参数说明：设置在检查点之后对页面的第一次修改为页面上元组hint bits的修改时，是否将整个页面的全部内容写到WAL日志中。不推荐用户修改此设置。

该参数属于POSTMASTER类型参数，请参考“重设参数”中对应设置方法进行设置。

取值范围：布尔型

- on表示整个页面全部内容写到WAL日志中。
- off表示整个页面内容不会写到WAL日志中。

默认值：on



**wal_buffers**

参数说明：设置用于存放WAL数据的共享内存空间的XLOG_BLCKSZ数，XLOG_BLCKSZ的大小默认为8KB。

该参数属于POSTMASTER类型参数，请参考表11-1中对应设置方法进行设置。

取值范围：-1~218

- 如果设置为-1，表示wal_buffers的大小随着参数shared_buffers自动调整，为shared_buffers的1/32，最小值为8个XLOG_BLCKSZ，最大值为2048个XLOG_BLCKSZ。
- 如果设置为其他值，当小于4时，会被默认设置为4。

默认值：16MB

设置建议：每次事务提交时，WAL缓冲区的内容都写入到磁盘中，因此设置为很大的值不会带来明显的性能提升。如果将它设置成几百兆，就可以在有很多即时事务提交的服务器上提高写入磁盘的性能。根据经验来说，默认值可以满足大多数的情况。



**wal_writer_delay**

参数说明：WalWriter进程的写间隔时间。

该参数属于SIGHUP类型参数，请参考表11-1中对应设置方法进行设置。

 <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   

如果时间过长可能造成WAL缓冲区的内存不足，时间过短会引起WAL不断写入，增加磁盘I/O负担。

取值范围：整型， 1～10000（毫秒）

默认值：200ms



**commit_delay**

参数说明：表示一个已经提交的数据在WAL缓冲区中存放的时间。

该参数属于USERSET类型参数，请参考表11-1中对应设置方法进行设置。

  <div align="left"><img src="image/image2.png" style="zoom:20%")</div>    

- 设置为非 0 值时事务执行commit后不会立即写入WAL中，而仍存放在WAL缓冲区中，等待WalWriter进程周期性写入磁盘。
- 如果系统负载很高，在延迟时间内，其他事务可能已经准备好提交。但如果没有事务准备提交，这个延迟就是在浪费时间。

取值范围：整型， 0～100000（微秒），其中0表示无延迟。

默认值：0



**commit_siblings**

参数说明：当一个事务发出提交请求时，如果数据库中正在执行的事务数量大于此参数的值，则该事务将等待一段时间（commit_delay的值），否则该事务则直接写入WAL。

该参数属于USERSET类型参数，请参考表11-1中对应设置方法进行设置。

取值范围：整型， 0～1000

默认值：5



**wal_block_size**

参数说明：说明WAL日志段文件中日志页面的大小。

该参数属于INTERNAL类型参数，为固定参数，用户无法修改此参数，只能查看。

取值范围：整型，单位为Byte。

默认值：8192



**wal_segment_size**

参数说明：说明WAL日志段文件的大小。

该参数属于INTERNAL类型参数，为固定参数，用户无法修改此参数，只能查看。

取值范围：整型，单位为8KB。

默认值：16MB (2048 * 8KB)



**walwriter_cpu_bind**

参数说明：绑定到WAL写入线程的CPU核，与thread pool配合使用。

该参数属于POSTMASTER类型参数，请参考“重设参数”中对应设置方法进行设置。

取值范围：整型，-1~核数减1。

默认值：-1



**walwriter_sleep_threshold**

参数说明：xlogflusher进入sleep之前空闲xlog刷新的次数，达到阈值会休眠。

该参数属于SIGHUP类型参数，请参考“重设参数”中对应设置方法进行设置。

取值范围：整型，1~50000。

默认值：500



**wal_file_init_num**

参数说明：WAL编写器将创建的xlog段文件的数量。

该参数属于POSTMASTER类型参数，请参考“重设参数”中对应设置方法进行设置。

取值范围：整型，0~1000000。

默认值：10



**force_promote**

参考说明：备机强切功能开关。

备机强切在集群故障状态下，以丢失部分数据为代价换取集群尽可能快的恢复服务；是集群状态为不可用时的一个逃生方法，不建议频繁触发。如果操作者不清楚备机强切后丢失数据对业务的影响，请勿使用本功能。

取值范围：整型，0或1

0表示关闭，1表示开启

默认值：0



**wal_flush_timeout**

参数说明：遍历WalInsertStatusEntryTbl的超时时间。Xlog刷盘自适应控制的刷盘IO遍历WalInsertStatusEntryTbl等待的最大时间。

该参数属于SIGHUP类型参数，请参考“重设参数”中对应设置方法进行设置。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   
> 如果时间过长可能造成Xlog刷盘频率降低，降低Xlog处理性能。

取值范围：整型， 0 ~ 90000000（微秒）

默认值：2us



**wal_flush_delay**

参数说明：遍历WalInsertStatusEntryTbl时，遇到WAL_NOT_COPIED状态entry时等待的时间间隔。

该参数属于SIGHUP类型参数，请参考“重设参数”中对应设置方法进行设置。

取值范围：整型， 0 ~ 90000000（微秒）

默认值：1us

#### 设置保留字（关键字）可以作为字段名或别名

**功能描述**

为了兼容更多的主流数据库，Vastbase关键字较多。应用系统数据从其他数据库迁移到Vastbase时可能会遇到表名、字段名等是Vastbase的关键字，从而导致查询报错的情况。因此，可以选择屏蔽部分Vastbase的关键字，以达到关键字可以作为字段名或别名等兼容场景的目的。

**参数说明**

- vb_exclude_reserved_words可以设置多个关键字，用“,”隔开，设置后重启数据库生效。
- 参数级别为PG_POSTMASTER。

**注意事项**

某些关键字对于系统的正常运行非常重要，例如“select”。因此，这类关键字即使设置到系统参数vb_exclude_reserved_words中，也不会真正生效。下表列出了在vb_exclude_reserved_words参数中不会生效的关键字：

| -              | -                 | -        | -         | -        |
| -------------- | ----------------- | -------- | --------- | -------- |
| all            | column            | fetch    | null      | varchar2 |
| analyze        | connect           | float    | number    | when     |
| and            | constraint        | for      | numeric   | where    |
| any            | create            | from     | nvl       | with     |
| array          | csn               | grant    | offset    |          |
| as             | current_catalog   | group    | on        |          |
| asc            | current_date      | grouping | or        |          |
| between        | current_role      | having   | order     |          |
| bigint         | current_schema    | in       | primary   |          |
| binary         | current_time      | inner    | prior     |          |
| binary_double  | current_timestamp | int      | procedure |          |
| binary_integer | current_user      | integer  | rownuw    |          |
| bit            | date              | interval | select    |          |
| boolean        | decimal           | into     | table     |          |
| case           | default           | is       | then      |          |
| char           | desc              | like     | timestamp |          |
| character      | distinct          | limit    | union     |          |
| check          | else              | minus    | user      |          |
| collate        | end               | modify   | values    |          |
| collation      | exists            | not      | varchar   |          |

注：关键字被屏蔽后，相关关键字语法将同步失效。

**示例**

1、在操作系统命令行设置参数。

```
vi postgresql.conf
添加以下参数：vb_exclude_reserved_words='select,replace'
```

2、重启数据库生效。

```
vb_ctl restart
```

3、连接数据库。

4、查看屏蔽关键字。

```
show vb_exclude_reserved_words;
```

结果显示如下：

```
vb_exclude_reserved_words 
---------------------------
 select,replace
(1 row)
```

 replace可作为字段别名，select关键字依旧生效。

```
select 1 replace;
```

结果返回如下： 

```
replace 
---------
    1
(1 row)
```

#### 逻辑内存管理模块

**功能描述**

设置enable_memory_limit为true，即启用内存管理模块，可用于限制进程的内存使用。当其他参数配置不满足数据库启动条件时，则启动失败，并给出提示。

**操作方法**

- 设置enable_memory_limit为true：

```
[vastbase@localhost  vastbase]$  vi  postgresql.conf
enable_memory_limit  =  true
[vastbase@localhost  vastbase]$  vb_ctl  restart
```

- 设置enable_memory_limit为false：

```
[vastbase@localhost vastbase]$ vi postgresql.conf
enable_memory_limit = false
[vastbase@localhost vastbase]$ vb_ctl restart
```

**注意事项**

- 用户设置enable_memory_limit=true，但其他参数配置不满足条件，则数据库启动失败，并提示原因：

```
“the values of memory out of limit，the database failed to be started，please modify parameters value of 'max_process_memory、cstore_buffers、UDFWorkerMemHardLimit、shared_buffers、max_pred_locks_per_transaction、max_connections' “
```

- 如果用户设置enable_memory_limit=false, 启动成功并且提示风险：

```
“The parameter value of enable_memory_limit is false, there is a risk of database downtime due to memory depletion“
```

### 常见故障定位指南

#### 支持RAS：对于SIGBUS信号的处理

**术语定义**

SIGBUS信号：

- 硬件故障导致SIGBUS信号。

- Linux平台上运行malloc()，没有足够的RAM会给当前进程发送SIGBUS信号（实测未复现，不同系统可能会不一样）。

- 部分架构上访问数据时有对齐的要求，例如只能从4字节边界上读取一个4字节的数据类型，否则向当前进程发送SIGBUS信号。

- 试图访问一块无文件内容相应的内存区域，比如超过文件尾的内存区域，或者以前有文件内容对应，现在为另一进程截断过的内存区域，产生SIGBUS信号。

SIGBUS信号处理，可以再数据库接受到SIGBUS信号后进行一些处理并将结果记录到日志后再终止数据库运行。

SIGBUS信号记录操作，如果因SIGBUS停库则进行记录SIGBUS信号信息到文件，数据库工具可以查询是否存在SIGBUS错误，当SIGBUS错误修复后需手动清除SIGBUS信号记录文件。

**功能描述**

结合数据库的运行信息处理SIGBUS返回值，将处理结果记录到日志后再中止数据库运行。接收到SIGBUS信号后，SIGBUS信号中signal code值如下：

| si_code       | 原因                                                         |
| ------------- | ------------------------------------------------------------ |
| BUS_ADRALN    | 无效的地址对齐                                               |
| BUS_ADRERR    | 不存在的物理地址                                             |
| BUS_OBJERR    | 特定对象硬件错误                                             |
| BUS_MCEERR_AR | 硬件内存错误导致机器进行检查（hardware memory error consumed on a machine check: action required） |
| BUS_MCEERR_AO | 在进程中检测到硬件内存错误（hardware memory error detected in process but not consumed: action optional） |

**注意事项**

SIGBUS信号处理依赖GUC参数enable_incremental_checkpoint，请确保该参数处于开启状态（默认开启）。

#### 常见故障定位案例

##### 强制终止用户会话

**功能描述**

针对需要终止用户会话的场景，可以终止指定用户会话，释放Vastbase Server相应的资源而不影响实例正常运行，被终止的用户操作或事务会自动回滚。

**操作方法**

参考如下语句根据线程结束会话。

```
SELECT pg_terminate_backend(pid);
```

**示例**

1、从当前活动会话视图查找会话的线程ID。

```
SELECT datid, pid, state, query FROM pg_stat_activity; 
```

显示类似如下信息，其中pid的值即为该会话的线程ID。

```
datid |       pid       | state  | query 
-------+-----------------+--------+------ 
13205 | 139834762094352 | active | 
13205 | 139834759993104 | idle   | 
(2 rows) 
```

2、根据线程ID结束会话。

```
SELECT pg_terminate_backend(139834762094352);
```

当结果显示如下信息，则表示验证完成。

```
pg_terminate_backend 
---------------------
t
(1 row)
```

显示类似如下信息，表示用户正在尝试结束当前会话，此时仅会重连会话，而不是结束会话。

```
FATAL:  terminating connection due to administrator command 
FATAL:  terminating connection due to administrator command The connection to the server was lost. Attempting reset: Succeeded.
```



### 性能调优

#### 系统调优指南

##### 资源利用-空闲事务会话超时

**功能描述**

本功能支持设置空闲事务超时时间（以毫秒为单位），一旦用户会话闲置超过阈值，会话被断开，事务自动回滚。

**语法格式**

```
SET idle_in_transaction_session_timeout=n;
```

**参数说明**

n：空闲事务超时时间值，单位为毫秒。

**注意事项**

无。

**示例**

设置空闲事务超时时间阈值为1000毫秒。

```
set idle_in_transaction_session_timeout=1000;
```

##### 资源利用-降级容错

**功能描述**

当Vastbase数据库服务器CPU利用率过高，流程出现阻塞等情况时，可以设置Vastbase服务器进程调度优先级(即nice值，nice值越大优先级越低)。

**语法格式**

- 获取当前优先值

```
select get_nice();
```

- 设置进程优先值

```
select set_nice(n);
```

**参数说明**

n：nice值，代表需要设置的优先级。

**注意事项**

进程优先级非系统超级用户只能降不能升。

**示例**

1、使用超级管理员登陆数据库。

2、获取当前优先级。

```
select get_nice(); 
```

3、设置优先级比当前高。

```
select set_nice(10);
```



### Schema

#### WDR Snapshot Schema

##### WDR Snapshot 生成性能报告

**功能描述**

基于WDR Snapshot数据表汇总、统计，生成性能报告，默认初始化用户或监控管理员用户可以生成报告。

**操作步骤**

1、执行如下命令新建报告文件。

```
touch  /home/vastbase/wdrTestNode.html
```
2、连接数据库。

3、执行如下命令查询已经生成的快照，以获取快照的snapshot_id。

```
select * from snapshot.snapshot;
```

4、执行如下命令手动创建快照。数据库中只有一个快照或者需要查看在当前时间段数据库的监控数据，可以选择手动执行快照操作，该命令需要用户具有sysadmin权限。（可选）

```
select create_wdr_snapshot();
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
>  执行“cm_ctl query -Cdvi”，回显中“Central Coordinator State”下显示的信息即为CCN信息。

5、执行如下命令，在本地生成HTML格式的WDR报告。

（1）执行如下命令，设置报告格式。\a: 不显示表行列符号， \t: 不显示列名 ，\o: 指定输出文件。

```
\a      
\t 
\o /home/vastbase/wdrTestNode.html
```

（2）执行如下命令，生成HTML格式的WDR报告。

```
select generate_wdr_report(begin_snap_id Oid, end_snap_id Oid, int report_type, int report_scope, int node_name );
```

示例一：生成集群级别的报告：

```
select generate_wdr_report(1, 2, 'all', 'cluster',null);
```

示例二：生成某个节点的报告：

```
select generate_wdr_report(1, 2, 'all', 'node', pgxc_node_str()::cstring);
```

（3）执行如下命令关闭输出选项及格式化输出命令。

```
\o \a \t 
```

6、在/home/vastbase/下根据需要查看WDR报告。

generate_wdr_report函数参数说明如下表所示：

| 参数          | 说明                                                         | 取值范围                                                     |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| begin_snap_id | 查询时间段开始的snapshot的id（表snapshot.snapshot中的snapshot_id）。 | -                                                            |
| end_snap_id   | 查询时间段结束snapshot的id。默认end_snap_id大于begin_snap_id（表snapshot.snapshot中的snapshot_id）。 | -                                                            |
| report_type   | 指定生成report的类型。例如，summary/detail/all。             | summary：汇总数据。detail：明细数据。all：包含summary和detail。 |
| report_scope  | 指定生成report的范围，可以为cluster或者node。                | cluster：数据库级别的信息。node：节点级别的信息。            |
| node_name     | 在report_scope指定为node时，需要把该参数指定为对应节点的名称。（节点名称可以执行select * from pg_node_env;查询）。在report_scope为cluster时，该值可以省略或者指定为空或NULL。 | node：Vastbase中的节点名称。cluster：省略/空/NULL。          |

**注意事项**

需进入系统库查看快照信息。

WDR Snapshot启动（即参数enable_wdr_snapshot为on），且快照数量大于等于2。

**示例**

1、修改参数。

```
alter system set enable_wdr_snapshot=on;
```

2、创建报告文件。

```
touch  /home/vastbase/wdrTestNode.html
```

3、登录数据库后切换至系统库。

```
\c postgres
```

4、查询已经生成的快照。

```
select * from snapshot.snapshot;
```

结果显示如下：

```
snapshot_id |           start_ts            |            end_ts             
-------------+-------------------------------+-------------------------------
         432 | 2022-07-05 10:34:25.477173+08 | 2022-07-05 10:34:40.441504+08
         435 | 2022-07-05 13:20:23.230771+08 | 2022-07-05 13:20:38.65221+08
```

5、生成格式化性能报告wdrTestNode.html。

```
\a \t \o /home/om/wdrTestNode.html
```

6、查询node节点名称

```
select * from pg_node_env;
```

结果如下所示，node_name 即为节点名称。

```
 node_name |   host    | process | port |          installpath          |           datapath           | log_directory 
-----------+-----------+---------+------+-------------------------------+------------------------------+---------------
 node1     | localhost |  148191 | 5432 | /home/vastbase/local/vastbase | /home/vastbase/data/vastbase | pg_log
 (1 row)
```

7、向性能报告wdrTestNode.html中写入数据。

```
 select generate_wdr_report(432, 435, 'all', 'node', 'node1');
```

8、关闭性能报告wdrTestNode.html。

```
postgres=# \o
```

9、生成格式化性能报告wdrTestCluster.html。

```
postgres=# \o /home/om/wdrTestCluster.html
```

10、向格式化性能报告wdrTestCluster.html中写入数据。

```
select generate_wdr_report(432, 435, 'all', 'cluster');
```

11、关闭性能报告wdrTestCluster.html。

```
postgres=# \o \a \t
```



### 用户自定义函数

#### PL/pgSQL语言函数

PL/pgsql是一种可载入的过程语言。

用PL/pgsql创建的函数可以被用在任何可以使用内建函数的地方。例如，可以创建复杂条件的计算函数并且后面用它们来定义操作符或把它们用于索引表达式。

SQL被大多数数据库用作查询语言。它是可移植的并且容易学习。但是每一个SQL语句必须由数据库服务器单独执行。

这意味着客户端应用必须发送每一个查询到数据库服务器、等待它被处理、接收并处理结果、做一些计算，然后发送更多查询给服务器。如果客户端和数据库服务器不在同一台机器上，则会引起进程间通信并且将带来网络负担。

通过PL/pgsql，可以将一整块计算和一系列查询分组在数据库服务器内部，这样就有了一种过程语言的能力并且使SQL更易用，同时能节省客户端/服务器通信开销。

- 客户端和服务器之间的额外往返通信被消除。

- 客户端不需要的中间结果不必被整理或者在服务器和客户端之间传送。

- 多轮的查询解析可以被避免。

PL/pgsql可以使用SQL中所有的数据类型、操作符和函数。

应用PL/pgsql创建函数的语法为CREATE FUNCTION。PL/pgsql是一种可载入的过程语言。其应用方法与存储过程相似，只是存储过程无返回值，函数有返回值。

### 存储过程

#### 存储过程概述

商业规则和业务逻辑可以通过程序存储在Vastbase中，这个程序就是存储过程。

存储过程是SQL和PL/SQL的组合。存储过程使执行商业规则的代码可以从应用程序中移动到数据库。从而，代码存储一次能够被多个程序使用。

存储过程的创建及调用办法请参考“CREATE PROCEDURE”章节。

PL/pgsql节所提到的PL/pgsql语言创建的函数与存储过程的应用方法相通。下面各节中，除非特别声明，否则内容通用于存储过程和PL/pgsql语言函数。

#### 数据类型

数据类型是一组值的集合以及定义在这个值集上的一组操作。Vastbase数据库是由表的集合组成的，而各表中的列定义了该表，每一列都属于一种数据类型，Vastbase根据数据类型有相应函数对其内容进行操作，例如Vastbase可对数值型数据进行加、减、乘、除操作。

**数据类型转换**

数据库中允许有些数据类型进行隐式类型转换（赋值、函数调用的参数等），有些数据类型间不允许进行隐式数据类型转换，可尝试使用Vastbase提供的类型转换函数，例如CAST进行数据类型强转。

Vastbase数据库常见的隐式类型转换，请参见下表。

>  <div align="left"><img src="image/image2.png" style="zoom:20%")</div> 
>
> Vastbase支持的DATE的效限范围是：公元前4713年到公元294276年。

 隐式类型转换表

| 原始数据类型 | 目标数据类型 | 备注                         |
| ------------ | ------------ | ---------------------------- |
| CHAR         | VARCHAR2     | -                            |
| CHAR         | NUMBER       | 原数据必须由数字组成。       |
| CHAR         | DATE         | 原数据不能超出合法日期范围。 |
| CHAR         | RAW          | -                            |
| CHAR         | CLOB         | -                            |
| VARCHAR2     | CHAR         | -                            |
| VARCHAR2     | NUMBER       | 原数据必须由数字组成。       |
| VARCHAR2     | DATE         | 原数据不能超出合法日期范围。 |
| VARCHAR2     | CLOB         | -                            |
| NUMBER       | CHAR         | -                            |
| NUMBER       | VARCHAR2     | -                            |
| DATE         | CHAR         | -                            |
| DATE         | VARCHAR2     | -                            |
| RAW          | CHAR         | -                            |
| RAW          | VARCHAR2     | -                            |
| CLOB         | CHAR         | -                            |
| CLOB         | VARCHAR2     | -                            |
| CLOB         | NUMBER       | 原数据必须由数字组成。       |
| INT4         | CHAR         | -                            |

#### 数组和record

##### 数组

**数组类型的使用**

在使用数组之前，需要自定义一个数组类型。

在存储过程中紧跟AS关键字后面定义数组类型。定义方法为：

```
TYPE array_type IS VARRAY(size) OF data_type;
```

其中：

- array_type：要定义的数组类型名。

- VARRAY：表示要定义的数组类型。

- size：取值为正整数，表示可以容纳的成员的最大数量。

- data_type：要创建的数组中成员的类型。

>  <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> - 在Vastbase中，数组会自动增长，访问越界会返回一个NULL，不会报错。
>
> - 在存储过程中定义的数组类型，其作用域仅在该存储过程中。
>
> - 建议选择上述定义方法的一种来自定义数组类型，当同时使用两种方法定义同名的数组类型时，Vastbase会优先选择存储过程中定义的数组类型来声明数组变量。

Vastbase支持使用圆括号来访问数组元素，且还支持一些特有的函数，如extend，count，first，last来访问数组的内容。

<div align="left"><img src="image/image1.png" style="zoom:25%")</div>   

存储过程中如果有DML语句（SELECT、UPDATE、INSERT、DELETE），DML语句只能使用中括号来访问数组元素，使用小括号默认识别为数组访问，若数组不存在，则识别为函数表达式。

##### record

**record类型的变量**

创建一个record变量的方式：

定义一个record类型 ，然后使用该类型来声明一个变量。

**语法**

record类型的语法参见下图。

<div align="left"><img src="image/record类型语法.jpg" style="zoom:50%")</div>  

 

对以上语法格式的解释如下：

- record_type：声明的类型名称。

- field：record类型中的成员名称。

- datatype：record类型中成员的类型。

- expression：设置默认值的表达式。

<div align="left"><img src="image/image1.png" style="zoom:25%")</div>    

在Vastbase中：

- record类型变量的赋值支持：
  - 在函数或存储过程的声明阶段，声明一个record类型，并且可以在该类型中定义成员变量。
  - 一个record变量到另一个record变量的赋值。
  - SELECT INTO和FETCH向一个record类型的变量中赋值。
  - 将一个NULL值赋值给一个record变量。

- 不支持INSERT和UPDATE语句使用record变量进行插入数据和更新数据。

- 如果成员有复合类型，在声明阶段不支持指定默认值，该行为同声明阶段的变量一样。

**示例**

1、创建测试表。

```
CREATE TABLE emp_rec(empno numeric(4,0),ename character varying(10), job character varying(9), mgr numeric(4,0),hiredate timestamp(0) without time zone,sal numeric(7,2),comm numeric(7,2),deptno numeric(2,0));
```

2、查看表定义。

```
\d emp_rec 
```

结果返回如下

```
        Table "public.emp_rec" 
 Column  |        Type        | Modifiers  
----------+--------------------------------+----------- 
 empno   | numeric(4,0)          | not null 
 ename   | character varying(10)      |  
 job    | character varying(9)      |  
 mgr    | numeric(4,0)          |  
 hiredate | timestamp(0) without time zone |  
 sal    | numeric(7,2)          |  
 comm   | numeric(7,2)          |  
 deptno  | numeric(2,0)          |  
```

3、演示在存储过程中对数组进行操作。 

```
CREATE OR REPLACE FUNCTION regress_record(p_w VARCHAR2) 
RETURNS 
VARCHAR2  AS $$ 
DECLARE 

type rec_type is record (name  varchar2(100), epno int); -- 声明一个record类型. 
employer rec_type; 

type rec_type1 is record (name  emp_rec.ename%type, epno int not null :=10); --使用%type声明record类型 
employer1 rec_type1; 

  type rec_type2 is record ( 				--声明带有默认值的record类型 
     name varchar2 not null := 'SCOTT',  
     epno int not null :=10); 
  employer2 rec_type2; 
  CURSOR C1 IS  select ename,empno from emp_rec order by 1 limit 1; 

BEGIN 

   employer.name := 'WARD'; 					 --对一个record类型的变量的成员赋值。 
   employer.epno = 18; 
   raise info 'employer name: % , epno:%', employer.name, employer.epno; 
   
   employer1 := employer; 						 --将一个record类型的变量赋值给另一个变量。 
   raise info 'employer1 name: % , epno: %',employer1.name, employer1.epno; 

   employer1 := NULL; 							  --将一个record类型变量赋值为NULL。 
   raise info 'employer1 name: % , epno: %',employer1.name, employer1.epno; 

   raise info 'employer2 name: % ,epno: %', employer2.name, employer2.epno; 	--获取record变量的默认值。

   for employer in select ename,empno from emp_rec order by 1  limit 1  		 --在for循环中使用record变量 
     loop  
       raise info 'employer name: % , epno: %', employer.name, employer.epno; 
     end loop;       

   select ename,empno  into employer2 from emp_rec order by 1 limit 1; 	--在select into 中使用record变量。
   raise info 'employer name: % , epno: %', employer2.name, employer2.epno;       

   OPEN C1; 				--在cursor中使用record变量。 
   FETCH C1 INTO employer2; 
   raise info 'employer name: % , epno: %', employer2.name, employer2.epno; 
   CLOSE C1;     
   RETURN employer.name; 
END; 
$$ 
LANGUAGE plpgsql; 
```

4、调用该存储过程。 

```
CALL regress_record('abc'); 
```

结果显示如下：

```
INFO:  employer name: WARD , epno:18
INFO:  employer1 name: WARD , epno: 18
INFO:  employer1 name: <NULL> , epno: <NULL>
INFO:  employer2 name: SCOTT ,epno: 10
INFO:  employer name: <NULL> , epno: <NULL>
INFO:  employer name: <NULL> , epno: <NULL>

 regress_record 

(1 row)
```

5、删除存储过程。 

```
DROP PROCEDURE regress_record;
```

#### 声明语法

**结构**

PL/SQL块中可以包含子块，子块可以位于PL/SQL中任何部分。PL/SQL块的结构如下：

- 声明部分：声明PL/SQL用到的变量、类型、游标、局部的存储过程和函数。

```
DECLARE
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>     
>
> 不涉及变量声明时声明部分可以没有。
>
> - 对匿名块来说，没有变量声明部分时，可以省去DECLARE关键字。
>
> - 对存储过程来说，没有DECLARE， AS相当于DECLARE。即便没有变量声明的部分，关键字AS也必须保留。

- 执行部分：过程及SQL语句，程序的主要部分。必选。

```
BEGIN
```

- 执行异常部分：错误处理。可选。

```
EXCEPTION	
```

- 结束

```
END; 
/
```

 

<div align="left"><img src="image/image2.png" style="zoom:20%")</div>     

禁止在PL/SQL块中使用连续的Tab，连续的Tab可能会造成在使用vsql工具带“-r”参数执行PL/SQL块时出现异常。

**分类**

PL/SQL块可以分为以下几类：

- 匿名块：动态构造，只能执行一次。语法请参考[图1](#匿名块语法)。

- 子程序：存储在数据库中的存储过程、函数、操作符和高级包等。当在数据库上建立好后，可以在其他程序中调用它们。

**匿名块**	

匿名块（Anonymous Block）一般用于不频繁执行的脚本或不重复进行的活动。它们在一个会话中执行，并不被存储。

***\*语法\****

匿名块的语法参见图1。<a id="匿名块语法"></a>

图1. anonymous_block::=

<div align="left"><img src="image/匿名块语法.jpg" style="zoom:100%")</div>      

 

对以上语法图的解释如下：

- 匿名块程序实施部分，以BEGIN语句开始，以END语句停顿，以一个分号结束。输入“/”按回车执行它。

>  <div align="left"><img src="image/image2.png" style="zoom:20%")</div>     
>
> 最后的结束符“/”必须独占一行，不能直接跟在END后面。

- 声明部分包括变量定义、类型、游标定义等。

- 最简单的匿名块不执行任何命令。但一定要在任意实施块里至少有一个语句，甚至是一个NULL语句。

**子程序**

存储在数据库中的存储过程、函数、操作符和高级包等。当在数据库上建立好后，可以在其他程序中调用它们。

#### 基本语句

在编写PL/SQL过程中，会定义一些变量，给变量赋值，调用其他存储过程等。介绍PL/SQL中的基本语句，包括定义变量、赋值语句、调用语句以及返回语句。

>  <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 尽量不要在存储过程中调用包含密码的SQL语句，因为存储在数据库中的存储过程文本可能被其他有权限的用户看到导致密码信息被泄漏。如果存储过程中包含其他敏感信息也需要配置存储过程的访问权限，保证敏感信息不会泄漏。

##### 定义变量

介绍PL/SQL中变量的声明，以及该变量在代码中的作用域。

**变量声明**

变量声明语法请参见下图。

declare_variable::=

<div align="left"><img src="image/变量声明语法.jpg" style="zoom:50%")</div>     

 

对以上语法格式的解释如下：

- variable_name：变量名。

- type：变量类型。

- value：该变量的初始值（如果不给定初始值，则初始为NULL）。value也可以是表达式。



变量类型除了支持基本类型，还可以使用%TYPE和%ROWTYPE去声明一些与其他表字段或表结构本身相关的变量。

- %TYPE属性

%TYPE主要用于声明某个与其他变量类型（例如，表中某列的类型）相同的变量。假如我们想定义一个my_name变量，它的变量类型与employee的firstname类型相同，我们可以通过如下定义：

```
my_name employee.firstname%TYPE
```

这样定义可以带来两个好处，首先，我们不用预先知道employee 表的firstname类型具体是什么。其次，即使之后firstname类型有了变化，我们也不需要再次修改my_name的类型。

- %ROWTYPE属性

%ROWTYPE属性主要用于对一组数据的类型声明，用于存储表中的一行数据或从游标匹配的结果。假如，我们需要一组数据，该组数据的字段名称与字段类型都与employee表相同。我们可以通过如下定义：

```
my_employee employee%ROWTYPE
```

**变量作用域**

变量的作用域表示变量在代码块中的可访问性和可用性。只有在它的作用域内，变量才有效。

- 变量必须在declare部分声明，即必须建立BEGIN-END块。块结构也强制变量必须先声明后使用，即变量在过程内有不同作用域、不同的生存期。

- 同一变量可以在不同的作用域内定义多次，内层的定义会覆盖外层的定义。

- 在外部块定义的变量，可以在嵌套块中使用。但外部块不能访问嵌套块中的变量。

**示例**

```
DECLARE 
  emp_id  INTEGER := 7788;  --定义变量并赋值 
BEGIN 
  emp_id := 5*7784;  --变量赋值 
END; 
/
```

##### 赋值语句

**语法**

给变量赋值的语法请参见下图。

assignment_value::=

<div align="left"><img src="image/变量赋值语法.jpg" style="zoom:100%")</div>     

 

对以上语法格式的解释如下：

- variable_name：变量名。

- value：可以是值或表达式。值value的类型需要和变量variable_name的类型兼容才能正确赋值。

**示例**

```
DECLARE 
  emp_id  INTEGER := 7788;--赋值 
BEGIN 
  emp_id := 5;--赋值 
  emp_id := 5*7784; 
END; 
/
```

##### 调用语句

**语法**

调用一个语句的语法请参见下图。

call_clause::=

<div align="left"><img src="image/调用语句语法.jpg" style="zoom:50%")</div>    

 

对以上语法格式的解释如下：

- procedure_name：存储过程名。

- parameter：存储过程的参数，可以没有或者有多个参数。

**示例**

1、创建表并插入测试数据。

```
create table staffs(
section_id int,
salary int
);
insert into staffs values(1,1000);
insert into staffs values(2,1000);
insert into staffs values(3,1000);
insert into staffs values(4,1000);
insert into staffs values(5,1000);
insert into staffs values(6,1000);
insert into staffs values(7,1000);
insert into staffs values(8,1000);
```

2、创建存储过程proc_staffs 。

```
CREATE OR REPLACE PROCEDURE proc_staffs 
( 
section   NUMBER(6), 
salary_sum out NUMBER(8,2), 
staffs_count out INTEGER 
) 
IS 
BEGIN 
SELECT sum(salary), count(*) INTO salary_sum, staffs_count FROM staffs where section_id = section; 
END; 
/ 
```

3、调用存储过程proc_return。

```
CALL proc_staffs(2,8,6); 
```

结果显示如下：

```
 salary_sum | staffs_count 
------------+--------------
       1000 |            1
(1 row)
```

4、清除存储过程 。

```
DROP PROCEDURE proc_staffs; 
```

####  动态语句

##### 执行动态查询语句

**功能描述**

动态查询就是在程序运行的时候来进行查询。Vastbase提供两种方式：使用EXECUTE IMMEDIATE、OPEN FOR实现动态查询。前者通过动态执行SELECT语句，后者结合了游标的使用。当需要将查询的结果保存在一个数据集用于提取时，可使用OPEN FOR实现动态查询。

**EXECUTE IMMEDIATE**

语法图请参见下图。

EXECUTE IMMEDIATE dynamic_select_clause::=

<div align="left"><img src="image/动态查询语句语法.jpg" style="zoom:50%")</div>     

 

using_clause子句的语法图参见下图。

using_clause::=

<div align="left"><img src="image/using_clause子句语法图.jpg" style="zoom:50%")</div>    

 

对以上语法格式的解释如下：

- define_variable：用于指定存放单行查询结果的变量。

- USING IN bind_argument：用于指定存放传递给动态SQL值的变量，即在dynamic_select_string中存在占位符时使用。

- USING OUT bind_argument：用于指定存放动态SQL返回值的变量。

 

<div align="left"><img src="image/image2.png" style="zoom:20%")</div>     

- 查询语句中，into和out不能同时存在；

- 占位符命名以“:”开始，后面可跟数字、字符或字符串，与USING子句的bind_argument一一对应；

- bind_argument只能是值、变量或表达式，不能是表名、列名、数据类型等数据库对象，即不支持使用bind_argument为动态SQL语句传递模式对象。如果存储过程需要通过声明参数传递数据库对象来构造动态SQL语句（常见于执行DDL语句时），建议采用连接运算符“||”拼接dynamic_select_clause；

- 动态PL/SQL块允许出现重复的占位符，即相同占位符只能与USING子句的一个bind_argument按位置对应。

**OPEN FOR**

动态查询语句还可以使用OPEN FOR打开动态游标来执行。

语法参见下图。

open_for::=

<div align="left"><img src="image/OPENFOR语法.jpg" style="zoom:50%")</div>    

 

参数说明：

- cursor_name：要打开的游标名。

- dynamic_string：动态查询语句。

- USING value：在dynamic_string中存在占位符时使用。

游标的使用请参考章节”游标“。



##### 执行动态非查询语句

**功能描述**

动态非查询就是在程序运行的时候来进行非查询操作。

**语法格式**

语法格式请参见下图。

noselect::=

<div align="left"><img src="image/动态非查询语句语法.jpg" style="zoom:50%")</div>   

 

using_clause子句的语法参见图下图。

using_clause::=

<div align="left"><img src="image/using_clause子句非语法.jpg" style="zoom:50%")</div>  

**参数说明**

USING IN bind_argument：用于指定存放传递给动态SQL值的变量，在dynamic_noselect_string中存在占位符时使用，即动态SQL语句执行时，bind_argument将替换相对应的占位符。



> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>    
>
> bind_argument只能是值、变量或表达式，不能是表名、列名、数据类型等数据库对象。如果存储过程需要通过声明参数传递数据库对象来构造动态SQL语句（常见于执行DDL语句时），建议采用连接运算符“||”拼接dynamic_select_clause。另外，动态语句允许出现重复的占位符，相同占位符只能与唯一一个bind_argument按位置一一对应。

**示例**

1、创建测试表。 

```
CREATE TABLE sections_t1 
( 
  section    NUMBER(4) , 
  section_name  VARCHAR2(30), 
  manager_id   NUMBER(6), 
  place_id    NUMBER(4)  
); 
```

2、声明变量。 

```
DECLARE  
  section    NUMBER(4) := 280;  
  section_name  VARCHAR2(30) := 'Info support';  
  manager_id   NUMBER(6) := 103; 
  place_id    NUMBER(4) := 1400; 
  new_colname  VARCHAR2(10) := 'sec_name'; 
BEGIN  
```

3、执行查询 。

```
EXECUTE IMMEDIATE 'insert into sections_t1 values(:1, :2, :3, :4)'  
USING section, section_name, manager_id,place_id;  
```

4、执行查询（重复占位符） 。

```
EXECUTE IMMEDIATE 'insert into sections_t1 values(:1, :2, :3, :1)'  
USING section, section_name, manager_id;  
```

5、执行ALTER语句（建议采用“||”拼接数据库对象构造DDL语句） 。

```
EXECUTE IMMEDIATE 'alter table sections_t1 rename section_name to ' || new_colname; 
END;  
/ 
```

6、查询数据 。

```
SELECT * FROM sections_t1; 
```

7、删除表 。

```
DROP TABLE sections_t1;
```

##### 动态调用存储过程

**功能描述**

动态调用存储过程就是在程序运行的时候调用存储过程。使用EXECUTE IMMEDIATE…CALL语句执行。

**语法格式**

语法请参见下图。

call_procedure::=

 <div align="left"><img src="image/动态调用语法.jpg" style="zoom:50%")</div>  

using_clause子句的语法参见下图。

using_clause::=

 <div align="left"><img src="image/动态调用using_clause子句语法.jpg" style="zoom:50%")</div>   

 **参数说明**

- CALL procedure_name: 调用存储过程。

- [:placeholder1，:placeholder2，…] ：存储过程参数占位符列表。占位符个数与参数个数相同。

- USING  [IN|OUT|IN OUT] bind_argument: 用于指定存放传递给存储过程参数值的变量。bind_argument前的修饰符与对应参数的修饰符一致。

**注意事项**

动态调用存储过程必须使用匿名的语句块将存储过程或语句块包在里面，使用EXECUTE IMMEDIATE…USING语句后面带IN、OUT来输入、输出参数。

##### 动态调用匿名块

**功能描述**

动态调用匿名块是指在动态语句中执行匿名块，使用EXECUTE IMMEDIATE…USING语句后面带IN、OUT来输入、输出参数。

**语法格式**

语法请参见下图。

call_anonymous_block::=

<div align="left"><img src="image/动态匿名块语法.jpg" style="zoom:50%")</div>   

 

using_clause子句的语法参见下图。

using_clause::=

<div align="left"><img src="image/匿名块using_clause语法.jpg" style="zoom:50%")</div>    

 

对以上语法格式的解释如下：

- 匿名块程序实施部分，以BEGIN语句开始，以END语句停顿，以一个分号结束。

- USING  [IN|OUT|IN OUT] bind_argument，用于指定存放传递给存储过程参数值的变量。bind_argument前的修饰符与对应参数的修饰符一致。

- 匿名块中间的输入输出参数使用占位符来指明，要求占位符个数与参数个数相同，并且占位符所对应参数的顺序和USING中参数的顺序一致。

- 目前Vastbase在动态语句调用匿名块时，EXCEPTION语句中暂不支持使用占位符进行输入输出参数的传递。

#### 事务管理

**功能描述**

存储过程本身就处于一个事务中，开始调用最外围存储过程时会自动开启一个事务，在调用结束时自动提交或者发生异常时回滚。除了系统自动的事务控制外，也可以使用COMMIT/ROLLBACK来控制存储过程中的事务。在存储过程中调用COMMIT/ROLLBACK命令，将提交/回滚当前事务并自动开启一个新的事务，后续的所有操作都会在此新事务中运行。

保存点SAVEPOINT是事务中的一个特殊记号，它允许将那些在它建立后执行的命令全部回滚，把事务的状态恢复到保存点所在的时刻。存储过程中允许使用保存点来进行事务管理，当前支持保存点的创建、回滚和释放操作。存储过程中使用回滚保存点只是回退当前事务的修改，而不会改变存储过程的执行流程，也不会回退存储过程中的局部变量值等。

**语法格式**

- 定义保存点

```
SAVEPOINT savepoint_name;
```

- 回滚保存点

```
ROLLBACK TO [SAVEPOINT] savepoint_name;
```

- 释放保存点

```
RELEASE [SAVEPOINT] savepoint_name;
```

**使用场景**

支持调用的上下文环境：

- 支持在PLSQL的存储过程内使用COMMIT/ROLLBACK/SAVEPOINT。
- 支持含有EXCEPTION的存储过程使用COMMIT/ROLLBACK/SAVEPOINT。
- 支持在存储过程的EXCEPTION语句内使用COMMIT/ROLLBACK/SAVEPOINT。
- 支持在事务块里调用含有COMMIT/ROLLBACK/SAVEPOINT的存储过程，即通过/BEGIN/START/END等开启控制的外部事务。
- 支持在子事务中调用含有SAVEPOINT的存储过程，即存储过程中使用外部定义的SAVEPOINT，回退事务状态到存储过程外定义的SAVEPOINT位置。
- 支持存储过程外部对存储过程内定义的SAVEPOINT可见，即存储过程外可以将事务修改回滚到存储过程中定义SAVEPOINT的位置。
- 支持多数PLSQL的上下文和语句内调用COMMIT/ROLLBACK/SAVEPOINT，包括常用的IF/FOR/CURSOR LOOP/WHILE。
- 支持存储过程返回值与简单表达式计算中调用含有COMMIT/ROLLBACK/SAVEPOINT的存储过程或者函数。

支持提交/回滚的内容：

- 支持DDL在COMMIT/ROLLBACK后的提交/回滚。
- 支持DML的COMMIT/ROLLBACK后的提交。
- 支持存储过程内GUC参数的回滚提交。

**注意事项**

不支持调用的上下文环境：

- 不支持除PLSQL的其他存储过程中调用COMMIT/ROLLBACK/SAVEPOINT，例如PLJAVA、PLPYTHON等。
- 不支持函数中调用COMMIT/ROLLBACK/SAVEPOINT，包括函数调用含有COMMIT/ROLLBACK/SAVEPOINT的存储过程。
- 不支持事务块中调用了SAVEPOINT后，调用含有COMMIT/ROLLBACK的存储过程。
- 不支持TRIGGER中调用含有COMMIT/ROLLBACK/SAVEPOINT语句的存储过程。
- 不支持EXECUTE语句中调用COMMIT/ROLLBACK/SAVEPOINT语句。
- 不支持在CURSOR语句中打开一个含有COMMIT/ROLLBACK/SAVEPOINT的存储过程。
- 不支持带有IMMUTABLE以及SHIPPABLE的存储过程调用COMMIT/ROLLBACK/SAVEPOINT，或调用带有COMMIT/ROLLBACK/SAVEPOINT语句的存储过程。
- 不支持SQL中调用含有COMMIT/ROLLBACK/SAVEPOINT语句的存储过程，除了SELECT PROC以及CALL PROC。
- 存储过程头带有GUC参数设置的不允许调用COMMIT/ROLLBACK/SAVEPOINT语句。
- 不支持CURSOR/EXECUTE语句，以及各类表达式内调用COMMIT/ROLLBACK/SAVEPOINT。
- 自治事务和存储过程事务是两个独立的事务，不能互相使用对方事务中定义的保存点。

不支持提交回滚的内容：

- 不支持存储过程内声明变量以及传入变量的提交/回滚。
- 不支持存储过程内必须重启生效的GUC参数的提交/回滚。

**示例**

- 示例1：支持在PLSQL的存储过程内使用COMMIT/ROLLBACK。

```
CREATE TABLE EXAMPLE1(COL1 INT);
CREATE OR REPLACE PROCEDURE TRANSACTION_EXAMPLE()
AS
BEGIN
    FOR i IN 0..20 LOOP
        INSERT INTO EXAMPLE1(COL1) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
/
```

- 示例2：

  支持含有EXCEPTION的存储过程使用COMMIT/ROLLBACK。

  支持在存储过程的EXCEPTION语句内使用COMMIT/ROLLBACK。

  支持DDL在COMMIT/ROLLBACK后的提交/回滚。

```
CREATE OR REPLACE PROCEDURE TEST_COMMIT_INSERT_EXCEPTION_ROLLBACK()
AS
BEGIN
    DROP TABLE IF EXISTS TEST_COMMIT; 
    CREATE TABLE TEST_COMMIT(A INT, B INT);
    INSERT INTO TEST_COMMIT SELECT 1, 1;
    COMMIT;
        CREATE TABLE TEST_ROLLBACK(A INT, B INT);
    RAISE EXCEPTION 'RAISE EXCEPTION AFTER COMMIT';
  EXCEPTION
    WHEN OTHERS THEN
    INSERT INTO TEST_COMMIT SELECT 2, 2;
    ROLLBACK;
END;
/ 
```

- 示例3：支持在事务块里调用含有COMMIT/ROLLBACK的存储过程，即通过/BEGIN/START/END等开启控制的外部事务。

```
BEGIN;
    CALL TEST_COMMIT_INSERT_EXCEPTION_ROLLBACK();
END;
```

- 示例4：支持多数PLSQL的上下文和语句内调用COMMIT/ROLLBACK，包括常用的IF/FOR/CURSOR LOOP/WHILE。

```
CREATE OR REPLACE PROCEDURE TEST_COMMIT2()
IS
BEGIN
    DROP TABLE IF EXISTS TEST_COMMIT;
    CREATE TABLE TEST_COMMIT(A INT);
    FOR I IN REVERSE 3..0 LOOP
    INSERT INTO TEST_COMMIT SELECT I;
    COMMIT;
    END LOOP;
    FOR I IN REVERSE 2..4 LOOP
    UPDATE TEST_COMMIT SET A=I;
    COMMIT;
    END LOOP;
EXCEPTION
WHEN OTHERS THEN   
    INSERT INTO TEST_COMMIT SELECT 4;
    COMMIT;
END;
/
```

- 示例5：支持存储过程返回值与简单表达式计算。

```
CREATE OR REPLACE PROCEDURE exec_func3(RET_NUM OUT INT) 
AS 
BEGIN 
  RET_NUM := 1+1; 
COMMIT; 
END; 
/ 
CREATE OR REPLACE PROCEDURE exec_func4(ADD_NUM IN INT) 
AS 
SUM_NUM INT; 
BEGIN 
SUM_NUM := ADD_NUM + exec_func3(); 
COMMIT; 
END; 
/
```

- 示例6：支持存储过程内GUC参数的回滚提交。

1、查询参数值。

```
SHOW explain_perf_mode;
SHOW enable_force_vector_engine;
```

2、创建存储过程修改参数。

```
CREATE OR REPLACE PROCEDURE GUC_ROLLBACK()
AS
BEGIN
    SET enable_force_vector_engine = on;
    COMMIT;
    SET explain_perf_mode TO pretty;
    ROLLBACK;
END;
/
```

 3、调用存储过程并查询。   

```
call GUC_ROLLBACK();
SHOW explain_perf_mode;
SHOW enable_force_vector_engine;
```

结果显示如下：

```
 explain_perf_mode 
-------------------
 normal
(1 row)
```

```
enable_force_vector_engine 
----------------------------
 on
(1 row)
```

4、将参数改回。

```
SET enable_force_vector_engine = off;
```

- 示例7：函数（Function）中不允许调用commit/rollback语句

```
CREATE OR REPLACE FUNCTION FUNCTION_EXAMPLE1() RETURN INT
AS
EXP INT;
BEGIN
    FOR i IN 0..20 LOOP
        INSERT INTO EXAMPLE1(col1) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
    SELECT COUNT(*) FROM EXAMPLE1 INTO EXP;
    RETURN EXP;
END;
/
```

- 示例8：函数（Fucntion）中不允许调用带有commit/rollback语句的存储过程。

```
CREATE OR REPLACE FUNCTION FUNCTION_EXAMPLE2() RETURN INT
AS
EXP INT;
BEGIN
    --transaction_example为存储过程，带有commit/rollback语句
    CALL transaction_example();
    SELECT COUNT(*) FROM EXAMPLE1 INTO EXP;
    RETURN EXP;
END;
/
```

- 示例9：不允许Trigger的存储过程包含commit/rollback语句，或调用带有commit/rollback语句的存储过程。

```
CREATE OR REPLACE FUNCTION FUNCTION_TRI_EXAMPLE2() RETURN TRIGGER
AS
EXP INT;
BEGIN
    FOR i IN 0..20 LOOP
        INSERT INTO EXAMPLE1(col1) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
    SELECT COUNT(*) FROM EXAMPLE1 INTO EXP;
    
END;
/
    
CREATE TRIGGER TRIGGER_EXAMPLE AFTER DELETE ON EXAMPLE1 
FOR EACH ROW EXECUTE PROCEDURE FUNCTION_TRI_EXAMPLE2();
    
DELETE FROM EXAMPLE1;
```

- 示例10：不支持带有IMMUABLE以及SHIPPABLE的存储过程调用commit/rollback，或调用带有commit/rollback语句的存储过程。

```
CREATE OR REPLACE PROCEDURE TRANSACTION_EXAMPLE1()
IMMUTABLE
AS
BEGIN
    FOR i IN 0..20 LOOP
        INSERT INTO EXAMPLE1 (col1) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
/
```

- 示例11：不支持出现在SQL中的调用（除了Select Procedure）。

```
CREATE OR REPLACE PROCEDURE TRANSACTION_EXAMPLE3()
AS
BEGIN
    FOR i IN 0..20 LOOP
        INSERT INTO EXAMPLE1 (col1) VALUES (i);
        IF i % 2 = 0 THEN
            EXECUTE IMMEDIATE 'COMMIT';
        ELSE
            EXECUTE IMMEDIATE 'ROLLBACK';
        END IF;
    END LOOP;
END;
/
```

- 示例12：存储过程头带有GUC参数设置的不允许调用commit/rollback语句。

```
CREATE OR REPLACE PROCEDURE TRANSACTION_EXAMPLE4()
SET ARRAY_NULLS TO "ON"
AS
BEGIN
    FOR i IN 0..20 LOOP
        INSERT INTO EXAMPLE1 (col1) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
/
```

- 示例13：游标open的对象不允许为带有commit/rollback语句的存储过程。

```
CREATE OR REPLACE PROCEDURE TRANSACTION_EXAMPLE5(INTIN IN INT, INTOUT OUT INT)
AS
BEGIN
INTOUT := INTIN + 1;
COMMIT;
END;
/
    
CREATE OR REPLACE PROCEDURE TRANSACTION_EXAMPLE6()
AS
CURSOR CURSOR1(EXPIN INT)
IS SELECT TRANSACTION_EXAMPLE5(EXPIN);
INTEXP INT;
BEGIN
    FOR i IN 0..20 LOOP
        OPEN CURSOR1(i);
        FETCH CURSOR1 INTO INTEXP;
        INSERT INTO EXAMPLE1(COL1) VALUES (INTEXP);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
        CLOSE CURSOR1;
    END LOOP;
END; 
/
```

- 示例14：不支持CURSOR/EXECUTE语句，以及各类表达式内调用COMMIT/ROLLBACK。

```
CREATE OR REPLACE PROCEDURE exec_func1()
AS
BEGIN
    CREATE TABLE TEST_exec(A INT);
COMMIT;
END;
/
CREATE OR REPLACE PROCEDURE exec_func2()
AS
BEGIN
EXECUTE exec_func1();
COMMIT;
END;
/
```

- 示例15：存储过程使用保存点回退事务部分修改。

```
CREATE OR REPLACE PROCEDURE STP_SAVEPOINT_EXAMPLE1()
AS
BEGIN
    INSERT INTO EXAMPLE1 VALUES(1);
    SAVEPOINT s1;
    INSERT INTO EXAMPLE1 VALUES(2);
    ROLLBACK TO s1;  -- 回退插入记录2
    INSERT INTO EXAMPLE1 VALUES(3);
END;
/
```

- 示例16：存储过程中使用保存点回退到存储过程外部定义的保存点。

```
CREATE OR REPLACE PROCEDURE STP_SAVEPOINT_EXAMPLE2()
AS
BEGIN
    INSERT INTO EXAMPLE1 VALUES(2);
    ROLLBACK TO s1;  -- 回退插入记录2
    INSERT INTO EXAMPLE1 VALUES(3);
END;
/
    
BEGIN;
INSERT INTO EXAMPLE1 VALUES(1);
SAVEPOINT s1;
CALL STP_SAVEPOINT_EXAMPLE2();
SELECT * FROM EXAMPLE1;
COMMIT;
```

- 示例17：存储过程外部回退到存储过程中定义的保存点。

```
CREATE OR REPLACE PROCEDURE STP_SAVEPOINT_EXAMPLE3()
AS
BEGIN
    INSERT INTO EXAMPLE1 VALUES(1);
    SAVEPOINT s1;
    INSERT INTO EXAMPLE1 VALUES(2);
END;
/
    
BEGIN;
INSERT INTO EXAMPLE1 VALUES(3);
CALL STP_SAVEPOINT_EXAMPLE3();
ROLLBACK TO SAVEPOINT s1; --回退存储过程中插入记录2
SELECT * FROM EXAMPLE1;
COMMIT;
```

#### 控制语句

##### 返回语句

###### RETURN

**语法格式**

返回语句的语法格式请参见下图。

 return_clause::=

<div align="left"><img src="image/RETURN语法.png" style="zoom:50%")</div>    

 

对以上语法的解释如下：

用于将控制从存储过程或函数返回给调用者。

**示例**

请参见章节“调用语句”的示例

###### RETURN NEXT及RETURN QUERY

**语法格式**

创建函数时需要指定返回值SETOF datatype。

return_next_clause::=

<div align="left"><img src="image/return_next_clause.jpg" style="zoom:50%")</div>     

return_query_clause::=

<div align="left"><img src="image/return_query_clause.jpg" style="zoom:50%")</div>    

**参数说明**

- RETURN NEXT：可用于标量和复合数据类型。

- RETURN QUERY：有一种变体RETURN QUERY EXECUTE，后面还可以增加动态查询，通过USING向查询插入参数。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 当需要函数返回一个集合时，使用RETURN NEXT或者RETURN QUERY向结果集追加结果，然后继续执行函数的下一条语句。随着后续的RETURN NEXT或RETURN QUERY命令的执行，结果集中会有多个结果。函数执行完成后会一起返回所有结果。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE t1(a int); 
INSERT INTO t1 VALUES(1),(10); 
```

2、创建函数测试RETURN NEXT 。

```
CREATE OR REPLACE FUNCTION fun_for_return_next() RETURNS SETOF t1 AS $$ 
DECLARE 
  r t1%ROWTYPE; 
BEGIN 
  FOR r IN select * from t1 
  LOOP 
   RETURN NEXT r; 
  END LOOP; 
  RETURN; 
END; 
$$ LANGUAGE PLPgsql; 
```

3、调用函数

```
call fun_for_return_next(); 
```

结果显示如下：

```
 a 
--- 
 1 
 10 
(2 rows) 
```

 

4、创建函数测试RETURN QUERY 。

```
CREATE OR REPLACE FUNCTION fun_for_return_query() RETURNS SETOF t1 AS $$ 
DECLARE 
  r t1%ROWTYPE; 
BEGIN 
  RETURN QUERY select * from t1; 
END; 
$$ 
language plpgsql; 
```

调用函数

```
call fun_for_return_query(); 
```

结果显示如下：

```
 a 
--- 
 1 
 10 
(2 rows)
```

##### 条件语句

**功能描述**

条件语句的主要作用判断参数或者语句是否满足已给定的条件，根据判定结果执行相应的操作。

**语法格式**

Vastbase有五种形式的IF：

- IF_THEN

IF_THEN::=

<div align="left"><img src="image/IF_THEN.png" style="zoom:50%")</div>      

IF_THEN语句是IF的最简单形式。如果条件为真，statements将被执行。否则，将忽略它们的结果使该IF_THEN语句执行结束。

- IF_THEN_ELSE

IF_THEN_ELSE::=

<div align="left"><img src="image/IF_THEN_ELSE.png" style="zoom:50%")</div>    

 

IF_THEN_ELSE语句增加了ELSE的分支，可以声明在条件为假的时候执行的语句。

- IF_THEN_ELSE IF

IF语句可以嵌套，嵌套方式如下：

```
IF sex = 'm' THEN 
  pretty_sex := 'man'; 
ELSE 
  IF sex = 'f' THEN 
    pretty_sex := 'woman'; 
  END IF; 
END IF;
```

这种形式实际上就是在一个IF语句的ELSE部分嵌套了另一个IF语句。因此需要一个END IF语句给每个嵌套的IF，另外还需要一个END IF语句结束父IF-ELSE。如果有多个选项，可使用下面的形式。

- IF_THEN_ELSIF_ELSE

IF_THEN_ELSIF_ELSE::=

<div align="left"><img src="image/IF_THEN_ELSIF_ELSE.jpg" style="zoom:50%")</div>     

- IF_THEN_ELSEIF_ELSE

ELSEIF是ELSIF的别名。

**示例**

1、创建存储过程。

```
CREATE OR REPLACE PROCEDURE proc_control_structure(i in integer)  
AS 
  BEGIN 
    IF i > 0 THEN 
     raise info 'i:% is greater than 0. ',i;  
    ELSIF i < 0 THEN 
      raise info 'i:% is smaller than 0. ',i;  
    ELSE 
      raise info 'i:% is equal to 0. ',i;  
    END IF; 
    RETURN; 
  END; 
/ 
```

2、调用存储过程。

```
CALL proc_control_structure(3); 
```

结果显示如下：

```
INFO:  i:3 is greater than 0. 
-----------------------------
 proc_control_structure 

(1 row)
```

3、删除存储过程 

```
DROP PROCEDURE proc_control_structure;
```

##### 循环语句

- 简单LOOP语句

**语法图**

loop::=

<div align="left"><img src="image/loop.jpg" style="zoom:50%")</div>      

**示例**

创建存储过程 proc_loop并调用。

```
CREATE OR REPLACE PROCEDURE proc_loop(i in integer, count out integer)  
AS  
  BEGIN  
    count:=0;  
    LOOP  
    IF count > i THEN  
     raise info 'count is %. ', count;  
      EXIT;  
    ELSE  
      count:=count+1;  
    END IF;  
    END LOOP;  
    END; 
/ 
CALL proc_loop(10,5);
```

 当结果显示如下信息，则表示loop验证成功。

```
INFO:  count is 11. 
 count 
----------------------
    11
(1 row)
```

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   
>
> 该循环必须要结合EXIT使用，否则将陷入死循环。

- WHILE_LOOP语句

**语法图**

while_loop::=

<div align="left"><img src="image/whileloop.jpg" style="zoom:50%")</div>       

 

只要条件表达式为真，WHILE语句就会不停的在一系列语句上进行循环，在每次进入循环体的时候进行条件判断。

**示例**

创建存储过程并调用。

```
CREATE TABLE integertable(c1 integer) ;  
CREATE OR REPLACE PROCEDURE proc_while_loop(maxval in integer)  
AS  
  DECLARE  
  i int :=1;  
  BEGIN  
    WHILE i < maxval LOOP  
      INSERT INTO integertable VALUES(i);  
      i:=i+1;  
    END LOOP;  
  END;  
/  

CALL proc_while_loop(10); 
```

 查询表数据验证结果。

```
select * from integertable;
```

当结果显示如下信息，则表示循环插入成功。

```
 c1 
-------
  1
  2
  3
  4
  5
  6
  7
  8
  9
(9 rows)
```

- FOR_LOOP（integer变量）语句

**语法图**

for_loop::=

<div align="left"><img src="image/FOR_LOOP.jpg" style="zoom:50%")</div>      

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>       
>
> - 变量name会自动定义为integer类型并且只在此循环里存在。变量name介于lower_bound和upper_bound之间。
>
> - 当使用REVERSE关键字时，lower_bound必须大于等于upper_bound，否则循环体不会被执行。

- FOR_LOOP查询语句

**语法图**

for_loop_query::=

<div align="left"><img src="image/for_loop_query.jpg" style="zoom:50%")</div>       

 

<div align="left"><img src="image/image1.png" style="zoom:25%")</div>       

变量target会自动定义，类型和query的查询结果的类型一致，并且只在此循环中有效。target的取值就是query的查询结果。



- FORALL批量查询语句

**语法图**

forall::=

 <div align="left"><img src="image/forall.jpg" style="zoom:50%")</div>    

 

<div align="left"><img src="image/image1.png" style="zoom:25%")</div>     

变量index会自动定义为integer类型并且只在此循环里存在。index的取值介于low_bound和upper_bound之间。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE hdfs_t1 ( 
 title NUMBER(6), 
 did VARCHAR2(20), 
 data_peroid VARCHAR2(25), 
 kind VARCHAR2(25), 
 interval VARCHAR2(20), 
 time DATE, 
 isModified VARCHAR2(10) 
);  

INSERT INTO hdfs_t1 VALUES( 8, 'Donald', 'OConnell', 'DOCONNEL', '650.507.9833', to_date('21-06-1999', 'dd-mm-yyyy'), 'SH_CLERK' );  
```

2、创建存储过程并调用。

```
CREATE OR REPLACE PROCEDURE proc_forall() 
AS  
BEGIN  
  FORALL i IN 100..120  
  update hdfs_t1 set title = title + 100*i; 
END;  
/ 

CALL proc_forall(); 
```

 3、查询存储过程调用结果 

```
SELECT * FROM hdfs_t1 ;
```

 当结果显示如下信息，则表示循环调用成功。

```
title  |  did   | data_peroid |   kind   |   interval   |        time         | ismodified 
--------+--------+-------------+----------+--------------+---------------------+------------
 231008 | Donald | OConnell    | DOCONNEL | 650.507.9833 | 1999-06-21 00:00:00 | SH_CLERK
(1 row)
```

4、删除存储过程和表 

```
DROP PROCEDURE proc_forall; 
DROP TABLE hdfs_t1;
```

##### 分支语句

**语法格式**

分支语句的语法请参见下图。

case_when::=

<div align="left"><img src="image/case_when.jpg" style="zoom:50%")</div>    

 

when_clause子句的语法图参见下图。

when_clause::=

<div align="left"><img src="image/when_clause.jpg" style="zoom:70%")</div>    

 

**参数说明**

- case_expression：变量或表达式。

- when_expression：常量或者条件表达式。

- statement：执行语句。

**示例**

1、创建并调用存储过程。

```
CREATE OR REPLACE PROCEDURE proc_case_branch(pi_result in integer, pi_return out integer) 
AS  
  BEGIN  
    CASE pi_result  
      WHEN 1 THEN  
        pi_return := 111;         
       WHEN 2 THEN  
        pi_return := 222;  
      WHEN 3 THEN  
        pi_return := 333;  
      WHEN 6 THEN  
        pi_return := 444;  
      WHEN 7 THEN  
        pi_return := 555;  
      WHEN 8 THEN  
        pi_return := 666;  
      WHEN 9 THEN  
        pi_return := 777;  
      WHEN 10 THEN  
        pi_return := 888;  
      ELSE  
        pi_return := 999;  
    END CASE;  
    raise info 'pi_return : %',pi_return ;  
END;  
/ 

CALL proc_case_branch(3,0);  
```

当结果显示如下信息，则表示调用成功。

```
 pi_return 
-------------
       333
(1 row)
```

2、删除存储过程 

```
DROP PROCEDURE proc_case_branch;
```

##### 空语句

**功能描述**

在PL/SQL程序中，可以用NULL语句来说明“不用做任何事情”，相当于一个占位符，可以使某些语句变得有意义，提高程序的可读性。

**语法格式**

```
DECLARE 
  … 
BEGIN 
  … 
  IF v_num IS NULL THEN 
    NULL; -- 不需要处理任何数据。 
  END IF; 
END; 
```

##### 错误捕获语句

**功能描述**

缺省时，当PL/SQL函数执行过程中发生错误时退出函数执行，并且周围的事务也会回滚。可以用一个带有EXCEPTION子句的BEGIN块捕获错误并且从中恢复。

**语法格式**

```
[<<label>>]
[DECLARE
    declarations]
BEGIN
    statements
EXCEPTION
    WHEN condition [OR condition ...] THEN
        handler_statements
    [WHEN condition [OR condition ...] THEN
        handler_statements
    ...]
END;
```

**参数说明**

- condition：可以是SQL标准错误码编号说明的任意值。特殊的条件名OTHERS匹配除了QUERY_CANCELED之外的所有错误类型。

- handler_statements：捕获到错误语句后执行的操作。

**注意事项**

- 如果没有发生错误，这种形式的块儿只是简单地执行所有语句，然后转到END之后的下一个语句。但是如果在执行的语句内部发生了一个错误，则这个语句将会回滚，然后转到EXCEPTION列表。寻找匹配错误的第一个条件。若找到匹配，则执行对应的handler_statements，然后转到END之后的下一个语句。如果没有找到匹配，则会向事务的外层报告错误，和没有EXCEPTION子句一样。错误码可以捕获同一类的其他错误码。也就是说该错误可以被一个包围块用EXCEPTION捕获，如果没有包围块，则进行退出函数处理。
- 如果在选中的handler_statements里发生了新错误，则不能被这个EXCEPTION子句捕获，而是向事务的外层报告错误。一个外层的EXCEPTION子句可以捕获它。
- 如果一个错误被EXCEPTION捕获，PL/SQL函数的局部变量保持错误发生时的原值，但是所有该块中想写入数据库中的状态都回滚。

**示例**

- 示例1：当控制到达给y赋值的地方时，会有一个division_by_zero错误失败。这个错误将被EXCEPTION子句捕获。而在RETURN语句里返回的数值将是x的增量值。

1、创建测试表并插入数据。

```
CREATE TABLE mytab(id INT,firstname VARCHAR(20),lastname VARCHAR(20)) ;
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
```

2、创建函数并调用。

```
CREATE FUNCTION fun_exp() RETURNS INT
AS $$
DECLARE
    x INT :=0;
    y INT;
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;$$
LANGUAGE plpgsql;

call fun_exp();
```

当结果显示如下信息，则表示捕获到错误语句。

```
NOTICE:  caught division_by_zero
 fun_exp 
----------------
       1
(1 row)
```

3、查询表数据验证结果。

```
select * from mytab;
```

结果显示如下：

```
 id | firstname | lastname 
----+-----------+----------
    | Tom       | Jones
(1 row)
```

4、删除测试表和函数。

```
DROP FUNCTION fun_exp();
DROP TABLE mytab;
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - 进入和退出一个包含EXCEPTION子句的块要比不包含的块开销大的多。因此，不必要的时候不要使用EXCEPTION。
>
> - 在下列场景中，无法捕获处理异常，整个存储过程回滚：节点故障、网络故障引起的存储过程参与节点线程退出以及COPY FROM操作中源数据与目标表的表结构不一致造成的异常。

- 示例2：UPDATE/INSERT异常，这个例子根据使用异常处理器执行恰当的UPDATE或INSERT 。

1、创建测试表。

```
CREATE TABLE db (a INT, b TEXT);
```

2、创建测试函数。

```
CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP									
        UPDATE db SET b = data WHERE a = key;		--第一次尝试更新key
        IF found THEN
            RETURN;
        END IF;		
        BEGIN		--不存在，所以尝试插入key，如果其他人同时插入相同的key，我们可能得到唯一key失败。
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
        END;		 --什么也不做，并且循环尝试再次更新。
     END LOOP;
END;
$$
LANGUAGE plpgsql;
```

3、调用函数并查询数据进行对比。

```
SELECT merge_db(1, 'david');
SELECT * FROM db;
```

结果显示如下：

```
 a |   b   
---+-------
 1 | david
(1 row)
```

再次调用并查询。

```
SELECT merge_db(1, 'dennis');
SELECT * FROM db;
```

结果显示如下：

```
 a |   b    
---+--------
 1 | dennis
(1 row)
```

4、删除FUNCTION和TABLE。

```
DROP FUNCTION merge_db;
DROP TABLE db;
```

##### GOTO语句

**功能描述**

GOTO语句可以实现从GOTO位置到目标语句的无条件跳转。GOTO语句会改变原本的执行逻辑，因此应该慎重使用，或者也可以使用EXCEPTION处理特殊场景。当执行GOTO语句时，目标Label必须是唯一的。

**语法格式**

label declaration ::=

<div align="left"><img src="image/label.jpg" style="zoom:50%")</div>    

goto statement ::=

<div align="left"><img src="image/goto.jpg" style="zoom:50%")</div>     

**注意事项**

- 不支持有多个相同的GOTO labels目标场景，无论是否在同一个block中。

  ```
  BEGIN
    GOTO pos1; 
    <<pos1>>
    SELECT * FROM ...
    <<pos1>>
    UPDATE t1 SET ...
  END;
  /
  ```

- 不支持GOTO跳转到IF语句、CASE语句、LOOP语句中。

  ```
  BEGIN
     GOTO pos1; 
     IF valid THEN
       <<pos1>>
       SELECT * FROM ...
     END IF;
   END;
   /
  ```

- 不支持GOTO语句从一个IF子句跳转到另一个IF子句，或从一个CASE语句的WHEN子句跳转到另一个WHEN子句。

  ```
  BEGIN 
     IF valid THEN
       GOTO pos1;
       SELECT * FROM ...
     ELSE
       <<pos1>>
       UPDATE t1 SET ...
     END IF;
   END;
   /
  ```

- 不支持从外部块跳转到内部的BEGIN-END块。

  ```
  BEGIN
     GOTO pos1;  
     BEGIN
       <<pos1>>
       UPDATE t1 SET ...
     END;
   END;
   /
  ```

- 不支持从异常处理部分跳转到当前的BEGIN-END块。但可以跳转到上层BEGIN-END块。

  ```
  BEGIN
     <<pos1>>
     UPDATE t1 SET ...
     EXCEPTION
       WHEN condition THEN
          GOTO pos1;
   END;
   /
  ```

- 如果从GOTO到一个不包含执行语句的位置，需要添加NULL语句。

  ```
  DECLARE
     done  BOOLEAN;
  BEGIN
     FOR i IN 1..50 LOOP
        IF done THEN
           GOTO end_loop;
        END IF;
        <<end_loop>>  -- not allowed unless an executable statement follows
        NULL; -- add NULL statement to avoid error
     END LOOP;  -- raises an error without the previous NULL
  END;
  /
  ```

**示例**

1、创建测试表test。

```
CREATE TABLE test(id,int);
```

2、创建匿名块进行测试，执行过程将从GOTO语句位置跳转到'pos1'标记位置执行。

```
BEGIN
GOTO pos1;
INSERT INTO test(id) VALUES(1);
<<pos1>>
INSERT INTO test(id) VALUES(2);
END;
/
```

3、验证结果。

```
SELECT * FROM test;
```

当结果返回如下信息，则表示跳转成功。

```
 id 
----
  2
(1 row)
```



#### 其他语句

##### 锁操作

Vastbase提供了多种锁模式用于控制对表中数据的并发访问。这些模式可以用在MVCC（多版本并发控制）无法给出期望行为的场合。同样，大多数Vastbase命令自动施加恰当的锁，以保证被引用的表在命令的执行过程中不会以一种不兼容的方式被删除或者修改。比如，在存在其他并发操作的时候，ALTER TABLE是不能在同一个表上执行的。

#### 游标

##### 游标概述

为了处理SQL语句，存储过程进程分配一段内存区域来保存上下文联系。游标是指向上下文区域的句柄或指针。借助游标，存储过程可以控制上下文区域的变化。

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>     
>
> 当游标作为存储过程的返回值时，如果使用JDBC调用该存储过程，返回的游标将不可用。

游标的使用分为显式游标和隐式游标。对于不同的SQL语句，游标的使用情况不同，详细信息请参见下表

| SQL语句              | 游标           |
| :------------------- | :------------- |
| 非查询语句           | 隐式的         |
| 结果是单行的查询语句 | 隐式的或显式的 |
| 结果是多行的查询语句 | 显式的         |

##### 显式游标

**功能描述**

显式游标主要用于对查询语句的处理，尤其是在查询结果为多条记录的情况下。

**处理步骤**

显式游标处理需六个PL/SQL步骤（定义静态游标->打开静态游标->提取游标数据->对该记录进行处理->继续处理->关闭游标）如下所示：

1、定义静态游标：就是定义一个游标名，以及与其相对应的SELECT语句。

定义静态游标的语法图，请参见下图

static_cursor_define::=

<div align="left"><img src="image/静态游标.png" style="zoom:50%")</div>      

参数说明：

- cursor_name：定义的游标名。

- parameter：游标参数，只能为输入参数，其格式为 parameter_name datatype

- select_statement：查询语句。



> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 根据执行计划的不同，系统会自动判断该游标是否可以用于以倒序的方式检索数据行。

定义动态游标：指ref游标，可以通过一组静态的SQL语句动态的打开游标。首先定义ref游标类型，然后定义该游标类型的游标变量，在打开游标时通过OPEN FOR动态绑定SELECT语句。

定义动态游标的语法图，请参见下图。

cursor_typename::=

 <div align="left"><img src="image/cursor_typename.jpg" style="zoom:50%")</div>      

 

dynamic_cursor_define::=

<div align="left"><img src="image/dynamic_cursor_define.jpg" style="zoom:50%")</div>    

 

2、打开静态游标：就是执行游标所对应的SELECT语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集合。如果游标查询语句中带有FOR UPDATE选项，OPEN语句还将锁定数据库表中游标结果集合对应的数据行。

打开静态游标的语法图，请参见下图

open_static_cursor::=

<div align="left"><img src="image/open_static_cursor.jpg" style="zoom:50%")</div>     

 

打开动态游标：可以通过OPEN FOR语句打开动态游标，动态绑定SQL语句。

打开动态游标的语法图，请参见下图。

open_dynamic_cursor::=

<div align="left"><img src="image/open_dynamic_cursor.jpg" style="zoom:50%")</div>      

 

PL/SQL程序不能用OPEN语句重复打开一个游标。

3、提取游标数据：检索结果集合中的数据行，放入指定的输出变量中。

提取游标数据的语法图，请参见下图。

fetch_cursor::=

<div align="left"><img src="image/fetch_cursor.jpg" style="zoom:50%")</div>    

 

4、对该记录进行处理。

5、继续处理，直到活动集合中没有记录。

6、关闭游标：当提取和处理完游标结果集合数据后，应及时关闭游标，以释放该游标所占用的系统资源，并使该游标的工作区变成无效，不能再使用FETCH语句获取其中数据。关闭后的游标可以使用OPEN语句重新打开。

关闭游标的语法图，请参见下图。

close_cursor::=

<div align="left"><img src="image/close_cursor.png" style="zoom:50%")</div>     

 

 

**属性**

游标的属性用于控制程序流程或者了解程序的状态。当运行DML语句时，PL/SQL打开一个内建游标并处理结果，游标是维护查询结果的内存中的一个区域，游标在运行DML语句时打开，完成后关闭。显式游标的属性为：

- %FOUND布尔型属性：当最近一次读记录时成功返回，则值为TRUE。

- %NOTFOUND布尔型属性：与%FOUND相反。

- %ISOPEN布尔型属性：当游标已打开时返回TRUE。

- %ROWCOUNT数值型属性：返回已从游标中读取的记录数。

##### 隐式游标

**功能描述**

对于非查询语句，如修改、删除操作，则由系统自动地为这些操作设置游标并创建其工作区，这些由系统隐含创建的游标称为隐式游标，隐式游标的名称为SQL，这是由系统定义的。

对于隐式游标的操作，如定义、打开、取值及关闭操作，都由系统自动地完成，无需用户进行处理。用户只能通过隐式游标的相关属性，来完成相应的操作。在隐式游标的工作区中，所存放的数据是最新处理的一条SQL语句所包含的数据，与用户自定义的显式游标无关。

**语法格式**

格式调用为： SQL%

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>     
>
> INSERT，UPDATE，DELETE，SELECT语句中不必明确定义游标。

**属性**

隐式游标属性为：

- SQL%FOUND布尔型属性：当最近一次读记录时成功返回，则值为TRUE。

- SQL%NOTFOUND布尔型属性：与%FOUND相反。

- SQL%ROWCOUNT数值型属性：返回已从游标中读取得记录数。

- SQL%ISOPEN布尔型属性：取值总是FALSE。SQL语句执行完毕立即关闭隐式游标。

**示例**

1、创建测试表staffs。

```
create table staffs(
section_id int,
salary int
);
insert into staffs values(1,1000);
insert into staffs values(2,1000);
insert into staffs values(3,1000);
insert into staffs values(4,1000);
insert into staffs values(5,1000);
insert into staffs values(6,1000);
insert into staffs values(7,1000);
insert into staffs values(8,1000);
```

2、创建测试表sections。

```
create table sections(
section_id int,
salary int
);
insert into sections values(1,1000);
insert into sections values(2,1000);
insert into sections values(3,1000);
insert into sections values(4,1000);
insert into sections values(5,1000);
insert into sections values(6,1000);
insert into sections values(7,1000);
```

 3、删除员工表staffs中某部门的所有员工，如果该部门中已没有员工，则在部门表section中删除该部门。 

```
CREATE OR REPLACE PROCEDURE proc_cursor1()  
AS  
  DECLARE 
  V_DEPTNO NUMBER(4) := 100; 
  BEGIN 
  	DELETE FROM staffs WHERE section_ID = V_DEPTNO; 
    --根据游标状态做进一步处理 
    IF SQL%NOTFOUND THEN 
    DELETE FROM sections WHERE section_ID = V_DEPTNO; 
   END IF; 
  END; 
/ 
CALL proc_cursor1(); 
```

4、删除存储过程和表 

```
DROP PROCEDURE proc_cursor1; 
DROP TABLE sections;
DROP TABLE staffs;
```

##### 游标循环

**功能描述**

游标在WHILE语句、LOOP语句中的使用称为游标循环，一般这种循环都需要使用OPEN、FETCH和CLOSE语句。下面要介绍的一种循环不需要这些操作，可以简化游标循环的操作，这种循环方式适用于静态游标的循环，不用执行静态游标的四个步骤。

**语法**

FOR AS循环的语法请参见下图。

FOR_AS_loop::=

<div align="left"><img src="image/FOR_AS_loop.jpg" style="zoom:80%")</div>     

 

**注意事项**

- 不能在该循环语句中对查询的表进行更新操作。

- 变量loop_name会自动定义且只在此循环中有效，类型和select_statement的查询结果类型一致。loop_name的取值就是select_statement的查询结果。

- 游标的属性中%FOUND、%NOTFOUND、%ROWCOUNT在Vastbase数据库中都是访问同一个内部变量，事务和匿名块不支持多个游标同时访问。

#### Retry管理

**功能描述**

Retry是数据库在SQL或存储过程（包含匿名块）执行失败时，在数据库内部进行重新执行的过程，以提高执行成功率和用户体验。数据库内部通过检查发生错误时的错误码及Retry相关配置，决定是否进行重试。

**注意事项**

失败时回滚之前执行的语句，并重新执行存储过程进行Retry。

**示例**

```
CREATE OR REPLACE PROCEDURE retry_basic ( IN  x INT) 
AS  
BEGIN
      INSERT INTO t1 (a) VALUES (x);
      INSERT INTO t1 (a) VALUES (x+1);
END;
/

CALL retry_basic(1); 
```

#### 调试

**语法格式**

RAISE有以下五种语法格式：

raise_format::=

<div align="left"><img src="image/raise_format.jpg" style="zoom:50%")</div>      

 

 raise_condition::=

<div align="left"><img src="image/raise_condition.jpg" style="zoom:50%")</div>       

 

raise_sqlstate::=

<div align="left"><img src="image/raise_sqlstate.jpg" style="zoom:50%")</div>   

 

图1-4. raise_option::=

<div align="left"><img src="image/raise_option.jpg" style="zoom:50%")</div>  

 

图1-5. raise::= <a  id="raise"></a>

<div align="left"><img src="image/Raise.jpg" style="zoom:50%")</div>   

**参数说明：**

- level选项用于指定错误级别，有DEBUG，LOG，INFO，NOTICE，WARNING以及EXCEPTION（默认值）。EXCEPTION抛出一个正常终止当前事务的异常，其他的仅产生不同异常级别的信息。特殊级别的错误信息是否报告到客户端、写到服务器日志由log_min_messages和client_min_messages这两个配置参数控制。

- format：格式字符串，指定要报告的错误消息文本。格式字符串后可跟表达式，用于向消息文本中插入。在格式字符串中，%由format后面跟着的参数的值替换，%%用于打印出%。例如：

```
--v_job_id 将替换字符串中的 %： 
RAISE NOTICE 'Calling cs_create_job(%)',v_job_id;
```

- option = expression：向错误报告中添加另外的信息。关键字option可以是MESSAGE、DETAIL、HINT以及ERRCODE，并且每一个expression可以是任意的字符串。
  - MESSAGE，指定错误消息文本，这个选项不能用于在USING前包含一个格式字符串的RAISE语句中。
  - DETAIL，说明错误的详细信息。
  - HINT，用于打印出提示信息。
  - ERRCODE，向报告中指定错误码（SQLSTATE）。可以使用条件名称或者直接用五位字符的SQLSTATE错误码。

- condition_name：错误码对应的条件名。

- sqlstate：错误码。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - 如果在RAISE EXCEPTION命令中既没有指定条件名也没有指定SQLSTATE，默认用RAISE EXCEPTION (P0001)。如果没有指定消息文本，默认用条件名或者SQLSTATE作为消息文本。
>
> - [raice](#raise)所示的语法不接任何参数。这种形式仅用于一个BEGIN块中的EXCEPTION语句，它使得错误重新被处理。
> - 当由SQLSTATE指定了错误码，则不局限于已定义的错误码，可以选择任意包含五个数字或者大写的ASCII字母的错误码，而不是00000。建议避免使用以三个0结尾的错误码，因为这种错误码是类别码，会被整个种类捕获。 - 兼容O模式下，SQLCODE等于SQLSTATE。

**示例**

- 示例1：终止事务时，给出错误和提示信息：

```
CREATE OR REPLACE PROCEDURE proc_raise1(user_id in integer) 
AS  
BEGIN  
RAISE EXCEPTION 'Noexistence ID --> %',user_id USING HINT = 'Please check your user ID';  
END;  
/ 

call proc_raise1(300011); 
```

 结果显示如下：

```
ERROR:  Noexistence ID --> 300011 
HINT:  Please check your user ID
```

示例2：两种设置SQLSTATE的方式：

```
CREATE OR REPLACE PROCEDURE proc_raise2(user_id in integer) 
AS  
BEGIN  
RAISE 'Duplicate user ID: %',user_id USING ERRCODE = 'unique_violation';  
END;  
/ 

\set VERBOSITY verbose 

call proc_raise2(300011); 
```

 结果显示如下： 

```
ERROR:  Duplicate user ID: 300011 
SQLSTATE: 23505 
```

如果主要的参数是条件名或者是SQLSTATE，可以使用：

```
RAISE division_by_zero;
RAISE SQLSTATE '22012';
```

例如：

```
CREATE OR REPLACE PROCEDURE division(div in integer, dividend in integer)  
AS  
DECLARE  
res int;  
  BEGIN  
  IF dividend=0 THEN  
   RAISE division_by_zero;  
    RETURN;  
  ELSE  
    res := div/dividend;  
    RAISE INFO 'division result: %', res; 
    RETURN;  
  END IF;  
  END;  
/ 

call division(3,0);  
```

结果显示如下 

```
ERROR:  division_by_zero
SQLSTATE: 22012
```

或者另一种方式：

```
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
```

### 全文检索

#### 介绍

##### 全文检索概述

**功能描述**

文本搜索操作符在数据库中已存在多年。Vastbase为文本数据类型提供~、~*、LIKE和ILIKE操作符用于匹配字符进行检索，同时可以通过使用词典和索引满足现代信息系统所要求的许多必要属性。

**注意事项**

- 每个分词长度必须小于2K字节。
- tsvector结构（分词+位置）的长度必须小于1m字节。
- tsvector的位置值必须大于0，且小于等于16,383字节。
- 每个分词在文档中位置数必须小于256字节，若超过将舍弃后面的位置信息。
- tsquery中的关键字及对应运算符最大支持到32768字节。

- 没有语义支持，即使是英语。由于要识别派生词并不是那么容易，因此正则表达式也不能满足要求。如，satisfies和satisfy，当使用正则表达式寻找satisfy时，并不会查询到包含satisfies的文档。用户可以使用OR搜索多种派生形式，但过程非常繁琐。并且有些词会有上千的派生词，因此容易出错。

- 没有对搜索结果的分类（排序）。当搜索出成千的文档时，查找效率很低。

- 由于没有索引的支持，每一次的搜索需要遍历所有的文档，整体搜索比较缓慢。使用全文索引可以对文档进行预处理，并且可以使后续的搜索更快速。预处理过程包括：

- 将文档解析成token。为每个文档标记不同类别的token是非常有必要的，例如：数字、文字、复合词、电子邮件地址，这样就可以做不同的处理。原则上token的类别依赖于具体的应用，但对于大多数的应用来说，可以使用一组预定义的token类。

- 将token转换为词素。词素像token一样是一个字符串，但它已经标准化处理，这样同一个词的不同形式是一样的。例如，标准化通常包括：将大写字母转换成小写字母、删除后缀（如英语中的s或者es）。这将允许通过搜索找到同一个词的不同形式，不需要繁琐地输入所有可能的变形样式。同时，这一步通常会删除停用词。这些停用词通常因为太常见而对搜索无用。（总之，token是文档文本的原片段，而词素被认为是有用的索引和搜索词。）Vastbase使用词典执行这一步，且提供了各种标准的词典。

- 保存搜索优化后的预处理文档。比如，每个文档可以呈现为标准化词素的有序组合。伴随词素，通常还需要存储词素位置信息以用于邻近排序。因此文档包含的查询词越密集其排序越高。

- 词典能够对token如何标准化做到细粒度控制。使用合适的词典，可以定义不被索引的停用词。

- 数据类型tsvector用于存储预处理文档，tsquery用于存储查询条件，详细请参见章节”文本搜索类型“。为这些数据类型提供的函数和操作符请参见章节”文本检索函数和操作符“。其中最重要的是匹配运算符@@，将在章节”基本文本匹配“中介绍。

##### 文档

**功能描述**

文档是全文搜索系统的搜索单元，例如：杂志上的一篇文章或电子邮件消息。文本搜索引擎必须能够解析文档，而且可以存储父文档的关联词素（关键词）。后续，这些关联词素用来搜索包含查询词的文档。

在Vastbase中，文档通常是一个数据库表中一行的文本字段，或者这些字段的可能组合（级联）。文档可能存储在多个表中或者需动态获取。换句话说，一个文档由被索引化的不同部分构成，因此无法存储为一个整体，如 [示例](#exam)所示。

另外一种可能是：文档在文件系统中作为简单的文本文件存储。在这种情况下，数据库可以用于存储全文索引并且执行搜索，同时可以使用一些唯一标识从文件系统中检索文档。然而，从数据库外部检索文件需要拥有系统管理员权限或者特殊函数支持。因此，还是将所有数据保存在数据库中比较方便。同时，将所有数据保存在数据库中可以方便地访问文档元数据以便于索引和显示。

**注意事项**

为了实现文本搜索目的，必须将每个文档减少至预处理后的tsvector格式。搜索和相关性排序都是在tsvector形式的文档上执行的。原始文档只有在被选中要呈现给用户时才会被检索。因此，我们常将tsvector说成文档，但是很显然其实它只是完整文档的一种紧凑表示。

**示例**  <a id="exam"></a> 

1、创建测试表并插入数据。

```
create table date_dim(
d_dow int,
d_dom int,
d_fy_week_seq int
);

insert into date_dim values(5,6,1);
insert into date_dim values(0,8,1);
insert into date_dim values(2,3,1);
insert into date_dim values(3,4,1);
insert into date_dim values(4,5,1);
insert into date_dim values(1,2,1);
insert into date_dim values(6,7,1);
insert into date_dim values(4,5,2);
insert into date_dim values(1,2,2);
insert into date_dim values(6,7,2);
```

2、查询数据。

```
SELECT d_dow || '-' || d_dom || '-' || d_fy_week_seq  AS identify_serials FROM date_dim WHERE d_fy_week_seq = 1; 
```

结果显示如下

```
identify_serials  
--------------------
 5-6-1 
 0-8-1 
 2-3-1 
 3-4-1 
 4-5-1 
 1-2-1 
 6-7-1 
(7 rows) 
```



> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   
>
> 实际上，在这些示例查询中，应该使用coalesce防止一个独立的NULL属性导致整个文档的NULL结果。

##### 基本文本匹配

**功能描述**

Vastbase的全文检索基于匹配算子@@，当一个tsvector(document)匹配到一个tsquery(query)时，则返回true。其中，tsvector(document)和tsquery(query)两种数据类型可以任意排序。

**示例**

- 查询验证结果。

```
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat & rat'::tsquery AS RESULT; 
```

结果返回如下：

```
 result 
---------- 
 t 
(1 row)
```

```
SELECT 'fat & cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector AS RESULT; 
```

结果返回如下：

```
 result 
---------- 
 f 
(1 row) 
```

- tsquery不仅是文本，且比tsvector包含的要多。tsquery包含已经标注化为词条的搜索词，同时可能是使用AND、OR、或NOT操作符连接的多个术语。详细请参见章节“文本搜索类型”。函数to_tsquery和plainto_tsquery对于将用户书写文本转换成适合的tsquery是非常有用的，比如将文本中的词标准化。类似地，to_tsvector用于解析和标准化文档字符串。因此，实际中文本搜索匹配看起来更像这样：

```
SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat & rat') AS RESULT; 
```

结果返回如下：

```
result 
---------- 
 t 
(1 row)
```

需要注意的是，下面这种方式是不可行的：

```
SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat & rat')AS RESULT; 
```

结果返回如下：

```
result 
---------- 
 f 
(1 row)
```

- 由于tsvector没有对rats进行标准化，所以rats不匹配rat。

  @@操作符也支持text输入，允许一个文本字符串的显示转换为tsvector或者在简单情况下忽略tsquery。可用形式是：

```
tsvector @@ tsquery 
tsquery  @@ tsvector 
text @@ tsquery 
text @@ text
```

我们已经看到了前面两种，形式text @@ tsquery等价于to_tsvector(text) @@ tsquery，而text @@ text等价于to_tsvector(text) @@ plainto_tsquery(text)。

##### 分词器

**功能描述**

全文检索功能还可以做更多事情：忽略索引某个词（停用词），处理同义词和使用复杂解析，例如：不仅基于空格的解析。这些功能通过文本搜索分词器控制。Vastbase支持多语言的预定义的分词器，并且可以创建分词器（\dF命令显示了所有可用分词器）。

为了更方便的建立自定义文本搜索分词器，可以通过简单的数据库对象建立分词器。 Vastbase文本搜索功能提供了四种类型与分词器相关的数据库对象：

- 文本搜索解析器将文档分解为token，并且分类每个token（例如：词和数字）。

- 文本搜索词典将token转换成规范格式并且丢弃停用词。

- 文本搜索模板提供潜在的词典功能：一个词典指定一个模板，并且为模板设置参数。
- 文本搜索分词器选择一个解析器，并且使用一系列词典规范化语法分析器产生的token。

**使用方法**

- 在安装期间选择一个合适的分词器，并且在postgresql.conf中相应的设置default_text_search_config。

- 如果为了Vastbase使用同一个文本搜索分词器可以使用postgresql.conf中的值。

- 如果需要在Vastbase中使用不同分词器，可以使用ALTER DATABASE … SET在任一数据库进行配置。

- 用户也可以在每个会话中设置default_text_search_config。

**注意事项**

每个依赖于分词器的文本搜索函数有一个可选的配置参数，用以明确声明所使用的分词器。仅当忽略这个参数的时候，才使用default_text_search_config。



#### 表和索引

##### 搜索表

**功能描述**

在不使用索引的情况下也可以进行全文检索。

**示例**

创建测试表并插入数据。

```
DROP SCHEMA IF EXISTS tsearch CASCADE;
CREATE SCHEMA tsearch;
CREATE TABLE tsearch.pgweb(id int, body text, title text, last_mod_date date);
   
INSERT INTO tsearch.pgweb VALUES(1, 'China, officially the People''s Republic of China (PRC), located in Asia, is the world''s most populous state.', 'China', '2010-1-1');  
INSERT INTO tsearch.pgweb VALUES(2, 'America is a rock band, formed in England in 1970 by multi-instrumentalists Dewey Bunnell, Dan Peek, and Gerry Beckley.', 'America', '2010-1-1');   
INSERT INTO tsearch.pgweb VALUES(3, 'England is a country that is part of the United Kingdom. It shares land borders with Scotland to the north and Wales to the west.', 'England', '2010-1-1');   
INSERT INTO tsearch.pgweb VALUES(4, 'Australia, officially the Commonwealth of Australia, is a country comprising the mainland of the Australian continent, the island of Tasmania, and numerous smaller islands.', 'Australia', '2010-1-1'); 
INSERT INTO tsearch.pgweb VALUES(6, 'Japan is an island country in East Asia.', 'Japan', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(7, 'Germany, officially the Federal Republic of Germany, is a sovereign state and federal parliamentary republic in central-western Europe.', 'Germany', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(8, 'France, is a sovereign state comprising territory in western Europe and several overseas regions and territories.', 'France', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(9, 'Italy officially the Italian Republic, is a unitary parliamentary republic in Europe.', 'Italy', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(10, 'India, officially the Republic of India, is a country in South Asia.', 'India', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(11, 'Brazil, officially the Federative Republic of Brazil, is the largest country in both South America and Latin America.', 'Brazil', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(12, 'Canada is a country in the northern half of North America.', 'Canada', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(13, 'Mexico, officially the United Mexican States, is a federal republic in the southern part of North America.', 'Mexico', '2010-1-1');
```

- 示例1：一个简单查询，将body字段中包含america的每一行打印出来。像America这样的相关词也会被找到，因为这些词都被处理成了相同标准的词条。

```
SELECT id, body, title FROM tsearch.pgweb WHERE to_tsvector('english', body) @@ to_tsquery('english', 'america');
```

结果显示如下：

```
 id |                                                          body                                                           |  title  
----+-------------------------------------------------------------------------------------------------------------------------+---------
  2 | America is a rock band, formed in England in 1970 by multi-instrumentalists Dewey Bunnell, Dan Peek, and Gerry Beckley. | America
 11 | Brazil, officially the Federative Republic of Brazil, is the largest country in both South America and Latin America.   | Brazil
 12 | Canada is a country in the northern half of North America.                                                              | Canada
 13 | Mexico, officially the United Mexican States, is a federal republic in the southern part of North America.              | Mexico
(4 rows)
```

上面的查询指定english配置来解析和规范化字符串。当然也可以省略此配置，通过default_text_search_config进行配置设置。

查询default_text_search_config; 参数

```
 SHOW default_text_search_config; 
 
 default_text_search_config  
---------------------------- 
 pg_catalog.english 
(1 row) 

 
```

执行查询

```
SELECT id, body, title FROM tsearch.pgweb WHERE to_tsvector(body) @@ to_tsquery('america'); 
```

结果显示如下：

```
 id |                                                          body                                                           |  title  
----+-------------------------------------------------------------------------------------------------------------------------+---------
  2 | America is a rock band, formed in England in 1970 by multi-instrumentalists Dewey Bunnell, Dan Peek, and Gerry Beckley. | America
 11 | Brazil, officially the Federative Republic of Brazil, is the largest country in both South America and Latin America.   | Brazil
 12 | Canada is a country in the northern half of North America.                                                              | Canada
 13 | Mexico, officially the United Mexican States, is a federal republic in the southern part of North America.              | Mexico
(4 rows)


```

- 示例2：一个复杂查询：检索出在title或者body字段中包含north和america的最近10篇文档：

```
SELECT title FROM tsearch.pgweb WHERE to_tsvector(title || ' ' || body) @@ to_tsquery('north & america') ORDER BY last_mod_date DESC LIMIT 10; 
```

结果显示如下：

```
 title  
-------- 
 Mexico 
 Canada 
(2 rows)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - 为了清晰，举例中没有调用coalesce函数在两个字段中查找包含NULL的行。
> - 以上例子均在没有索引的情况下进行查询。对于大多数应用程序来说，这个方法很慢。因此除了偶尔的特定搜索，文本搜索在实际使用中通常需要创建索引。

##### 创建GIN索引

**功能描述**

为了加速文本搜索，可以创建GIN索引。

**注意事项**

- to_tsvector()函数有两个版本。只输一个参数的版本和输两个参数的版本。只输一个参数时，系统默认采用default_text_search_config所指定的分词器。
- 创建索引时必须使用to_tsvector的两参数版本。只有指定了分词器名称的全文检索函数才可以在索引表达式中使用。这是因为索引的内容必须不受default_text_search_config的影响，否则索引内容可能不一致。由于default_text_search_config的值可以随时调整，从而导致不同条目生成的tsvector采用了不同的分词器，并且没有办法区分究竟使用了哪个分词器。正确地转储和恢复这样的索引也是不可能的。
- 因为在上述创建索引中to_tsvector使用了两个参数，只有当查询时也使用了两个参数，且参数值与索引中相同时，才会使用该索引。也就是说，WHERE to_tsvector('english', body) @@ 'a & b' 可以使用索引，但WHERE to_tsvector(body) @@ 'a & b'不能使用索引。这确保只使用这样的索引——索引各条目是使用相同的分词器创建的。

**示例**

- 方法一：

1、创建GIN索引，索引中的分词器名称由另一列指定时可以建立更复杂的表达式索引。

```
CREATE INDEX pgweb_idx_1 ON tsearch.pgweb USING gin(to_tsvector('ngram', body));
```

2、索引可以连接列。

```
CREATE INDEX pgweb_idx_2 ON tsearch.pgweb USING gin(to_tsvector('english', title || ' ' || body));
```

- 方法二：

1、创建一个单独的tsvector列控制to_tsvector的输出。下面的例子是title和body的连接，当其它是NULL的时候，使用coalesce确保一个字段仍然会被索引：

```
ALTER TABLE tsearch.pgweb ADD COLUMN textsearchable_index_col tsvector; 
UPDATE tsearch.pgweb SET textsearchable_index_col = to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''));
```

2、为加速搜索创建一个GIN索引。

```
CREATE INDEX textsearch_idx_3 ON tsearch.pgweb USING gin(textsearchable_index_col);
```

3、执行一个快速全文搜索。

```
SELECT title 
FROM tsearch.pgweb 
WHERE textsearchable_index_col @@ to_tsquery('north & america') 
ORDER BY last_mod_date DESC 
LIMIT 10; 
```

结果显示如下：

```
 title  
--------
 Canada
 Mexico
(2 rows)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 相比于一个表达式索引，单独列方法的一个优势是：它没有必要在查询时明确指定分词器以便能使用索引。正如上面例子所示，查询可以依赖于default_text_search_config。另一个优势是搜索比较快速，因为它没有必要重新利用to_tsvector调用来验证索引匹配。表达式索引方法更容易建立，且它需要较少的磁盘空间，因为tsvector形式没有明确存储。

##### 索引使用约束

下面是一个使用索引的例子：

```
create table table1 (c_int int,c_bigint bigint,c_varchar varchar,c_text text) with(orientation=row); 
create text search configuration ts_conf_1(parser=POUND); 
create text search configuration ts_conf_2(parser=POUND) with(split_flag='%'); 
set default_text_search_config='ts_conf_1'; 
create index idx1 on table1 using gin(to_tsvector(c_text)); 
set default_text_search_config='ts_conf_2'; 
create index idx2 on table1 using gin(to_tsvector(c_text)); 
```

 查询测试

```
select c_varchar,to_tsvector(c_varchar) from table1 where to_tsvector(c_text) @@ plainto_tsquery('￥#@……&**')  and to_tsvector(c_text) @@  plainto_tsquery('某公司 ')  and c_varchar is not null order by 1 desc limit 3;
```

该例子的关键点是表table1的同一个列c_text上建立了两个gin索引：idx1和idx2，但这两个索引是在不同default_text_search_config的设置下建立的。该例子和同一张表的同一个列上建立普通索引的不同之处在于：

- gin索引使用了不同的parser（即分隔符不同），那么idx1和idx2的索引数据是不同的；

- 在同一张表的同一个列上建立的多个普通索引的索引数据是相同的。

因此当执行同一个查询时，使用idx1和idx2查询出的结果是不同的。

**使用约束**

通过上面的例子，索引使用满足如下条件时：

- 在同一个表的同一个列上建立了多个gin索引；

- 这些gin索引使用了不同的parser（即分隔符不同）；

- 在查询中使用了该列，且执行计划中使用索引进行扫描；

为了避免使用不同gin索引导致查询结果不同的问题，需要保证在物理表的一列上只有一个gin索引可用。

#### 控制文本搜索

##### 解析文档

**功能描述**

Vastbase中提供了to_tsvector函数把文档处理成tsvector数据类型。

**语法格式**

```
to_tsvector([ config regconfig, ] document text) returns tsvector
```

**to_tsvector函数**

to_tsvector将文本文档解析为token，再将token简化到词素，并返回一个tsvector。其中tsvector中列出了词素及它们在文档中的位置。文档是根据指定的或默认的文本搜索分词器进行处理的。

to_tsvector函数内部调用一个解析器，将文档的文本分解成token并给每个token指定一个类型。对于每个token，有一系列词典可供查询。词典系列因token类型的不同而不同。识别token的第一本词典将发出一个或多个标准词素来表示token。例如：

- rats变成rat因为词典认为词rats是rat的复数形式。

- 有些词被作为停用词（请参考章节"停用词"），这样它们就会被忽略，因为它们出现得太过频繁以致于搜索中没有用处。比如例子中的a、on和it。

- 如果没有词典识别token，那么它也被忽略。在这个例子中，符号“-”被忽略，因为词典没有给它分配token类型（空间符号），即空间记号永远不会被索引。

语法解析器、词典和要索引的token类型由选定的文本搜索分词器决定。可以在同一个数据库中有多种不同的分词器，以及提供各种语言的预定义分词器。在以上例子中，使用缺省分词器english。

函数setweight可以给tsvector的记录加权重，权重是字母A、B、C、D之一。这通常用于标记来自文档不同部分的记录，比如标题、正文。之后，这些信息可以用于排序搜索结果。

因为to_tsvector(NULL)会返回空，当字段可能是空的时候，建议使用coalesce。

**示例**

- 示例1：结果tsvector不包含词a、on或者it，rats变成rat，并且忽略标点符号-。

```
SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat rats');
```

结果显示如下：

```
                     to_tsvector                     
-----------------------------------------------------
 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4
(1 row)
```

- 示例2：结构化文档创建tsvector的方法：

```
CREATE TABLE tsearch.tt (id int, title text, keyword text, abstract text, body text, ti tsvector); 

INSERT INTO tsearch.tt(id, title, keyword, abstract, body) VALUES (1, 'China', 'Beijing', 'China','China, officially the People''s Republic of China (PRC), located in Asia, is the world''s most populous state.'); 

UPDATE tsearch.tt SET ti = 
 setweight(to_tsvector(coalesce(title,'')), 'A')   || 
 setweight(to_tsvector(coalesce(keyword,'')), 'B')  || 
 setweight(to_tsvector(coalesce(abstract,'')), 'C') || 
 setweight(to_tsvector(coalesce(body,'')), 'D'); 
```

结果显示如下：

```
 id | title | keyword | abstract |                              body                                        |                                      
                       ti                                                              
----+-------+---------+----------+--------------------------------------------------------------------------------------------------------------+--------------------------------------
---------------------------------------------------------------------------------------
  1 | China | Beijing | China    | China, officially the People's Republic of China (PRC), located in Asia, is the world's most populous state. | 'asia':15 'beij':2B 'china':1A,3C,4,1
1 'locat':13 'offici':5 'peopl':7 'popul':21 'prc':12 'republ':9 'state':22 'world':18
```



##### 解析查询

**功能描述**

Vastbase提供了函数to_tsquery和plainto_tsquery将查询转换为tsquery数据类型，to_tsquery提供比plainto_tsquery更多的功能，但对其输入要求更严格。

**语法格式**

```
to_tsquery([ config regconfig, ] querytext text) returns tsquery
```

**注意事项**

to_tsquery从querytext中创建一个tsquery，querytext必须由布尔运算符& (AND)，| (OR)和! (NOT)分割的单个token组成。这些运算符可以用圆括弧分组。换句话说，to_tsquery输入必须遵循tsquery输入的通用规则，具体请参见章节“文本搜索类型”。不同的是基本tsquery以token表面值作为输入，而to_tsquery使用指定或默认分词器将每个token标准化成词素，并依据分词器丢弃属于停用词的token。

**示例**

基本tsquery以token表面值作为输入，而to_tsquery使用指定或默认分词器将每个token标准化成词素，并依据分词器丢弃属于停用词的token。比如：

```
SELECT to_tsquery('english', 'The & Fat & Rats'); 

to_tsquery   
--------------- 
 'fat' & 'rat' 
(1 row)
```

像在基本tsquery中的输入一样，weight(s)可以附加到每个词素来限制它只匹配那些有相同weight(s)的tsvector词素。比如：

```
SELECT to_tsquery('english', 'Fat | Rats:AB'); 

  to_tsquery   
------------------ 
 'fat' | 'rat':AB 
(1 row)
```

同时，也可以附加到词素来指定前缀匹配：

```
SELECT to_tsquery('supern:*A & star:A*B'); 

to_tsquery     
-------------------------- 
 'supern':*A & 'star':*AB 
(1 row)
```

这样的词素将匹配tsquery中指定字符串和权重的项。

```
plainto_tsquery([ config regconfig, ] querytext text) returns tsquery
```

plainto_tsquery将未格式化的文本querytext变换为tsquery。类似于to_tsvector，文本被解析并且标准化，然后在存在的词之间插入&(AND)布尔算子。比如：

```
SELECT plainto_tsquery('english', 'The Fat Rats'); 

 plainto_tsquery  
----------------- 
'fat' & 'rat' 
(1 row)
```

请注意，plainto_tsquery无法识别布尔运算符、权重标签，或在其输入中的前缀匹配标签：

```
SELECT plainto_tsquery('english', 'The Fat & Rats:C'); 

  plainto_tsquery   
--------------------- 
 'fat' & 'rat' & 'c' 
(1 row)
```

在这里，所有输入的标点符号作为空格符号丢弃。

##### 排序查询结果

**功能描述**

排序试图针对特定查询衡量文档的相关度，从而将众多的匹配文档中相关度最高的文档排在最前。Vastbase提供了两个预置的排序函数。函数考虑了词法、距离和结构信息；也就是，他们考虑查询词在文档中出现的频率、紧密程度以及他们出现的地方在文档中的重要性。然而，相关性的概念是模糊的，并且是跟应用强相关的。不同的应用程序可能需要额外的信息来排序，比如，文档的修改时间、内置的排序函数等。也可以开发自己的排序函数或者采用附加因素组合这些排序函数的结果来满足特定需求。

**预置排序函数**

```
ts_rank([ weights float4[], ] vector tsvector, query tsquery [, normalization integer ]) returns float4
```

基于词素匹配率对vector进行排序：

```
ts_rank_cd([ weights float4[], ] vector tsvector, query tsquery [, normalization integer ]) returns float4
```

该函数需要位置信息的输入。因此它不能在“剥离”tsvector值的情况下运行—它将总是返回零。

**权重**

- 对于这两个函数，可选的weights参数提供给词加权重的能力，词的权重大小取决于所加的权值。权重阵列指定在排序时为每类词汇加多大的权重。如果没有提供weights，则使用缺省值：{0.1, 0.2, 0.4, 1.0}。

```
{D-weight, C-weight, B-weight, A-weight}
```

- 通常的权重是用来标记文档特殊领域的词，如标题或最初的摘要，所以相对于文章主体中的词它们有着更高或更低的重要性。

- 由于较长的文档有更多的机会包含查询词，因此有必要考虑文档的大小。例如，包含有5个搜索词的一百字文档比包含有5个搜索词的一千字文档相关性更高。两个预置的排序函数都采用了一个整型的标准化选项来定义文档长度是否影响排序及如何影响。这个整型选项控制多个行为，所以它是一个屏蔽字：可以使用|指定一个或多个行为（例如，2|4）。

  - 0（缺省）表示：跟长度大小没有关系
  - 1 表示：排名（rank）除以（文档长度的对数+1）
  - 2表示：排名除以文档的长度
  - 4表示：排名除以两个扩展词间的调和平均距离。只能使用ts_rank_cd实现
  - 8表示：排名除以文档中单独词的数量
  - 16表示：排名除以单独词数量的对数+1
  - 32表示：排名除以排名本身+1

  当指定多个标志位时，会按照所列的顺序依次进行转换。

**注意事项**

需要特别注意的是，排序函数不使用任何全局信息，所以不可能产生一个某些情况下需要的1%或100%的理想标准值。标准化选项32 (rank/(rank+1))可用于所有规模的从零到一之间的排序，当然，这只是一个表面变化；它不会影响搜索结果的排序。

**示例**

创建测试表并插入数据。

```
DROP SCHEMA IF EXISTS tsearch CASCADE;
CREATE SCHEMA tsearch;
CREATE TABLE tsearch.pgweb(id int, body text, title text, last_mod_date date);

INSERT INTO tsearch.pgweb VALUES(1, 'China, officially the People''s Republic of China (PRC), located in Asia, is the world''s most populous state.', 'China', '2010-1-1');  
INSERT INTO tsearch.pgweb VALUES(2, 'America is a rock band, formed in England in 1970 by multi-instrumentalists Dewey Bunnell, Dan Peek, and Gerry Beckley.', 'America', '2010-1-1');   
INSERT INTO tsearch.pgweb VALUES(3, 'England is a country that is part of the United Kingdom. It shares land borders with Scotland to the north and Wales to the west.', 'England', '2010-1-1');   
INSERT INTO tsearch.pgweb VALUES(4, 'Australia, officially the Commonwealth of Australia, is a country comprising the mainland of the Australian continent, the island of Tasmania, and numerous smaller islands.', 'Australia', '2010-1-1'); 
INSERT INTO tsearch.pgweb VALUES(6, 'Japan is an island country in East Asia.', 'Japan', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(7, 'Germany, officially the Federal Republic of Germany, is a sovereign state and federal parliamentary republic in central-western Europe.', 'Germany', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(8, 'France, is a sovereign state comprising territory in western Europe and several overseas regions and territories.', 'France', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(9, 'Italy officially the Italian Republic, is a unitary parliamentary republic in Europe.', 'Italy', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(10, 'India, officially the Republic of India, is a country in South Asia.', 'India', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(11, 'Brazil, officially the Federative Republic of Brazil, is the largest country in both South America and Latin America.', 'Brazil', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(12, 'Canada is a country in the northern half of North America.', 'Canada', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(13, 'Mexico, officially the United Mexican States, is a federal republic in the southern part of North America.', 'Mexico', '2010-1-1');
```

- 仅选择排名前十的匹配：

```
SELECT id, title, ts_rank_cd(to_tsvector(body), query) AS rank  
FROM tsearch.pgweb, to_tsquery('america') query  
WHERE query @@ to_tsvector(body)  
ORDER BY rank DESC  
LIMIT 10; 
```

结果显示如下：

```
 id |  title  | rank  
----+---------+------ 
 11 | Brazil  |  .2 
 2 | America |  .1 
 12 | Canada  |  .1 
 13 | Mexico  |  .1 
(4 rows)
```

- 使用标准化排序的相同例子：

```
SELECT id, title, ts_rank_cd(to_tsvector(body), query, 32 /* rank/(rank+1) */ ) AS rank  
FROM tsearch.pgweb, to_tsquery('america') query  
WHERE  query @@ to_tsvector(body)  
ORDER BY rank DESC  
LIMIT 10; 
```

结果显示如下

```
 id |  title  |  rank   
----+---------+---------- 
 11 | Brazil  |  .166667 
 2 | America | .0909091 
 12 | Canada  | .0909091 
 13 | Mexico  | .0909091 
(4 rows)
```

- 使用中文分词法排序查询的例子：

1、创建测试表并插入数据。

```
CREATE TABLE ts_ngram(id int, body text); 
INSERT INTO ts_ngram VALUES(1, '中文'); 
INSERT INTO ts_ngram VALUES(2, '中文检索'); 
INSERT INTO ts_ngram VALUES(3, '检索中文'); 
```

2、精确匹配 。

```
SELECT id, body, ts_rank_cd(to_tsvector('ngram',body), query) AS rank FROM ts_ngram, to_tsquery('中文') query WHERE query @@ to_tsvector(body); 
```

结果显示如下： 

```
id | body | rank  
----+------+------ 
 1 | 中文 |  .1 
(1 row) 
```

3、模糊匹配 

```
SELECT id, body, ts_rank_cd(to_tsvector('ngram',body), query) AS rank FROM ts_ngram, to_tsquery('中文') query WHERE query @@ to_tsvector('ngram',body); 
```

结果显示如下：

```
 id |  body  | rank  
----+----------+------ 
 3 | 检索中文 |  .1 
 1 | 中文   |  .1 
 2 | 中文检索 |  .1 
(3 rows)
```

排序要遍历每个匹配的tsvector，因此资源消耗多，可能会因为I/O限制导致排序慢。可是这是很难避免的，因为实际查询中通常会有大量的匹配。

##### 高亮搜索结果

**功能描述**

搜索结果的理想显示是：列出每篇文档中与搜索相关的部分，并标识为什么与查询相关。搜索引擎能够显示标识了搜索词的文档片段。Vastbase提供了函数ts_headline支持这部分功能。

**语法格式**

```
ts_headline([ config regconfig, ] document text, query tsquery [, options text ]) returns text
```

**参数说明**

- config：ts_headline的输入是带有查询条件的文档，其返回文档中的摘录，在摘录中查询词是高亮显示的。用来解析文档的分词器由config参数指定。如果省略config，则使用default_text_search_config的值所指定的分词器。

- options：指定options字符串时，需由一个或多个option=value对组成，且必须用逗号分隔。options可以是下面的选项：

  - StartSel，StopSel：分隔文档中出现的查询词，以区别于其他摘录词。当包含有空格或逗号时，必须用双引号将字符串引起来。

  - MaxWords，MinWords：定义摘录的最长和最短值。

  - ShortWord：在摘录的开始和结束会丢弃此长度或更短的词。默认值3会消除常见的英语冠词。

  - HighlightAll：布尔标志。如果为真，整个文档将作为摘录。忽略前面三个参数的值。

  - MaxFragments：要显示的文本摘录或片段的最大数量。默认值0表示选择非片段的摘录生成方法。 大于0的值表示选择基于片段的摘录生成。此方法查找带有尽可能多查询词的文本片段，并显示查询词周围的上下文片段。因此，查询词临近每个片段的中间，且查询词两边都有词。每个片段至多有MaxWords，并且长度为ShortWord或更短的词在每一个片段开始和结束被丢弃。如果在文档中没有找到所有的查询词，则文档中开头将显示MinWords单片段。

- 不声明选项时，采用下面的缺省值：

```
StartSel=<b>, StopSel=</b>,
MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,
MaxFragments=0, FragmentDelimiter=" ... "
```

**示例**

```
SELECT ts_headline('english', 
'The most common type of search 
is to find all documents containing given query terms 
and return them in order of their similarity to the 
query.', 
to_tsquery('english', 'query & similarity')); 
```

结果返回如下

```
            ts_headline              
------------------------------------------------------------ 

 containing given <b>query</b> terms 
 and return them in order of their <b>similarity</b> to the 
 <b>query</b>. 
(1 row) 
```

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>   
>
> ts_headline使用原始文档，而不是tsvector摘录，因此使用起来会慢，应慎重使用。

#### 附加功能

##### 处理tsvector

Vastbase提供了用来操作tsvector类型的函数和操作符。

- tsvector || tsvector

  tsvector连接操作符返回一个新的tsvector类型，它综合了两个tsvector中词素和位置信息，并保留词素的位置信息和权重标签。右侧的tsvector的起始位置位于左侧tsvector的最后位置，因此，新生成的tsvector几乎等同于将两个原始文档字串连接后进行to_tsvector操作。（这个等价是不准确的，因为任何从左边tsvector中删除的停用词都不会影响结果，但是，在使用文本连接时，则会影响词素在右侧tsvector中的位置。）
  相较于对文本进行连接后再执行to_tsvector操作，使用tsvector类型进行连接操作的优势在于，可以对文档的不同部分使用不同配置进行解析。因为setweight函数会对给定的tsvector中的语素进行统一设置，如果想要对文档的不同部分设置不同的权重，需要在连接之前对文本进行解析和权重设置。

- setweight(vector tsvector, weight "char") returns tsvector

  setweight返回一个输入tsvector的副本，其中每一个位置都使用给定的权重做了标记。权值可以为A、B、C或D（D是tsvector副本的默认权重，并且不在输出中呈现）。当对tsvector进行连接操作时，这些权重标签将会被保留，文档不同部分以不同的权重进行排序。

- length(vector tsvector) returns integer

  返回vector中的词素的数量。

- strip(vector tsvector) returns tsvector

  返回一个tsvector类型，其中包含输入的tsvector的同义词，但不包含任何位置和权重信息。虽然在相关性排序中，这里返回的tsvector要比未拆分的tsvector的作用小很多，但它通常都比未拆分的tsvector小的多。

**注意事项**

权重标签作用于位置，而不是词素。如果传入的tsvector已经被剥离了位置信息，那么setweight函数将什么都不做。

##### 处理查询

Vastbase提供了函数和操作符用来操作tsquery类型的查询。

- tsquery && tsquery

返回两个给定查询tsquery的与结果。

- tsquery || tsquery

返回两个给定查询tsquery的或结果。

- !! tsquery

返回给定查询tsquery的非结果。

- numnode(query tsquery) returns integer

返回tsquery中的节点数目（词素加操作符），这个函数在检查查询是否有效（返回值大于0），或者只包含停用词（返回值等于0）时，是有用的。例如：

```
SELECT numnode(plainto_tsquery('the any')); 
```

结果显示如下：

```
NOTICE:  text-search query contains only stop words or doesn't contain lexemes, ignored 
CONTEXT:  referenced column: numnode 
 numnode  
--------- 
    0 
```

```
SELECT numnode('foo & bar'::tsquery); 
```

结果显示如下：

```
 numnode 
--------- 
    3
```

- querytree(query tsquery) returns text

返回可用于索引搜索的tsquery部分，该函数对于检测非索引查询是有用的（例如只包含停用词或否定项）。例如:

```
SELECT querytree(to_tsquery('!defined')); 
```

 结果显示如下

```
querytree  
----------- 
 T 
(1 row)
```

##### 查询重写

**功能描述**

ts_rewrite函数族可以从tsquery中搜索一个特定的目标子查询，并在该子查询每次出现的地方都替换为另一个子查询。 实际上这只是通过字串替换而得到的一个特定tsquery版本。目标子查询和替换查询组合起来可以被认为是一个重写规则。一组类似的重写规则可以为搜索提供强大的帮助。例如，可以使用同义词扩大搜索范围（例如，new york, big apple, nyc, gotham）或限制搜索范围在用户直接感兴趣的热点话题上。

**语法格式**

- ts_rewrite的这种形式只适用于一个单一的重写规则：任何出现目标子查询的地方都被无条件替换。

```
ts_rewrite (query tsquery, target tsquery, substitute tsquery) returns tsquery
```

- ts_rewrite的这种形式接受一个起始查询和SQL查询命令。 这里的查询命令是文本字串形式，必须产生两个tsquery列。查询结果的每一行，第一个字段的值（目标子查询） 都会被第二个字段（替代子查询）替换。

```
ts_rewrite (query tsquery, select text) returns tsquery
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> 当多个规则需要重写时，重写顺序非常重要； 因此在实践中需要使用ORDER BY将源查询按照某些字段进行排序。

**示例**

举一个现实生活中天文学上的例子。我们将使用表驱动的重写规则扩大supernovae的查询范围：

1、创建测试表并插入数据。

```
CREATE TABLE tsearch.aliases (id int, t tsquery, s tsquery); 
INSERT INTO tsearch.aliases VALUES(1, to_tsquery('supernovae'), to_tsquery('supernovae|sn')); 
```

2、查询数据。

```
SELECT ts_rewrite(to_tsquery('supernovae & crab'), 'SELECT t, s FROM tsearch.aliases'); 
```

 结果返回如下：

```
      ts_rewrite       
--------------------------------- 
 'crab' & ( 'supernova' | 'sn' )
```

3、可以通过更新表修改重写规则。

```
UPDATE tsearch.aliases 
SET s = to_tsquery('supernovae|sn & !nebulae') 
WHERE t = to_tsquery('supernovae'); 
```

4、查询数据。

```
SELECT ts_rewrite(to_tsquery('supernovae & crab'), 'SELECT t, s FROM tsearch.aliases'); 
```

结果显示如下：

```
        ts_rewrite          
--------------------------------------------- 
 'crab' & ( 'supernova' | 'sn' & !'nebula' )
```

5、需要重写的规则越多，重写操作就越慢。因为它要检查每一个可能匹配的规则。为了过滤明显的非候选规则，可以使用tsquery类型的操作符来实现。在下面的例子中， 我们只选择那些可能与原始查询匹配的规则。

```
SELECT ts_rewrite('a & b'::tsquery, 'SELECT t,s FROM tsearch.aliases WHERE ''a & b''::tsquery @> t'); 
```

 结果显示如下：

```
 ts_rewrite  
\------------ 
 'b' & 'a' 
(1 row) 
```

##### 收集文献统计

**功能描述**

函数ts_stat可用于检查配置和查找候选停用词。

**语法格式**

```
ts_stat(sqlquery text, [ weights text, ]
        OUT word text, OUT ndoc integer,
        OUT nentry integer) returns setof record
```

**参数说明**

- sqlquery：是一个包含SQL查询语句的文本，该SQL查询将返回一个tsvector
- ts_stat执行SQL查询语句并返回一个包含tsvector中每一个不同的语素（词）的统计信息。返回信息包括：
  - word text：词素。
  - ndoc integer：词素在文档（tsvector）中的编号。
  - nentry integer：词素出现的频率。

**示例**

1、创建测试表并插入数据。

```
DROP SCHEMA IF EXISTS tsearch CASCADE;
CREATE SCHEMA tsearch;
CREATE TABLE tsearch.pgweb(id int, body text, title text, last_mod_date date);

INSERT INTO tsearch.pgweb VALUES(1, 'China, officially the People''s Republic of China (PRC), located in Asia, is the world''s most populous state.', 'China', '2010-1-1');  
INSERT INTO tsearch.pgweb VALUES(2, 'America is a rock band, formed in England in 1970 by multi-instrumentalists Dewey Bunnell, Dan Peek, and Gerry Beckley.', 'America', '2010-1-1');   
INSERT INTO tsearch.pgweb VALUES(3, 'England is a country that is part of the United Kingdom. It shares land borders with Scotland to the north and Wales to the west.', 'England', '2010-1-1');   
INSERT INTO tsearch.pgweb VALUES(4, 'Australia, officially the Commonwealth of Australia, is a country comprising the mainland of the Australian continent, the island of Tasmania, and numerous smaller islands.', 'Australia', '2010-1-1'); 
INSERT INTO tsearch.pgweb VALUES(6, 'Japan is an island country in East Asia.', 'Japan', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(7, 'Germany, officially the Federal Republic of Germany, is a sovereign state and federal parliamentary republic in central-western Europe.', 'Germany', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(8, 'France, is a sovereign state comprising territory in western Europe and several overseas regions and territories.', 'France', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(9, 'Italy officially the Italian Republic, is a unitary parliamentary republic in Europe.', 'Italy', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(10, 'India, officially the Republic of India, is a country in South Asia.', 'India', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(11, 'Brazil, officially the Federative Republic of Brazil, is the largest country in both South America and Latin America.', 'Brazil', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(12, 'Canada is a country in the northern half of North America.', 'Canada', '2010-1-1');
INSERT INTO tsearch.pgweb VALUES(13, 'Mexico, officially the United Mexican States, is a federal republic in the southern part of North America.', 'Mexico', '2010-1-1');
```

2、如果设置了权重条件，只有标记了对应权重的词素才会统计频率。例如，在一个文档集中检索使用频率最高的十个单词。

```
SELECT * FROM ts_stat('SELECT to_tsvector(''english'',title) FROM tsearch.pgweb WHERE id < 10') ORDER BY nentry DESC, ndoc DESC, word LIMIT 10;
```

结果显示如下：

```
   word    | ndoc | nentry 
-----------+------+--------
 america   |    1 |      1
 australia |    1 |      1
 china     |    1 |      1
 england   |    1 |      1
 franc     |    1 |      1
 germani   |    1 |      1
 itali     |    1 |      1
 japan     |    1 |      1
(8 rows)
```

3、同样的情况，但是只计算权重为A或者B的单词使用频率。

```
SELECT * FROM ts_stat('SELECT to_tsvector(''english'', title) FROM tsearch.pgweb WHERE id < 10', 'a') ORDER BY nentry DESC, ndoc DESC, word LIMIT 10;
```

结果显示如下：

```
 word | ndoc | nentry 
------+------+--------
(0 rows)
```

#### 解析器

**功能描述**

文本搜索解析器负责将原文档文本分解为多个token，并标识每个token的类型。这里的类型集由解析器本身定义。注意，解析器并不修改文本，它只是确定合理的单词边界。由于这一限制，人们更需要定制词典，而不是为每个应用程序定制解析器。

目前Vastbase提供了三个内置的解析器，分别为pg_catalog.default、pg_catalog.ngram、pg_catalog.pound，其中pg_catalog.default适用于英文分词场景，pg_catalog.ngram、pg_catalog.pound是为了支持中文全文检索功能新增的两种解析器，适用于中文及中英混合分词场景。

内置解析器pg_catalog.default，它能识别23种token类型，如下表所示：

| 别名            | 描述                                     | 示例                                                  |
| :-------------- | :--------------------------------------- | :---------------------------------------------------- |
| asciiword       | Word, all ASCII letters                  | elephant                                              |
| word            | Word, all letters                        | mañana                                                |
| numword         | Word, letters and digits                 | beta1                                                 |
| asciihword      | Hyphenated word, all ASCII               | up-to-date                                            |
| hword           | Hyphenated word, all letters             | lógico-matemática                                     |
| numhword        | Hyphenated word, letters and digits      | Vastbase-beta1                                        |
| hword_asciipart | Hyphenated word part, all ASCII          | Vastbase in the context Vastbase-beta1                |
| hword_part      | Hyphenated word part, all letters        | lógico or matemática in the context lógico-matemática |
| hword_numpart   | Hyphenated word part, letters and digits | beta1 in the context Vastbase-beta1                   |
| email           | Email address                            | "foo@example.com"                                     |
| protocol        | Protocol head                            | http://                                               |
| url             | URL                                      | example.com/stuff/index.html                          |
| host            | Host                                     | example.com                                           |
| url_path        | URL path                                 | /stuff/index.html, in the context of a URL            |
| file            | File or path name                        | /usr/local/foo.txt, if not within a URL               |
| sfloat          | Scientific notation                      | -1.23E+56                                             |
| float           | Decimal notation                         | -1.234                                                |
| int             | Signed integer                           | -1234                                                 |
| uint            | Unsigned integer                         | 1234                                                  |
| version         | Version number                           | 8.3.0                                                 |
| tag             | XML tag                                  | \<a href="dictionaries.html">                         |
| entity          | XML entity                               | &amp；                                                |
| blank           | Space symbols                            | 无法识别的空白或标点符号                              |

**注意事项**

- 对于解析器来说，一个“字母”的概念是由数据库的语言区域设置，即lc_ctype设置决定的。只包含基本ASCII字母的词被报告为一个单独的token类型，因为这类词有时需要被区分出来。大多数欧洲语言中，对token类型word和asciiword的处理方法是类似的。

- email不支持某些由RFC 5322定义的有效电子邮件字符。具体来说，可用于email用户名的非字母数字字符仅包含句号、破折号和下划线。

解析器可能对同一内容进行重叠token。例如，包含连字符的单词将作为一个整体进行报告，其组件也会分别被报告。

```
SELECT alias, description, token FROM ts_debug('english','foo-bar-beta1'); 
```

结果显示如下：

```
   alias    |        description         |   token    
-----------------+------------------------------------------+--------------- 
 numhword     | Hyphenated word, letters and digits    | foo-bar-beta1 
 hword_asciipart | Hyphenated word part, all ASCII      | foo 
 blank      | Space symbols               | - 
 hword_asciipart | Hyphenated word part, all ASCII      | bar 
 blank      | Space symbols               | - 
 hword_numpart  | Hyphenated word part, letters and digits | beta1
```

这种行为是有必要的，因为它支持搜索整个复合词和各组件。这里是另一个例子：

```
SELECT alias, description, token FROM ts_debug('english','http://example.com/stuff/index.html'); 
```

结果显示如下：

```
 alias  |  description  |       token        
----------+---------------+------------------------------ 
 protocol | Protocol head | http:// 
 url    | URL      | example.com/stuff/index.html 
 host   | Host      | example.com 
 url_path | URL path    | /stuff/index.html
```

N-gram是一种机械分词方法，适用于无语义中文分词场景。N-gram分词法可以保证分词的完备性，但是为了照顾所有可能，把很多不必要的词也加入到索引中，导致索引项增加。N-gram支持中文编码包括GBK、UTF-8。内置6种token类型，如[表2](#表2) 所示。

表2 token类型<a id="表2"></a>

| 别名        | 描述            |
| :---------- | :-------------- |
| zh_words    | chinese words   |
| en_word     | english word    |
| numeric     | numeric data    |
| alnum       | alnum string    |
| grapsymbol  | graphic symbol  |
| multisymbol | multiple symbol |

Pound是一种固定格式分词方法，适用于无语意但待解析文本以固定分隔符分割开来的中英文分词场景。支持中文编码包括GBK、UTF8，支持英文编码包括ASCII。内置6种token类型，如[表3](#表3)所示；支持5种分隔符，如[表4](表4)所示，在用户不进行自定义设置的情况下分隔符默认为“#”。Pound限制单个token长度不能超过256个字符。

表3 token类型<a id="表3"></a>

| 别名        | 描述            |
| :---------- | :-------------- |
| zh_words    | chinese words   |
| en_word     | english word    |
| numeric     | numeric data    |
| alnum       | alnum string    |
| grapsymbol  | graphic symbol  |
| multisymbol | multiple symbol |

表4 分隔符类型<a id="表4"></a>

| 分隔符 | 描述              |
| :----- | :---------------- |
| @      | Special character |
| #      | Special character |
| $      | Special character |
| %      | Special character |
| /      | Special character |

#### 词典

##### 词典概述

词典用于定义停用词（stop words），即全文检索时不搜索哪些词。

词典还可以用于对同一个词的不同形式进行规范化，这样同一个词的不同派生形式都可以进行匹配。规范化后的词称为词位（lexeme）。

除了提高检索质量外，词的规范化和删除停用词可以减少文档tsvector格式的大小， 从而提高性能。词的规范化和删除停用词并不总是具有语言学意义，用户可以根据应用环境在词典定义文件中自定义规范化和删除规则。

一个词典是一个程序，接收标记（token）作为输入，并返回：

- 如果token在词典中已知，返回对应lexeme数组（注意，一个标记可能对应多个lexeme）。

- 一个lexeme。一个新token会代替输入token被传递给后继词典（当前词典可被称为过滤词典）。

- 如果token在词典中已知，但它是一个停用词，返回空数组。

- 如果词典不能识别输入的token，返回NULL。

Vastbase提供了多种语言的预定义字典，同时提供了五种预定义的词典模板，分别是Simple，Synonym，Thesaurus，Ispell和Snowball，可用于创建自定义参数的新词典。

在使用全文检索时，建议用户：

- 可以在文本搜索配置中定义一个解析器，以及一组用于处理该解析器的输出标记词典。对于解析器返回的每个标记类型，可以在配置中指定不同的词典列表进行处理。当解析器输出一种类型的标记后，在对应列表的每个字典中会查阅该标记，直到某个词典识别它。如果它被识别为一个停用词， 或者没有任何词典识别，该token将被丢弃，即不被索引或检索到。通常情况下，第一个返回非空结果的词典决定了最终结果，后继词典将不会继续处理。但是一个过滤类型的词典可以依据规则替换输入token，然后将替换后的token传递给后继词典进行处理。

- 配置字典列表的一般规则是，第一个位置放置一个应用范围最小的、最具体化定义的词典，其次是更一般化定义的词典， 最后是一个普适定义的词典，比如Snowball词干词典或Simple词典。在下面例子中，对于一个针对天文学的文本搜索配置astro_en，可以定义标记类型asciiword（ASCII词）对应的词典列表为：天文术语的Synonym同义词词典， Ispell英语词典和Snowball 英语词干词典。

```
ALTER TEXT SEARCH CONFIGURATION astro_en 
 ADD MAPPING FOR asciiword WITH astro_syn, english_ispell, english_stem;
```

过滤类型的词典可以放置在词典列表中除去末尾的任何地方，放置在末尾时是无效的。使用这些词典对标记进行部分规范化，可以有效简化后继词典的处理。

##### 停用词

**功能描述**

停用词是很常见的词，几乎出现在每一个文档中，并且没有区分值。因此，在全文搜索的语境下可忽视它们。停用词处理逻辑和词典类型相关。例如，Ispell词典会先对标记进行规范化，然后再查看停用词表，而Snowball词典会最先检查输入标记是否为停用词。

**示例**

- 每个英文文本包含像a和the的单词，因此没必要将它们存储在索引中。然而，停用词影响tsvector中的位置，同时位置也会影响相关度。

```
SELECT to_tsvector('english','in the list of stop words'); 
```

结果显示如下：

```
    to_tsvector 
---------------------------- 
 'list':3 'stop':5 'word':6
```

- 位置1、2、4是停用词，所以不显示。为包含和不包含停用词的文档计算出的排序是完全不同的：

```
vastbase=# SELECT ts_rank_cd (to_tsvector('english','in the list of stop words'), to_tsquery('list & stop')); 

 ts_rank_cd 
------------ 
    .05 
```

```
vastbase=# SELECT ts_rank_cd (to_tsvector('english','list stop words'), to_tsquery('list & stop')); 

 ts_rank_cd 
------------ 
     .1
```

##### Simple词典

**功能描述**

Simple词典首先将输入标记转换为小写字母，然后检查停用词表。如果识别为停用词则返回空数组，即表示该标记会被丢弃。否则，输入标记的小写形式作为规范化后的lexeme返回。此外，Simple词典可通过设置参数Accept为false（默认值true），将非停用词报告为未识别，传递给后继词典继续处理。

**注意事项**

- 大多数词典的功能依赖于词典定义文件，词典定义文件名仅支持小写字母、数字、下划线组合。

- 临时模式pg_temp下不允许创建词典。

- 词典定义文件的字符集编码必须为UTF-8格式。实际应用时，如果与数据库的字符编码格式不一致，在读入词典定义文件时会进行编码转换。

- 通常情况下，每个session仅读取词典定义文件一次，当且仅当在第一次使用该词典时。需要修改词典文件时，可通过ALTER TEXT SEARCH DICTIONARY命令进行词典定义文件的更新和重新加载。

**示例**

1、创建Simple词典。

```
 CREATE TEXT SEARCH DICTIONARY public.simple_dict ( 
   TEMPLATE = pg_catalog.simple, 
   STOPWORDS = english 
);
```

其中，停用词表文件全名为english.stop。关于创建simple词典的语法和更多参数，请参见章节“CREATE TEXT SEARCH DICTIONARY”。

2、使用Simple词典。

```
SELECT ts_lexize('public.simple_dict','YeS'); 
```

结果显示如下

```
 ts_lexize  
----------- 
 {yes} 
(1 row) 
```

```
 SELECT ts_lexize('public.simple_dict','The'); 
```

结果显示如下：

```
 ts_lexize 
-----------
 {}
(1 row)
```

3、设置参数ACCEPT=false，使Simple词典返回NULL，而不是返回非停用词的小写形式。

```
ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false ); 
```

查询验证。

```
SELECT ts_lexize('public.simple_dict','YeS'); 
```

结果显示如下：

```
 ts_lexize  
----------- 
(1 row) 
```

 查询验证。

```
SELECT ts_lexize('public.simple_dict','The'); 
```

结果显示如下：

```
 ts_lexize  
----------- 
 {} 
(1 row)
```

#####  Synonym词典

**功能描述**

Synonym词典用于定义、识别token的同义词并转化，不支持词组（词组形式的同义词可用Thesaurus词典定义，详细请参见章节“Thesaurus词典”）。

**示例**

- 1、Synonym词典可用于解决语言学相关问题，例如，为避免使单词"Paris"变成"pari"，可在Synonym词典文件中定义一行"Paris paris"，并将该词典放置在预定义的english_stem词典之前。

```
SELECT * FROM ts_debug('english', 'Paris'); 
```

结果返回如下：  

```
alias  |  description  | token |  dictionaries  |  dictionary  | lexemes  
-----------+-----------------+-------+----------------+--------------+--------- 
 asciiword | Word, all ASCII | Paris | {english_stem} | english_stem | {pari} 
(1 row) 
```

2、创建词典，FILEPATH以dicts文件实际目录为准。

```
CREATE TEXT SEARCH DICTIONARY my_synonym ( 
  TEMPLATE = synonym, 
  SYNONYMS = my_synonyms, 
  FILEPATH = 'file:///home/dicts/'  
); 
```

3、修改词典。

```
 ALTER TEXT SEARCH CONFIGURATION english 
  ALTER MAPPING FOR asciiword 
  WITH my_synonym, english_stem; 
```

4、 查询验证。

```
SELECT * FROM ts_debug('english', 'Paris'); 
```

结果显示如下：

```
  alias  |  description  | token |    dictionaries     | dictionary | lexemes  
-----------+-----------------+-------+---------------------------+------------+--------- 
 asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {paris} 
(1 row) 
```

5、 查询验证。

```
SELECT * FROM ts_debug('english', 'paris'); 
```

结果显示如下：

```
 alias  |  description  | token |    dictionaries     | dictionary | lexemes  
-----------+-----------------+-------+---------------------------+------------+--------- 
 asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {paris} 
(1 row) 
```

6、修改词典。

```
ALTER TEXT SEARCH DICTIONARY my_synonym ( CASESENSITIVE=true); 
```

7、查询验证。

```
SELECT * FROM ts_debug('english', 'Paris'); 
```

结果显示如下：

```
  alias  |  description  | token |    dictionaries     | dictionary | lexemes  
-----------+-----------------+-------+---------------------------+------------+--------- 
 asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {paris} 
(1 row) 
```

8、查询验证 。

```
SELECT * FROM ts_debug('english', 'paris'); 
```

结果显示如下：

```
  alias  |  description  | token |    dictionaries     | dictionary | lexemes  
----------+-----------------+-------+---------------------------+------------+--------- 
 asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {pari} 
(1 row) 
```

 

其中，同义词词典文件全名为my_synonyms.syn，所在目录为当前连接数据库主节点的/home/dicts/（以实际路径为准）下。关于创建词典的语法和更多参数，请参见章节“ALTER TEXT SEARCH DICTIONARY”。

- 星号（*）可用于词典文件中的同义词结尾，表示该同义词是一个前缀。在to_tsvector()中该星号将被忽略，但在to_tsquery()中会匹配该前缀并对应输出结果（参照章节“处理查询”）。

假设词典文件synonym_sample.syn内容如下：

```
postgres     pgsql 
postgresql    pgsql  
postgre pgsql  
gogle  googl  
indices index*
```

1、创建并使用词典。

```
CREATE TEXT SEARCH DICTIONARY syn ( 
  TEMPLATE = synonym, 
  SYNONYMS = synonym_sample 
); 
```

2、验证结果。

```
SELECT ts_lexize('syn','indices'); 
```

结果返回如下：

```
 ts_lexize  
----------- 
 {index} 
(1 row) 
```

3、创建词典并修改。

```
CREATE TEXT SEARCH CONFIGURATION tst (copy=simple); 
ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword WITH syn; 
```

4、验证结果。

```
SELECT to_tsvector('tst','indices'); 
```

结果返回如下： 

```
to_tsvector  
------------- 
 'index':1 
(1 row) 

 
```

```
 SELECT to_tsquery('tst','indices'); 
```

结果返回如下：

```
 to_tsquery  
------------ 
 'index':* 
(1 row) 
```

```
SELECT 'indexes are very useful'::tsvector; 
```
结果返回如下：

```
      tsvector        
--------------------------------- 
 'are' 'indexes' 'useful' 'very' 
(1 row) 
```

```
SELECT 'indexes are very useful'::tsvector @@ to_tsquery('tst','indices'); 
```

结果返回如下：

```
 ?column?  
---------- 
 t 
(1 row)
```

##### **Thesaurus词典**

**功能描述**

Thesaurus词典，也叫做分类词典（缩写为TZ），是一组定义了词以及词组间关系的集合，包括广义词（BT）、狭义词（NT）、首选词、非首选词、相关词等。根据词典文件中的定义，TZ词典用一个指定的短语替换对应匹配的所有短语，并且可选择保留原始短语进行索引。TZ词典实际上是Synonym词典的一个扩展，增加了短语支持。

**注意事项**

- 由于TZ词典需要识别短语，所以在处理过程中必须保存当前状态并与解析器进行交互，以决定是否处理下一个token或是结束当前识别。此外，TZ词典配置时需谨慎，如果设置TZ词典仅处理asciiword类型的token，则类似one 7的分类词典定义将不会生效，因为uint类型的token不会传给TZ词典处理。

- 在索引期间要用到分类词典，因此分类词典参数中的任何变化都要求重新索引。对于其他大多数类型的词典来说，类似添加或删除停用词这种修改并不需要强制重新索引。

**示例**

1、创建一个名为thesaurus_astro的TZ词典。

以一个简单的天文学词典thesaurus_astro为例，其中定义了两组天文短语及其同义词如下：

```
supernovae stars : sn  
crab nebulae : crab
```

执行如下语句创建TZ词典：

```
CREATE TEXT SEARCH DICTIONARY thesaurus_astro ( 
  TEMPLATE = thesaurus, 
  DictFile = thesaurus_astro, 
  Dictionary = pg_catalog.english_stem, 
  FILEPATH = 'file:///home/dicts/' 
);
```

其中，词典定义文件全名为thesaurus_astro.ths，所在目录为当前连接数据库主节点的/home/dicts/下 。子词典pg_catalog.english_stem是预定义的Snowball类型的英语词干词典，用于规范化输入词，子词典自身相关配置（例如停用词等）不在此处显示。关于创建词典的语法和更多参数，请参见12.19.53CREATE TEXT SEARCH DICTIONARY。

2、创建词典后，将其绑定到对应文本搜索配置中需要处理的token类型上：

```
ALTER TEXT SEARCH CONFIGURATION russian 
  ALTER MAPPING FOR asciiword, asciihword, hword_asciipart 
  WITH thesaurus_astro, english_stem;
```

3、使用TZ词典。

- 测试TZ词典。

ts_lexize函数对于测试TZ词典作用不大，因为该函数是按照单个token处理输入。可以使用plainto_tsquery、to_tsvector、to_tsquery函数测试TZ词典，这些函数能够将输入分解成多个token（to_tsquery函数需要将输入加上引号）。

```
SELECT plainto_tsquery('russian','supernova star'); 
```

结果显示如下： 

```
plainto_tsquery  
----------------- 
 'sn' 
(1 row) 
```

```
SELECT to_tsvector('russian','supernova star'); 
```

 结果显示如下：

```
to_tsvector  
------------- 
 'sn':1 
(1 row) 
```

```
    SELECT to_tsquery('russian','''supernova star'''); 
```

 结果显示如下：

```
to_tsquery  
------------ 
 'sn' 
(1 row) 
```

其中，supernova star匹配了词典thesaurus_astro定义中的supernovae stars，这是因为在thesaurus_astro词典定义中指定了Snowball类型的子词典english_stem，该词典移除了e和s。

- 如果同时需要索引原始短语，只要将其同时放置在词典定义文件中对应定义的右侧即可（在thesaurus_astro文件中修改），如下：

```
supernovae stars : sn supernovae stars  
```
数据库中执行以下语句修改词典并查询验证。

```
 ALTER TEXT SEARCH DICTIONARY thesaurus_astro ( 
  DictFile = thesaurus_astro, 
  FILEPATH = 'file:///home/dicts/'); 
  SELECT plainto_tsquery('russian','supernova star'); 
```

结果返回如下：

```
    plainto_tsquery     
----------------------------- 
 'sn' & 'supernova' & 'star' 
(1 row)
```

#####  Ispell词典

**功能描述**

Ispell词典模板支持词法词典，它可以把一个词的各种语言学形式规范化成相同的词位。比如，一个Ispell英语词典可以匹配搜索词bank的词尾变化和词形变化，如banking、banked、banks、banks'和bank's等。

Vastbase不提供任何预定义的Ispell类型词典或词典文件。dict文件和affix文件支持多种开源词典格式，包括Ispell、MySpell和Hunspell等。

**示例**

1、获取词典定义文件和词缀文件。

用户可以使用开源词典，直接获取的开源词典后缀名可能为.aff和.dic，此时需要将扩展名改为.affix和.dict。此外，对于某些词典文件，还需要使用下面的命令把字符转换成 UTF-8 编码，比如挪威语词典：

```
iconv -f ISO_8859-1 -t UTF-8 -o nn_no.affix nn_NO.aff  
iconv -f ISO_8859-1 -t UTF-8 -o nn_no.dict nn_NO.dic
```

2、创建Ispell词典。

```
CREATE TEXT SEARCH DICTIONARY norwegian_ispell ( 
  TEMPLATE = ispell, 
  DictFile = nn_no, 
  AffFile = nn_no, 
  FilePath = 'file:///home/dicts' 
);
```

其中，词典文件全名为nn_no.dict和nn_no.affix，所在目录为当前连接数据库主节点的/home/dicts/下 。关于创建词典的语法和更多参数，请参见章节“CREATE TEXT SEARCH DICTIONARY”。

3、使用Ispell词典进行复合词拆分。

```
SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk'); 
```

结果显示如下：

```
   ts_lexize    
--------------------- 
 {sjokolade,fabrikk} 
(1 row) 
```

>  <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> MySpell不支持复合词，Hunspell对复合词有较好的支持。Vastbase仅支持Hunspell中基本的复合词操作。通常情况下，Ispell词典能够识别的词是一个有限集合，其后应该配置一个更广义的词典，例如一个可以识别所有词的Snowball词典。

##### Snowball词典

Snowball词典模板支持词干分析词典，基于Martin Porter的Snowball项目，内置有许多语言的词干分析算法。Vastbase中预定义有多种语言的Snowball词典，可通过系统表章节“PG_TS_DICT”查看预定义的词干分析词典以及支持的语言词干分析算法。

无论是否可以简化，Snowball词典将标示所有输入为已识别，因此它应当被放置在词典列表的最后。把Snowball词典放在任何其他词典前面会导致后继词典失效，因为输入token不会通过Snowball词典进入到下一个词典。

关于Snowball词典的语法，请参见章节“CREATE TEXT SEARCH DICTIONARY”。

##### 配置示例

文本搜索配置（Text Search Configuration），指定了将文档转换成tsvector过程中所必需的组件：

- 解析器，用于把文本分解成标记token；

- 词典列表，用于将每个token转换成词位lexeme。

每次to_tsvector或to_tsquery函数调用时，都需要指定一个文本搜索配置来指定具体的处理过程。GUC参数章节“default_text_search_config”指定了默认的文本搜索配置，当文本搜索函数中没有显式指定文本搜索配置参数时，将会使用该默认值进行处理。

Vastbase中预定义有一些可用的文本搜索配置，用户也可创建自定义的文本搜索配置。此外，为了便于管理文本搜索对象，还提供有多个vsql元命令，可以显示有关文本搜索对象的信息（详细请参见《工具参考》中“客户端工具 >元命令参考”章节）。

**操作步骤**

1、创建一个文本搜索配置ts_conf，复制预定义的文本搜索配置english。

```
CREATE TEXT SEARCH CONFIGURATION ts_conf ( COPY = pg_catalog.english ); 
```

2、创建Synonym词典。

假设同义词词典定义文件pg_dict.syn内容如下：

```
postgres   pg  
pgsql    pg  
postgresql  pg
```

执行如下语句创建Synonym词典：

```
CREATE TEXT SEARCH DICTIONARY pg_dict ( 
   TEMPLATE = synonym, 
   SYNONYMS = pg_dict, 
   FILEPATH = 'file:///home/dicts' 
 );
```

3、创建一个Ispell词典english_ispell（词典定义文件来自开源词典）。

```
CREATE TEXT SEARCH DICTIONARY english_ispell ( 
  TEMPLATE = ispell, 
  DictFile = english, 
  AffFile = english, 
  StopWords = english, 
  FILEPATH = 'file:///home/dicts'  
);
```

4、设置文本搜索配置ts_conf，修改某些类型的token对应的词典列表。关于token类型的详细信息，请参见章节“解析器”。

```
ALTER TEXT SEARCH CONFIGURATION ts_conf 
  ALTER MAPPING FOR asciiword, asciihword, hword_asciipart, 
           word, hword, hword_part 
  WITH pg_dict, english_ispell, english_stem;
```

5、在文本搜索配置中，选择设置不索引或搜索某些token类型。

```
ALTER TEXT SEARCH CONFIGURATION ts_conf 
 DROP MAPPING FOR email, url, url_path, sfloat, float;
```

6、使用文本检索调测函数ts_debug()对所创建的词典配置ts_conf进行测试。

```
SELECT * FROM ts_debug('ts_conf', ' 
PostgreSQL, the highly scalable, SQL compliant, open source object-relational 
database management system, is now undergoing beta testing of the next 
version of our software. 
');
```

7、可以设置当前session使用ts_conf作为默认的文本搜索配置。此设置仅在当前session有效。

```
 \dF+ ts_conf 
```

结果返回如下：

```
  Text search configuration "public.ts_conf" 
Parser: "pg_catalog.default" 
   Token    |       Dictionaries        
-----------------+------------------------------------- 
 asciihword    | pg_dict,english_ispell,english_stem 
 asciiword    | pg_dict,english_ispell,english_stem 
 file       | simple 
 host       | simple 
 hword      | pg_dict,english_ispell,english_stem 
 hword_asciipart | pg_dict,english_ispell,english_stem 
 hword_numpart  | simple 
 hword_part    | pg_dict,english_ispell,english_stem 
 int       | simple 
 numhword     | simple 
 numword     | simple 
 uint       | simple 
 version     | simple 
 word       | pg_dict,english_ispell,english_stem 
```

```
SET default_text_search_config = 'public.ts_conf'; 
SHOW default_text_search_config; 
 default_text_search_config  
---------------------------- 
 public.ts_conf 
(1 row)
```

#### 测试和调试文本搜索

##### 分词器测试

**功能描述**

函数ts_debug允许简单测试文本搜索分词器。

**语法格式**

```
ts_debug([ config regconfig, ] document text,
         OUT alias text,
         OUT description text,
         OUT token text,
         OUT dictionaries regdictionary[],
         OUT dictionary regdictionary,
         OUT lexemes text[])
         returns setof record
```

**参数说明**

ts_debug为文本解析器标识的每个token返回一行记录。记录中的列分别是：

- alias：text类型，token的别名。
- description：text类型，token的描述。
- token：text类型，token的文本内容。
- dictionaries：regdictionary数组类型，是分词器为token选定的词典。
- dictionary：regdictionary类型，用来识别token的词典。如果为空，则不做识别。
- lexemes：text数组类型，词典识别token时生成的词素。如果为空，则不生成词素。空数组（{}）意味着token将被识别成停用词。

**注意事项**

ts_debug显示document的每个token信息，token是由解析器生成，由指定的词典进行处理。如果忽略对应参数，则使用config指定的分词器或者default_text_search_config指定的分词器。

**示例**

```
SELECT * FROM ts_debug('english','a fat  cat sat on a mat - it ate a fat rats'); 
```

结果返回如下：

```
  alias  |  description  | token |  dictionaries  |  dictionary  | lexemes  
-----------+-----------------+-------+----------------+--------------+--------- 
 asciiword | Word, all ASCII | a   | {english_stem} | english_stem | {} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | fat  | {english_stem} | english_stem | {fat} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | cat  | {english_stem} | english_stem | {cat} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | sat  | {english_stem} | english_stem | {sat} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | on   | {english_stem} | english_stem | {} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | a   | {english_stem} | english_stem | {} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | mat  | {english_stem} | english_stem | {mat} 
 blank   | Space symbols  |    | {}       |        |  
 blank   | Space symbols  | -   | {}       |        |  
 asciiword | Word, all ASCII | it   | {english_stem} | english_stem | {} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | ate  | {english_stem} | english_stem | {ate} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | a   | {english_stem} | english_stem | {} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | fat  | {english_stem} | english_stem | {fat} 
 blank   | Space symbols  |    | {}       |        |  
 asciiword | Word, all ASCII | rats  | {english_stem} | english_stem | {rat} 
(24 rows)
```



##### 解析器测试

- 函数ts_parse可以直接测试文本搜索解析器。

```
ts_parse(parser_name text, document text,
         OUT tokid integer, OUT token text) returns setof record
```

ts_parse解析指定的document并返回一系列的记录，一条记录代表一个解析生成的token。每条记录包括标识token类型的tokid及token文本。例如：

```
SELECT * FROM ts_parse('default', '123 - a number');
```

 结果返回如下：

```
tokid | token
-------+--------
    22 | 123
    12 |
    12 | -
     1 | a
    12 |
     1 | number
(6 rows)
```

- 函数ts_token_type返回指定解析器的token类型及其描述信息。

```
ts_token_type(parser_name text, OUT tokid integer,
              OUT alias text, OUT description text) returns setof record
```

ts_token_type返回一个表，这个表描述了指定解析器可以识别的每种token类型。对于每个token类型，表中给出了整数类型的tokid–用于解析器标记对应的token类型；alias——命名分词器命令中的token类型及简单描述。例如：

```
SELECT * FROM ts_token_type('default'); 
```

结果返回如下：

```
 tokid |    alias    |        description         
-------+-----------------+------------------------------------------ 
   1 | asciiword    | Word, all ASCII 
   2 | word       | Word, all letters 
   3 | numword     | Word, letters and digits 
   4 | email      | Email address 
   5 | url       | URL 
   6 | host       | Host 
   7 | sfloat      | Scientific notation 
   8 | version     | Version number 
   9 | hword_numpart  | Hyphenated word part, letters and digits 
  10 | hword_part    | Hyphenated word part, all letters 
  11 | hword_asciipart | Hyphenated word part, all ASCII 
  12 | blank      | Space symbols 
  13 | tag       | XML tag 
  14 | protocol     | Protocol head 
  15 | numhword     | Hyphenated word, letters and digits 
  16 | asciihword    | Hyphenated word, all ASCII 
  17 | hword      | Hyphenated word, all letters 
  18 | url_path     | URL path 
  19 | file       | File or path name 
  20 | float      | Decimal notation 
  21 | int       | Signed integer 
  22 | uint       | Unsigned integer 
  23 | entity      | XML entity 
(23 rows)
```



##### 词典测试

**功能描述**

函数ts_lexize用于进行词典测试。

**注意事项**

ts_lexize(dict regdictionary, token text) returns text[]如果输入的token可以被词典识别，那么ts_lexize返回词素的数组；如果token可以被词典识别到它是一个停用词，则返回空数组；如果是一个不可识别的词则返回NULL。

**示例**

```
 SELECT ts_lexize('english_stem', 'stars'); 
```

结果返回如下： 

```
ts_lexize 
----------- 
 {star} 
```
查询不可识别值。

```
SELECT ts_lexize('english_stem', 'a'); 
```

结果返回如下： 

```
ts_lexize 
----------- 
 {}
```

### AI特性

#### AI4DB数据库自治运维

**功能描述**

AI4DB主要用于对数据库进行自治运维和管理，从而帮助数据库运维人员减少运维工作量。在实现上，DBMind的AI4DB框架具有监控和服务化的性质，同时也提供即时AI工具包，提供开箱即用的AI运维功能（如索引推荐）。AI4DB的监控平台以开源的Prometheus为主，DBMind提供监控数据生产者exporter, 可与Prometheus平台完成对接。DBMind的AI4DB服务架构如下图所示：

<div align="left"><img src="image/AI4DB架构.png" style="zoom:100%")</div>  

**组件说明**

- DBMind Service: DBMind后台服务，可用于定期离线计算，包括慢SQL根因分析、时序预测等；
- Prometheus-server: Prometheus 监控指标存储的服务器；
- metadatabase: DBMind在离线计算结束后，将计算结果存储在此处，支持openGauss、SQLite等数据库；
- client: 用户读取DBMind离线计算结果的客户端，目前仅实现命令行客户端；若采用openGauss等数据库存储计算DBMind计算结果，则用户可以自行配置Grafana等可视化工具对该结果进行可视化；
- openGauss-exporter: 用户从openGauss数据库节点上采集监控指标，供DBMind服务进行计算；
- node-exporter: Prometheus官方提供的exporter, 可用于监控该节点的系统指标，如CPU和内存使用情况；
- reprocessing-exporter: 用于对Prometheus采集到的指标进行二次加工处理，例如计算CPU使用率等。

**环境配置**

DBMind外置AI功能需要运行在Python 3.6版本及以上，需要的第三方依赖包记录在AI功能根目录（$GAUSSHOME/bin/dbmind）的requirements.txt文件中（包括requirements-x86.txt与requirements-arrch64.txt，用户可根据自己平台类型选择）中，可以通过pip install命令安装依赖，如：

```
pip install requirements-x86.txt
```

如果用户没有安装齐全所需的依赖，则当用户执行gs_dbmind命令时，会再次提醒用户安装第三方依赖。需要注意，该文件提供了DBMind所需的第三方依赖，若用户环境存在第三方包冲突等情况，可由用户根据实际情况进行处理。

##### DBMIND模式说明

**功能描述**

用户可通过gs_dbmind命令调用AI4DB的全部功能，该命令可实现下列基本功能：

- 服务功能：service子命令，包括创建并初始化配置目录、启动后台服务、关闭后台服务等；
- 调用组件：component子命令，AI4DB功能（如索引推荐、参数调优等）可通过该模式进行即时调用；
- 设置参数：set子命令，通过该命令，可以一键修改配置目录中的配置文件值；当然，用户也可以通过文本编辑器进行手动修改；

**语法格式**

用户可以通过 –help 选项获得模式的帮助信息，例如：

```
gs_dbmind --help
```

```
usage: [-h] [--version] {service,set,component} ...

openGauss DBMind: An autonomous platform for openGauss

optional arguments:
  -h, --help            show this help message and exit
  --version             show program's version number and exit

available subcommands:
  {service,set,component}
                        type '<subcommand> -h' for help on a specific subcommand
    service             send a command to DBMind to change the status of the service
    set                 set a parameter
    component           pass command line arguments to each sub-component.
```

**参数说明**

| 参数      | 参数说明             |
| :-------- | :------------------- |
| -h, –help | 帮助命令             |
| –version  | 版本号               |
| service   | 服务功能相关的子命令 |
| component | 调用组件的子命令     |
| set       | 修改配置文件的子命令 |

###### SERVICE子命令

**功能描述**

该子命令可用于对配置目录进行初始化，同时也可以实现启动和停止后台任务。

**语法格式**

用户可以通过 –help 选项获得该模式的帮助信息。

```
gs_dbmind service --help
```

```
usage: service [-h] -c DIRECTORY [--only-run {slow_query_diagnosis,forecast}] [--interactive | --initialize] {setup,start,stop}

positional arguments:
  {setup,start,stop}
                        perform an action for service

optional arguments:
  -h, --help            show this help message and exit
  -c DIRECTORY, --conf DIRECTORY
                        set the directory of configuration files
  --only-run {slow_query_diagnosis,forecast}
                        explicitly set a certain task running in the backend
  --interactive         configure and initialize with interactive mode
  --initialize          initialize and check configurations after configuring.
```

**参数说明**

| 参数         | 参数说明           | 取值范围                                                     |
| :----------- | :----------------- | :----------------------------------------------------------- |
| action       | 动作参数           | setup：初始化配置目录。start：服务启动。stop：服务停止。     |
| -c，–conf    | 配置文件目录地址   | -                                                            |
| –initialize  | 配置参数初始化     | -                                                            |
| –interactive | 交互式输入配置参数 | -                                                            |
| –only-run    | 选择只运行的模块   | forecast：预测模块。slow_query_diagnosis：慢SQL根因分析模块。 |
| -h, –help    | 帮助命令           | -                                                            |

**配置目录初始化**

用户可通过 gs_dbmind service setup 子命令进行配置目录的初始化。该配置文件中可包括DBMind的配置文件、日志等内容。该目录中的部分文件说明：

- dbmind.conf：DBMind的参数配置文件，用户可通过 gs_dbmind set 命令进行修改，也可通过文本编辑器进行手动修改。
- dynamic_config.db：DBMind服务保存在本地节点的元信息，主要包括算法的超参数、监控阈值等；该文件为DBMind服务元信息，不可由用户直接配置。
- metric_map.conf：监控指标映射表，可用于适配到不同采集平台中。例如，在DBMind中，监控到的系统cpu使用率名为os_cpu_usage, 而用户自行实现的指标采集工具将cpu使用率命名为my_cpu_usage_rate. 则在该种情况下，如果想要DBMind代表cpu使用率的指标名为my_cpu_usage_rate, 则需要修改该配置选项。即添加“os_cpu_usage = my_cpu_usage_rate”配置项进行映射。对于普通用户，建议直接使用DBMind配套的采集组件和方案，则不涉及修改该配置文件。
- logs: 该目录中用于存储DBMind服务产生的日志。

用户可通过两种方式进行配置目录的初始化，一种为交互式，另一种为非交互式。例如，待初始化的配置目录名为confpath, 则分别通过下述方法进行配置：

- 交互式模式

```
gs_dbmind service setup -c confpath --interactive
```

执行完毕上述命令后，用户可通过命令行终端对配置项进行交互式配置。

- 非交互式模式

非交互式模式总共分为三个步骤，即启动配置，修改配置项，初始化配置。其中第二个步骤需要用户通过文本编辑器手动编辑配置文件。具体步骤如下：

1、启动配置，执行下述命令：

```
gs_dbmind service setup -c confpath
```

2、执行完上述命令后，会在confpath目录下生成dbmind.conf配置文件，用户需要利用文本编辑器进行手动修改。需要修改的配置部分为“指标数据源数据库信息区【TSDB】”、“预测结果存储数据库信息区【METADATABASE】”和“自监控参数配置区【SELF-MONITORING】”相关参数的说明如下：

```
[TSDB] # 时序数据库相关信息，即指标数据源信息
name = prometheus # 时序数据库类型. 当前仅支持选择'prometheus'.
host = # 时序数据库IP地址.
port = # 时序数据库端口号.
     
[METADATABASE] # 元数据库相关信息，及预测结果存储方式
dbtype = # 元数据库类型. 可选择: sqlite, opengauss, postgresql。若该配置项名为opengauss, 需关注Python驱动事宜，可参考下文中关于Python驱动的提示。
host = # 元数据库地址.
port = # 元数据库端口号.
username = # 元数据库用户信息.
password =  # 元数据库密码，将会被加密存储
database =  # 元数据库库名. 如果选择的数据库类型为SQLite, 则无需填写上述配置项，仅需填写此处。DBMind会根据database配置项的内容，在配置目录中生成对应文件名的SQLite数据库文件。
     
[SELF-MONITORING] # 自监控参数配置
detection_interval = 600  # 单位秒. 对openGauss进行健康检查的时间间隔（仅慢SQL根因诊断使用）.
last_detection_time = 600  # 单位秒. 用于健康检查的监控数据长度（仅慢SQL根因诊断使用）.
forecasting_future_time = 3600  # 单位秒，时序预测的长度（供时序预测特性使用），同时也是预测功能调度周期
# 待时序预测进行预测的关键指标项（仅供时序预测特性使用）
golden_kpi = os_cpu_usage, os_mem_usage, gaussdb_qps_by_instance
     
[LOG] # 日志相关信息
maxbytes = 10485760 # 默认值为 10Mb, 单个日志文件的最大大小.如果 maxbytes 为零，则文件无限增长（建议该值不要设置太小，默认即可）.
backupcount = 1 # 日志文件最大数量.
level = INFO  # 日志级别，也可配置为 DEBUG, INFO, WARNING, ERROR模式。
```

3、待用户手动修改完上述参数后，需要执行下述命令进行配置项的初始化。在该阶段中，DBMind会初步检查配置项的正确性、加密配置项中出现的明文密码、同时初始化用于存储结果数据的元数据库。

```
gs_dbmind service setup --initialize -c confpath
```

4、完成配置目录初始化过程，可基于该配置目录启动DBMind后台服务。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> 1、配置文件注释信息用于在交互模式下对用户进行提示有特殊含义，请勿手动修改或删除。
> 2、需要确保配置项的值与注释信息之间通过空格符分割，否则系统会将注释信息识别为配置项的值。
> 3、配置项中的特殊字符，如果需要转移，则通过转义符“百分号”（%）来转义，例如，用户配置的密码为 “password%”, 则应通过“百分号”进行转义，即 “password%%“。

**启动服务**

当用户完成配置目录的初始化后，可基于此配置目录启动DBMind后台服务。例如配置目录为confpath，则启动命令如下：

```
gs_dbmind service start -c confpath
```

当执行上述命令后，会提示服务已启动。在未指定任何附加参数时，该命令默认会启动所有的后台任务。如果用户只想启动某一个后台任务，需要添加参数 –only-run. 例如，用户只想启动慢SQL根因分析服务，则为：

```
gs_dbmind service start -c confpath --only-run slow_query_diagnosis
```

**关闭服务**

关闭服务与启动服务类似，其命令行结构更加简单，只需指定配置目录的地址即可。例如配置目录为confpath，则为：

```
gs_dbmind service stop -c confpath
```

DBMind服务会在后台执行完正在运行的任务后自行退出。



> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> -  [METADATABASE]中的元数据库用户需要具有在该数据库下的创表和数据插入更新权限，否则工具执行会出现异常。
> - 当前不支持同一配置文件下分开启动多个服务。
> - 工具提供了requirement.txt文件，用户可以通过该文件安装所需的第三方依赖。

###### COMPONENT子命令

**功能描述**

该子命令可以用于启动DBMind的组件，包括可用于监控指标的exporter，以及AI功能等。该命令可以将用户通过命令行传入的命令转发给对应的子组件，故不同的子组件命令需参考其功能的对应说明。

**语法格式**

用户可以通过 –help 选项获得该模式的帮助信息。

```
gs_dbmind component --help
```

```
usage:  component [-h] COMPONENT_NAME ...

positional arguments:
  COMPONENT_NAME  choice a component to start. ['extract_log', 'forecast', 'index_advisor', 'opengauss_exporter', 'reprocessing_exporter', 'slow_query_diagnosis', 'sqldiag', 'xtuner']
  ARGS            arguments for the component to start

optional arguments:
  -h, --help      show this help message and exit
```

**参数说明**

| 参数           | 参数说明     | 取值范围                                                     |
| :------------- | :----------- | :----------------------------------------------------------- |
| COMPONENT_NAME | 子组件名     | extract_log, forecast, index_advisor, opengauss_exporter, reprocessing_exporter, slow_query_diagnosis, sqldiag, xtuner |
| ARGS           | 子组件的参数 | 参考子组件的命令说明                                         |
| -h, –help      | 帮助命令     | -                                                            |

###### SET子命令

该命令用于修改配置文件dbmind.conf中的参数值，与用户手动修改配置文件dbmind.conf一般无差异。

**语法格式**

用户可以通过 –help 选项获得该模式的帮助信息。

```
gs_dbmind set --help
```

```
usage:  set [-h] -c DIRECTORY section option target

positional arguments:
  section               which section (case sensitive) to set
  option                which option to set
  target                the parameter target to set

optional arguments:
  -h, --help            show this help message and exit
  -c DIRECTORY, --conf DIRECTORY
                        set the directory of configuration files
```

**参数说明**

| 参数      | 参数说明             |
| :-------- | :------------------- |
| -h, –help | 帮助命令             |
| -c，–conf | 配置文件目录confpath |
| section   | 设置区               |
| option    | 设置项               |
| target    | 设置值               |

**注意事项**

修改密码项时必须通过该命令才可以实现修改，否则通过用户手动修改的配置文件无法实现对明文密码的加密。

**示例**

修改配置目录confpath中的配置文件dbmind.conf中TSDB配置部分，host参数的值，并将其设置为 127.0.0.1。

```
gs_dbmind set TSDB host 127.0.0.1 -c confpath
```

修改密码。

```
gs_dbmind set METADATABASE password xxxxxx -c confpath
```

##### DBMIND支持的组件

###### Prometheus Exporter组件

**功能描述**

Prometheus是业内非常流行的开源监控系统，同时本身也是一款时序数据库。Prometheus的采集端称之为exporter，用来收集被监控模块的指标项。为了与Prometheus平台完成对接，AI工具分别实现了两款exporter，分别是用来采集数据库指标的openGauss-exporter，以及对采集到的指标进行二次加工的reprocessing-exporter。

**语法格式**

用户可以通过 –help 选项获得该模式的帮助信息。

- reprocessing-exporter的使用帮助详情：

```
gs_dbmind component reprocessing_exporter --help
```

```
usage:  [-h] [--disable-https] [--ssl-keyfile SSL_KEYFILE]
        [--ssl-certfile SSL_CERTFILE]
        [--web.listen-address WEB.LISTEN_ADDRESS]
        [--web.listen-port WEB.LISTEN_PORT]
        [--collector.config COLLECTOR.CONFIG] [--log.filepath LOG.FILEPATH]
        [--log.level {debug,info,warn,error,fatal}] [--version]
        prometheus_host prometheus_port

Reprocessing Exporter: A re-processing module for metrics stored in the
Prometheus server.

positional arguments:
  prometheus_host       from which host to pull data
  prometheus_port       the port to connect to the Prometheus host

optional arguments:
  -h, --help            show this help message and exit
  --disable-https       disable Https schema
  --ssl-keyfile SSL_KEYFILE
                        set the path of ssl key file
  --ssl-certfile SSL_CERTFILE
                        set the path of ssl certificate file
  --web.listen-address WEB.LISTEN_ADDRESS
                        address on which to expose metrics and web interface
  --web.listen-port WEB.LISTEN_PORT
                        listen port to expose metrics and web interface
  --collector.config COLLECTOR.CONFIG
                        according to the content of the yaml file for metric
                        collection
  --log.filepath LOG.FILEPATH
                        the path to log
  --log.level {debug,info,warn,error,fatal}
                        only log messages with the given severity or above.
                        Valid levels: [debug, info, warn, error, fatal]
  --version             show program's version number and exit
```

- openGauss-exporter的使用帮助详情：

```
gs_dbmind component opengauss_exporter --help
```

```
usage:  [-h] --url URL [--config CONFIG] [--constant-labels CONSTANT_LABELS]
        [--web.listen-address WEB.LISTEN_ADDRESS]
        [--web.listen-port WEB.LISTEN_PORT]
        [--web.telemetry-path WEB.TELEMETRY_PATH] [--disable-cache]
        [--disable-settings-metrics] [--disable-statement-history-metrics]
        [--disable-https] [--ssl-keyfile SSL_KEYFILE]
        [--ssl-certfile SSL_CERTFILE] [--parallel PARALLEL]
        [--log.filepath LOG.FILEPATH]
        [--log.level {debug,info,warn,error,fatal}] [--version]

openGauss Exporter (DBMind): Monitoring for openGauss.

optional arguments:
  -h, --help            show this help message and exit
  --url URL             openGauss database target url.
  --config CONFIG       path to config dir or file.
  --constant-labels CONSTANT_LABELS
                        a list of label=value separated by comma(,).
  --web.listen-address WEB.LISTEN_ADDRESS
                        address on which to expose metrics and web interface
  --web.listen-port WEB.LISTEN_PORT
                        listen port to expose metrics and web interface
  --web.telemetry-path WEB.TELEMETRY_PATH
                        path under which to expose metrics.
  --disable-cache       force not using cache.
  --disable-settings-metrics
                        not collect pg_settings.yml metrics.
  --disable-statement-history-metrics
                        not collect statement-history metrics (including slow
                        queries).
  --disable-https       disable Https schema
  --ssl-keyfile SSL_KEYFILE
                        set the path of ssl key file
  --ssl-certfile SSL_CERTFILE
                        set the path of ssl certificate file
  --parallel PARALLEL   not collect pg_settings.yml metrics.
  --log.filepath LOG.FILEPATH
                        the path to log
  --log.level {debug,info,warn,error,fatal}
                        only log messages with the given severity or above.
                        Valid levels: [debug, info, warn, error, fatal]
  --version             show program's version number and exit
```

**参数说明**

| 参数                               | 参数说明                                                     | 取值范围                        |
| :--------------------------------- | :----------------------------------------------------------- | :------------------------------ |
| –url                               | openGauss server 的连接地址，例如 postgres://user:pwd@host:port/dbname | -                               |
| –constant-labels                   | 常量标签，将采集到的指标项中强行添加该标签列表               | 1024-65535                      |
| -h, –help                          | 帮助选项                                                     | -                               |
| –disable-https                     | 禁用Https协议                                                | -                               |
| –ssl-keyfile                       | Https协议使用的证书私钥文件路径                              | -                               |
| –ssl-certfile                      | Https协议使用的证书文件路径                                  | -                               |
| –web.listen-address                | 该exporter服务的绑定IP                                       | -                               |
| –web.listen-port                   | 该exporter服务的侦听端口                                     | 1024-65535                      |
| –web.telemetry-path                | 该exporter采集指标的URI地址，默认为 /metrics                 | -                               |
| –config                            | 显性指定的待采集指标配置文件路径                             | -                               |
| –log.filepath                      | 日志文件保存路径，默认保存在当前目录下                       | -                               |
| –log.level                         | 日志文件的打印级别，默认为INFO级别                           | debug, info, warn, error, fatal |
| –version                           | 显示版本信息                                                 | -                               |
| –disable-cache                     | 禁止使用缓存                                                 | -                               |
| –disable-settings-metrics          | 禁止采集pg_settings表的值                                    | -                               |
| –disable-statement-history-metrics | 禁止收集statement_history表中的慢SQL信息                     | -                               |
| –parallel                          | 连接到openGauss的数据库连接池的大小                          | 正整数                          |

**注意事项**

- Prometheus 和exporter部署在内网环境中，不对外部暴露接口，仅供内部监控平台使用。如果用户希望提高安全性，可自行修改Prometheus的TLS配置选项，但仍不建议对外部直接暴露访问接口。
- 提供的exporter组件默认采用Https通信协议，因此需要用户默认提供ssl证书和秘钥文件，并通过–ssl-keyfile以及–ssl-certfile提供。若用户不希望使用Https协议，则可以通过–disable-https选项禁用该模式。
- openGauss-exporter中连接数据库的用户需要monitor admin或以上权限，否则会出现部分指标无法采集的情况。
- openGauss-exporter会从dbe_perf.statement_history中抽样慢SQL信息，dbe_perf.statement_history视图慢SQL记录与GUC参数log_min_duration_statement和track_stmnt_stat_level相关，其中log_min_duration_statement是慢SQL阈值，单位毫秒，具体值由用户设置；track_stmnt_stat_level是SQL记录级别，默认为'OFF,L0'，即只记录慢SQL信息，级别为L0，用户在详细了解参数意义与作用情况下谨慎修改。
- openGauss-exporter采集数据库相关信息，主要包括部分系统表和视图中的数据（具体参见代码中opengauss_exporter中的配置文件），node-exporter采集系统指标信息，主要与系统磁盘、CPU等相关，reprocessing_exporter基于prometheus-server中的某些指标（具体参见代码中reprocessing_exporter中的配置文件）进行二次加工，最终提供加工后的数据供用户使用。
-  prometheus-server在拉取exporter数据时有超时机制，超时时间由scrape_timeout（默认10s）控制，因此当exporter采集数据量较大时，用户可根据实际情况增大scrape_timeout以防止超时报错，另外需要注意的是scrape_interval（采集间隔）不能比scrape_timeout小，否则会出现异常。
- 如果数据库时区设置和系统不相同，可能会出现时间相关指标时间与系统时间不一致的情况，因此需要将用户时区与系统保持同步。
- 当使用https通信时，工具会检测证书与密钥文件权限以及证书有效期，如果文件权限大于600则会出现报警，证书有效期小于90天会出现报警。
- 当存在指标重复采集时，openGauss-exporter会出现异常，异常信息会打印到日志中。
- openGauss-exporter的–config、–disable-settings-metrics、–disable-statement-history-metrics三个参数需要注意，其存在以下几种情况：
  - 用户不指定其中任何参数，则工具会同时对yamls目录下的三个配置文件中的指标进行采集。
  - 用户显式指定–config，则工具不会采集yamls目录下default.yml中的指标，而会采集用户指定配置文件中的指标，同时pg_settings.yml和statements.yml正常采集，此时用户需要注意指定的配置文件中的指标和pg_settings.yml、statements.yml中的指标不能存在重复采集的现象。
  - 用户显式指定–disable-settings-metrics，则工具不会采集yamls目录下pg_settings.yml中的指标，用户显式指定–disable-statement-history-metrics，则工具不会采集yamls目录下statements.yml（慢SQL相关）中的指标。


**环境部署**

1、通过命令行参数启动对应的exporter进程，同时在本地机器创建侦听端口号。

2、在Promethues的服务器端修改配置文件prometheus.yml，将启动的exporter信息添加进去，例如：

```
scrape_configs:
  ...
       
    - job_name: 'opengauss_exporter'
      static_configs:
      - targets: ['127.0.0.1:9187']
        ...
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> 由于openGauss默认模式下的通信加密协议与PostgreSQL不兼容，故导致通过PyPI源安装的基于PostgreSQL编译的Python驱动psycopg2-binary默认无法连接至openGauss数据库。
> 因此，需要用户自行编译psycopg2或修改GUC参数进行适配。也可通过openGauss官方网站下载基于openGauss编译的psycopg2（官方网站仅提供部分Python版本的编译包，一般为Python3.6版本，需要用户鉴别）。
>
> - 官方openGauss Python驱动下载地址为：
>   https://opengauss.org/zh/download.html
> - 关于Python驱动的适配问题，可参考openGauss官方操作指南：
>   https://mp.weixin.qq.com/s/2TobUQKtw0N9sBpMZJr6zw

**使用指导**

用户可通过gs_dbmind命令启动对应的exporter。下面演示了一个完整的Prometheus监控平台的搭建过程。

1、部署openGauss-exporter：启动openGauss-exporter，采用默认侦听端口号9187，侦听地址为192.168.1.100，不采用https协议，则命令可以为：

```
gs_dbmind component opengauss_exporter --url postgresql://user:password@ip:port/dbname --web.listen-address 192.168.1.100 --disable-https
```

2、部署reprocessing-exporter：启动reprocessing-exporter，采用默认侦听端口号8181，侦听地址为192.168.1.101，Prometheus-server IP与端口号为192.168.1.100:9090，采用https协议，则命令可以为：

```
gs_dbmind component reprocessing_exporter 192.168.1.100 9090 --web.listen-address 192.168.1.101 --ssl-keyfile server.key --ssl-certfile server.crt
```

3、部署node-exporter：一般地，对于Prometheus监控平台都需要部署node-exporter用于监控Linux操作系统，后文提到的部分AI功能也需要依赖node-exporter采集Linux系统指标，故也需要用户来部署；只不过，该node-exporter为Prometheus自带组件，需要用户自行下载安装，下载地址为 https://prometheus.io/download/#node_exporter  ，使用方法详见：https://prometheus.io/docs/guides/node-exporter/#installing-and-running-the-node-exporter  。用户可解压压缩包后直接运行该node-exporter进程，其默认端口号为9100，启动命令行为：

```
./node_exporter 
```

4、配置Prometheus-server，修改配置文件prometheus.yml，添加下述内容：

```
scrape_configs:
 ...
   - job_name: 'opengauss_exporter'
     static_configs:
     - targets: ['192.168.1.100:9187']
   - job_name: 'reprocessing_exporter'
     scheme: https
     tls_config:
         ca_file: xxx.crt
     static_configs:
     - targets: ['127.0.0.1:8181']
   - job_name: 'node_exporter'
     static_configs:
     - targets: ['127.0.0.1:9100']
 ...
```

**常见问题**

- 提示需要用户提供–ssl-keyfile与–ssl-certfile选项：

  上述exporter默认采用Https模式通信，因此需要用户指定证书及其私钥文件的路径。相反，如果用户只想采用Http模式，则需要显性给定–disable-https选项，从而禁用Https协议。

- 提示用户需要输入PEM密码（Enter PEM pass phrase）：

  如果用户采用Https模式，并给定了证书及其秘钥文件的路径，且该秘钥文件是经过加密的，则需要用户输入该加密私钥证书文件的密码。

##### DBMIND的AI子功能

###### X-TUNER：参数调优与诊断

**功能描述**

X-Tuner是一款数据库集成的参数调优工具，通过结合深度强化学习和全局搜索算法等AI技术，实现在无需人工干预的情况下，获取最佳数据库参数配置。本功能不强制与数据库环境部署到一起，支持独立部署，脱离数据库安装环境独立运行。

**原理简介**

调优程序是一个独立于数据库内核之外的工具，需要提供数据库及其所在实例的用户名和登录密码信息，以便控制数据库执行benchmark进行性能测试；在启动调优程序前，要求用户测试环境交互正常，能够正常跑通benchmark测试脚本、能够正常连接数据库。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
>  如果需要调优的参数中，包含重启数据库后才能使修改生效的参数，那么在调优过程中数据库将会重启多次。如果用户的数据库正在执行作业，请慎用train与tune模式。

调优程序X-Tuner包含三种运行模式，分别是:

- recommend：通过用户指定的用户名等信息登录到数据库环境中，获取当前正在运行的workload特征信息，根据上述特征信息生成参数推荐报告。报告当前数据库中不合理的参数配置和潜在风险等；输出根据当前正在运行的workload行为和特征；输出推荐的参数配置。该模式是秒级的，不涉及数据库的重启操作，其他模式可能需要反复重启数据库。
- train：通过用户提供的benchmark信息，不断地进行参数修改和benchmark的执行。通过反复的迭代过程，训练强化学习模型，以便用户在后面通过tune模式加载该模型进行调优。
- tune：使用优化算法进行数据库参数的调优，当前支持两大类算法，一种是深度强化学习，另一种是全局搜索算法（全局优化算法）。深度强化学习模式要求先运行train模式，生成训练后的调优模型，而使用全局搜索算法则不需要提前进行训练，可以直接进行搜索调优。

<div align="left"><img src="image/image2.png" style="zoom:20%")</div>  

如果在tune模式下，使用深度强化学习算法，要求必须有一个训练好的模型，且要求训练该模型时的参数与进行调优时的参数列表（包括max与min）必须一致。

X-Tuner结构图如下所示：

<div align="left"><img src="image/XTUNER结构图.png" style="zoom:100%")</div>  

- DB侧：通过DB_Agent模块对数据库实例进行抽象，通过该模块可以获取数据库内部的状态信息、当前数据库参数、以及设置数据库参数等。DB侧包括登录数据库环境使用的SSH连接。
- 算法侧：用于调优的算法包，包括全局搜索算法（如贝叶斯优化、粒子群算法等）和深度强化学习（如DDPG）。
- X-Tuner主体逻辑模块：通过Enviroment模块进行封装，每一个step就是一次调优过程。整个调优过程通过多个step进行迭代。
- benchmark：由用户指定的benchmark性能测试脚本，用于运行benchmark作业，通过跑分结果反映数据库系统性能优劣。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> 应确保benchmark脚本跑分结果越大表示性能越好。 例如TPCH这种衡量SQL语句整体执行时长的benchmark，可以通过取总体执行时间的相反数作为benchmark的输出分数。

**语法格式**

用户可以通过 –help 选项获得该模式的帮助信息。

```
gs_dbmind component xtuner --help
```

```
usage:  [-h] [--db-name DB_NAME] [--db-user DB_USER] [--port PORT]
                 [--host HOST] [--host-user HOST_USER]
                 [--host-ssh-port HOST_SSH_PORT] [-f DB_CONFIG_FILE]
                 [-x TUNER_CONFIG_FILE] [-v]
                 {train,tune,recommend}

X-Tuner: a self-tuning tool integrated by openGauss.

positional arguments:
  {train,tune,recommend}
                        Train a reinforcement learning model or tune database
                        by model. And also can recommend best_knobs according
                        to your workload.

optional arguments:
  -h, --help            show this help message and exit
  -f DB_CONFIG_FILE, --db-config-file DB_CONFIG_FILE
                        You can pass a path of configuration file otherwise
                        you should enter database information by command
                        arguments manually. Please see the template file
                        share/server.json.template.
  -x TUNER_CONFIG_FILE, --tuner-config-file TUNER_CONFIG_FILE
                        This is the path of the core configuration file of the
                        X-Tuner. You can specify the path of the new
                        configuration file. The default path is xtuner.conf.
                        You can modify the configuration file to control the
                        tuning process.
  -v, --version         show program's version number and exit

Database Connection Information:
  --db-name DB_NAME     The name of database where your workload running on.
  --db-user DB_USER     Use this user to login your database. Note that the
                        user must have sufficient permissions.
  --port PORT           Use this port to connect with the database.
  --host HOST           The IP address of your database installation host.
  --host-user HOST_USER
                        The login user of your database installation host.
  --host-ssh-port HOST_SSH_PORT
                        The SSH port of your database installation host.
```

**参数说明**

- 命令行参数

| 参数                   | 参数说明                                                     | 取值范围               |
| :--------------------- | :----------------------------------------------------------- | :--------------------- |
| mode                   | 指定调优程序运行的模式                                       | train，tune，recommend |
| –tuner-config-file, -x | X-Tuner的核心参数配置文件路径，默认路径为安装目录下的xtuner.conf。如果需要修改配置文件的加载路径，则可以通过选项-x命令行选项来指定。 |                        |
| –db-config-file, -f    | 调优程序的用于登录到数据库宿主机上的连接信息配置文件路径，若通过该文件配置数据库连接信息，则下述数据库连接信息可省略 | -                      |
| –db-name               | 指定需要调优的数据库名                                       | -                      |
| –db-user               | 指定以何用户身份登陆到调优的数据库上                         | -                      |
| –port                  | 数据库的侦听端口                                             | -                      |
| –host                  | 数据库实例的宿主机IP                                         | -                      |
| –host-user             | 指定以何用户身份登陆到数据库实例的宿主机上，要求改用户名的环境变量中可以找到gsql、vb_ctl等数据库运维工具。 | -                      |
| –host-ssh-port         | 数据库实例所在宿主机的SSH端口号，可选，默认为22              | -                      |
| –help, -h              | 返回帮助信息                                                 | -                      |
| –version, -v           | 返回当前工具版本号                                           | -                      |

- 配置文件中的参数详解

| 参数名                | 参数说明                                                     | 取值范围                      |
| :-------------------- | :----------------------------------------------------------- | :---------------------------- |
| logfile               | 生成的日志存放路径                                           | -                             |
| output_tuning_result  | 可选，调优结果的保存路径                                     | -                             |
| verbose               | 是否打印详情                                                 | on, off                       |
| recorder_file         | 调优中间信息的记录日志存放路径                               | -                             |
| tune_strategy         | 调优模式下采取哪种策略                                       | rl, gop, auto                 |
| drop_cache            | 是否在每一个迭代轮次中进行drop cache，drop cache可以使benchmark跑分结果更加稳定。若启动该参数，则需要将登录的系统用户加入到 /etc/sudoers 列表中，同时为其增加 **NOPASSWD** 权限（由于该权限可能过高，建议临时启用该权限，调优结束后关闭）。 | on, off                       |
| used_mem_penalty_term | 数据库使用总内存的惩罚系数，用于防止通过无限量占用内存而换取的性能表现。该数值越大，惩罚力度越大。 | 建议0 ~ 1                     |
| rl_algorithm          | 选择何种RL算法                                               | ddpg                          |
| rl_model_path         | RL模型保存或读取路径，包括保存目录名与文件名前缀。在train 模式下该路径用于保存模型，在tune模式下则用于读取模型文件 | -                             |
| rl_steps              | 深度强化学习算法迭代的步数                                   | -                             |
| max_episode_steps     | 每个回合的最大迭代步数                                       | -                             |
| test_episode          | 使用RL算法进行调优模式的回合数                               | -                             |
| gop_algorithm         | 采取何种全局搜索算法                                         | bayes, pso                    |
| max_iterations        | 全局搜索算法的最大迭代轮次（并非确定数值，可能会根据实际情况多跑若干轮） | -                             |
| particle_nums         | PSO算法下的粒子数量                                          | -                             |
| benchmark_script      | 使用何种benchmark驱动脚本，该选项指定加载benchmark路径下同名文件，默认支持TPC-C、TPC-H等典型benchmark | tpcc, tpch, tpcds, sysbench … |
| benchmark_path        | benchmark 脚本的存储路径，若没有配置该选项，则使用benchmark驱动脚本中的配置 | -                             |
| benchmark_cmd         | 启动benchmark 脚本的命令，若没有配置该选项，则使用benchmark驱动脚本中的配置 | -                             |
| benchmark_period      | 仅对 period benchmark有效，表明整个benchmark的测试周期是多少，单位是秒 | -                             |
| scenario              | 用户指定的当前workload所属的类型                             | tp, ap, htap                  |
| tuning_list           | 准备调优的参数列表文件，可参考 share/knobs.json.template 文件 | -                             |

**注意事项**

- 数据库状态正常、客户端能够正常连接、且要求数据库内导入数据，以便调优程序可以执行benchmark测试调优效果。
- 使用本工具需要指定登录到数据库的用户身份，要求该登录到数据库上的用户具有足够的权限，以便可以获得充足的数据库状态信息。
- 使用登录到数据库宿主机上的Linux用户，需要将$GAUSSHOME/bin添加到PATH环境变量中，即能够直接运行gsql、gs_guc、vb_ctl等数据库运维工具。
- 本工具支持以三种模式运行，其中tune和train模式要求用户配置好benchmark运行环境，并导入数据，本工具将会通过迭代运行benchmark来判断修改后的参数是否有性能提升。
- recommend模式建议在数据库正在执行workload的过程中执行，以便获得更准确的实时workload信息。
- 本工具默认带有TPC-C、TPC-H、TPC-DS以及sysbench的benchmark运行脚本样例，如果用户使用上述benchmark对数据库系统进行压力测试，则可以对上述配置文件进行适度修改或配置。如果需要适配用户自己的业务场景，需要您参照benchmark目录中的template.py文件编写驱动您自定义benchmark的脚本文件。

**Benchmark的选择与配置**

Benchmark的驱动脚本存放路径为X-Tuner目录（即$GAUSSHOME/bin/dbmind/components/xtuner，下同）的子目录benchmark中。X-Tuner自带常用的benchmark驱动脚本，例如基于时间周期的探测脚本（默认）、TPC-C、TPC-H等。X-Tuner通过调用benchmark/_init__.py文件中 get_benchmark_instance()命令来加载不同的benchmark驱动脚本，获取benchmark驱动实例。其中，benchmark驱动脚本的格式说明如下：

- 驱动脚本文件名：表示benchmark的名字，该名字用于表示驱动脚本的唯一性，可通过在X-Tuner的配置文件中的配置项benchmark_script来指定选择加载哪个benchmark驱动脚本。
- 驱动脚本内容三要素：path变量、cmd变量以及run函数。

下面分别介绍驱动脚本的内容三要素：

- path变量：表示benchmark脚本的存放地址，可以直接在驱动脚本中修改，也可以通过配置文件的benchmark_path配置项来指定。
- cmd变量：表示执行benchmark脚本需要运行的命令，可以直接在驱动脚本中修改，也可以通过配置文件的benchmark_cmd配置项来指定。cmd中的文本允许使用占位符，用于获取某些运行cmd命令时的必要信息，使用示例参见TPC-H驱动脚本示例。这些占位符包括：
  - {host}：数据库宿主机的IP地址
  - {port}：数据库实例的侦听端口号
  - {user}：登录数据库系统上的用户名
  - {password}：与登录数据库系统上的用户相匹配的密码
  - {db}：正在进行调优的数据库名
- run函数：该函数的函数签名如下所示。

```
def run(remote_server, local_host) -> float:
```

其中，返回数据类型为float，表示benchmark执行后的评估分数值，要求该值越大表示性能越好，例如使用TPC-C跑分结果tpmC即可作为返回值，TPC-H的全部SQL语句执行总时间的相反数（取相反数后可保证返回值越大则性能越好）也可作为返回值。

remote_server变量是X-Tuner程序传递给脚本使用的远端主机（数据库宿主机）的shell命令接口，local_host变量是X-Tuner程序传递给脚本使用的本地主机（运行X-Tuner脚本的主机）的shell命令接口。上述shell命令接口提供的方法包括：

- 在主机上执行shell命令

```
exec_command_sync(command, timeout)
```

参数列表：command 必选，数据类型可以是str, 以及元素为str类型的list或tuple；timeout 可选，表示命令执行的超时时长，单位是秒。
返回值：返回二元组 (stdout, stderr)，stdout表示标准输出流结果，stderr表示标准错误流结果，数据类型均为str.

- 最近一条shell命令执行后的退出状态码(exit status code)。

```
exit_status
```

说明：一般情况，退出状态码为0表示执行正常，非0表示存在错误。

**Benchmark驱动脚本示例说明**

- TPC-C 驱动脚本

```
from tuner.exceptions import ExecutionError
    
# WARN: You need to download the benchmark-sql test tool to the system,
# replace the PostgreSQL JDBC driver with the openGauss driver,
# and configure the benchmark-sql configuration file.
# The program starts the test by running the following command:
path = '/path/to/benchmarksql/run'  # TPC-C测试脚本benchmark-sql 的存放路径
cmd = "./runBenchmark.sh props.gs"  # 自定义一个名为 props.gs 的benchmark-sql测试配置文件
    
    
def run(remote_server, local_host):
    # 切换到 TPC-C 脚本目录下，清除历史错误日志，然后运行测试命令。
    # 此处最好等待几秒钟，因为benchmark-sql 测试脚本生成最终测试报告是通过一个shell脚本实现的，整个过程会有延迟，
    # 为了保证能够获取到最终的tpmC数值报告，我们这里选择等待3秒钟。
    stdout, stderr = remote_server.exec_command_sync(['cd %s' % path, 'rm -rf benchmarksql-error.log', cmd, 'sleep 3'])
    # 如果标准错误流中有数据，则报异常退出。
    if len(stderr) > 0:
        raise ExecutionError(stderr)
    
    # 寻找最终tpmC结果
    tpmC = None
    split_string = stdout.split()  # 对标准输出流结果进行分词。
    for i, st in enumerate(split_string):
        # 在5.0版本的benchmark-sql中，tpmC最终测试结果数值在 '(NewOrders)'关键字的后两位，正常情况下，找到该字段后直接返回即可。
        if "(NewOrders)" in st:
            tpmC = split_string[i + 2]
            break
    stdout, stderr = remote_server.exec_command_sync(
        "cat %s/benchmarksql-error.log" % path)
    nb_err = stdout.count("ERROR:")  # 判断整个benchmark运行过程中，是否有报错，记录报错的错误数
    return float(tpmC) - 10 * nb_err  # 这里将报错的错误数作为一个惩罚项，惩罚系数为10，越高的惩罚系数表示越看中报错的数量.
```

- TPC-H驱动脚本

```
import time
    
from tuner.exceptions import ExecutionError
    
# WARN: You need to import data into the database and SQL statements in the following path will be executed.
# The program automatically collects the total execution duration of these SQL statements.
path = '/path/to/tpch/queries'  # 存放TPC-H测试用的SQL脚本目录
cmd = "gsql -U {user} -W {password} -d {db} -p {port} -f {file}"  # 需要运行TPC-H测试脚本的命令，一般使用'gsql -f 脚本文件' 来运行
    
    
def run(remote_server, local_host):
    # 遍历当前目录下所有的测试用例文件名
    find_file_cmd = "find . -type f -name '*.sql'"
    stdout, stderr = remote_server.exec_command_sync(['cd %s' % path, find_file_cmd])
    if len(stderr) > 0:
        raise ExecutionError(stderr)
    files = stdout.strip().split('\n')
    time_start = time.time()
    for file in files:
        # 使用 file 变量替换 {file}，然后执行该命令行。
        perform_cmd = cmd.format(file=file)
        stdout, stderr = remote_server.exec_command_sync(['cd %s' % path, perform_cmd])
        if len(stderr) > 0:
            print(stderr)
    # 代价为全部测试用例的执行总时长
    cost = time.time() - time_start
    # 取相反数，适配run 函数的定义：返回结果越大表示性能越好。
    return - cost
```

**示例**

X-Tuner支持三种模式，分别是获取参数诊断报告的recommend模式、训练强化学习模型的train模式、以及使用算法进行调优的tune模式。上述三种模式可以通过命令行参数来区别，通过配置文件来指定具体的细节。

1、配置数据库连接信息

- 通过命令行指定：分别传递 –db-name –db-user –port –host –host-user 参数，可选 –host-ssh-port 参数。

```
gs_dbmind component xtuner recommend --db-name postgres --db-user omm --port 5678 --host 192.168.1.100 --host-user omm
```

- 通过JSON格式的连接信息配置文件指定：JSON配置文件的示例如下，并假设文件名为 connection.json，可通过 -f connection.json 传递。

```
{
  "db_name": "postgres",  # 数据库名
  "db_user": "dba",       # 登录到数据库上的用户名
  "host": "127.0.0.1",    # 数据库宿主机的IP地址
  "host_user": "dba",     # 登录到数据库宿主机的用户名
  "port": 5432,           # 数据库的侦听端口号
  "ssh_port": 22          # 数据库宿主机的SSH侦听端口号
}
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>  
>
> 为了防止密码泄露，配置文件和命令行参数中默认都不包含密码信息，用户在输入上述连接信息后，程序会采用交互式的方式要求用户输数据库密码以及操作系统登录用户的密码。

2、recommend模式使用示例

对recommend模式生效的配置项为scenario，若为auto，则自动检测workload类型。

执行下述命令，获取诊断结果：

```
gs_dbmind component xtuner recommend -f connection.json
```

recommend模式生成的报告示意图

<div align="left"><img src="image/报告示意图.png" style="zoom:100%")</div>  

在上述报告中，推荐了该环境上的数据库参数配置，并进行了风险提示。报告同时生成了当前workload的特征信息，其中有几个特征是比较有参考意义的：

- temp_file_size：产生的临时文件数量，如果该结果大于0，则表明系统使用了临时文件。使用过多的临时文件会导致性能不佳，如果可能的话，需要提高work_mem参数的配置。
- cache_hit_rate：shared_buffer的缓存命中率，表明当前workload使用缓存的效率。
- read_write_ratio：数据库作业的读写比例。
- search_modify_ratio：数据库作业的查询与修改数据的比例。
- ap_index：表明当前workload的AP指数，取值范围是0到10，该数值越大，表明越偏向于数据分析与检索。
- workload_type：根据数据库统计信息，推测当前负载类型，分为AP、TP以及HTAP三种类型。
- checkpoint_avg_sync_time：数据库在checkpoint时，平均每次同步刷新数据到磁盘的时长，单位是毫秒。
- load_average：平均每个CPU核心在1分钟、5分钟以及15分钟内的负载。一般地，该数值在1左右表明当前硬件比较匹配workload、在3左右表明运行当前作业压力比较大，大于5则表示当前硬件环境运行该workload压力过大（此时一般建议减少负载或升级硬件）。

由于某些系统表会一直记录统计信息，这可能会对负载特征识别造成干扰，因此建议最好先清空某些系统表的统计信息，运行一段时间的workload后再使用recommend模式进行诊断，以便获得更准确的结果。清除统计信息的方法为：

```
select pg_stat_reset_shared('bgwriter');
select pg_stat_reset();
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> recommend模式会读取数据库中的pg_stat_database以及pg_stat_bgwriter等系统表中的信息，需要登录到数据库上的用户具有足够的权限（建议为管理员权限，可通过alter user username sysadmin；授予username相应的权限）。

3、train 模式使用示例

该模式是用来训练深度强化学习模型的，与该模式有关的配置项为：

-   rl\_algorithm：用于训练强化学习模型的算法，当前支持设置为ddpg.
-   rl\_model\_path：训练后生成的强化学习模型保存路径。
-   rl\_steps：训练过程的最大迭代步数。
-   max\_episode\_steps：每个回合的最大步数。
-   scenario：明确指定的workload类型，如果为auto则为自动判断。在不同模式下，推荐的调优参数列表也不一样。
-   tuning\_list：用户指定需要调哪些参数，如果不指定，则根据workload类型自动推荐应该调的参数列表。如需指定，则tuning\_list表示调优列表文件的路径。一个调优列表配置文件的文件内容示例如下：

    ```
    {
      "work_mem": {
        "default": 65536,
        "min": 65536,
        "max": 655360,
        "type": "int",
        "restart": false
      },
      "shared_buffers": {
        "default": 32000,
        "min": 16000,
        "max": 64000,
        "type": "int",
        "restart": true
      },
      "random_page_cost": {
        "default": 4.0,
        "min": 1.0,
        "max": 4.0,
        "type": "float",
        "restart": false
      },
      "enable_nestloop": {
        "default": true,
        "type": "bool",
        "restart": false
      }
    }
    ```

待上述配置项配置完成后，可以通过下述命令启动训练：

```
gs_dbmind component xtuner train -f connection.json
```

训练完成后，会在配置项rl\_model\_path指定的目录中生成模型文件。

3、tune模式使用示例

tune模式支持多种算法，包括基于强化学习（Reinforcement Learning, RL）的DDPG算法、基于全局搜索算法（Global OPtimization algorithm, GOP）算法的贝叶斯优化算法（Bayesian Optimization）以及粒子群算法（Particle Swarm Optimization, PSO）。

与tune模式相关的配置项为：

-   tune\_strategy：指定选择哪种算法进行调优，支持rl（使用强化学习模型进行调优）、gop（使用全局搜索算法）以及auto（自动选择）。若该参数设置为rl，则rl相关的配置项生效。除前文提到过的train模式下生效的配置项外，test\_episode配置项也生效，该配置项表明调优过程的最大回合数，该参数直接影响了调优过程的执行时间（一般地，数值越大越耗时）。
-   gop\_algorithm：选择何种全局搜索算法，支持bayes以及pso。
-   max\_iterations：最大迭代轮次，数值越高搜索时间越长，效果往往越好。
-   particle\_nums：在PSO算法上生效，表示粒子数。
-   scenario与tuning\_list见上文train模式中的描述。

待上述配置项配置完成后，可以通过下述命令启动调优：

```
gs_dbmind component xtuner tune -f connection.json 
```

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div> 
>
>  在使用tune和train模式前，用户需要先导入benchmark所需数据并检查benchmark能否正常跑通。调优过程结束后，调优程序会自动恢复调优前的数据库参数配置。

**常见问题**

- 数据库实例连接失败：请检查数据库实例的情况，是否数据库实例出现了问题或安全权限配置（pg_hba.conf文件中的配置项）不正确。
- 重启失败：请检查数据库实例健康情况，确保数据库实例工作正常。
- 跑TPC-C作业时发现性能越来越慢：TPC-C等高并发场景下的压力测试，往往伴随着大量的数据修改。由于每一次测试并非是幂等的（TPC-C数据库数据量的增加、没有进行vacuum full清理掉失效元组、数据库没有触发checkpoint、没有进行drop cache等），因此一般建议TPC-C等伴随着较多数据写入的benchmark应该每隔一段时间（视具体并发量、执行时长的不同而异）重新导入一次数据，比较简单的方法是备份$PGDATA目录。
- TPC-C 跑作业时，TPC-C驱动脚本报异常 “TypeError: float() argument must be a string or a number, not 'NoneType'”（不能将None转换为float类型）：这是因为没有获取到TPC-C的压测返回结果，造成该问题的原因比较多，请首先手动检测是否能够跑通TPC-C并能够获取返回结果。若无上述问题，则建议将 TPC-C 驱动脚本中的命令列表中的 “sleep” 命令延迟时间设得更大一些。

###### INDEX-ADVISOR索引推荐

**单query索引推荐**

单query索引推荐功能支持用户在数据库中直接进行操作，本功能基于查询语句的语义信息和数据库的统计信息，对用户输入的单条查询语句生成推荐的索引。本功能涉及的函数接口如下。

| 函数名          | 参数          | 功能                           |
| :-------------- | :------------ | :----------------------------- |
| gs_index_advise | SQL语句字符串 | 针对单条查询语句生成推荐索引。 |

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> 仅支持单条SELECT类型的语句，不支持其他类型的SQL语句。
>
> 暂不支持列存表、段页式表、普通视图、物化视图、全局临时表以及密态数据库。

**单query索引示例**

- 使用上述函数，获取针对该query生成的推荐索引，推荐结果由索引的表名和列名组成。

```
select "table", "column" from gs_index_advise('SELECT c_discount from bmsql_customer where c_w_id = 10');
```

```
     table      |  column  
----------------+----------
 bmsql_customer | c_w_id
(1 row)
```

上述结果表明：应当在 bmsql_customer 的 c_w_id 列上创建索引，例如可以通过下述SQL语句创建索引：

```
CREATE INDEX idx on bmsql_customer(c_w_id);
```

- 某些SQL语句，也可能被推荐创建联合索引，例如：

```
select "table", "column" from gs_index_advise('select name, age, sex from t1 where age >= 18 and age < 35 and sex = ''f'';');
```

```
 table | column
-------+------------
 t1    | age, sex
(1 row)
```

上述语句表明应该在表 t1 上创建一个联合索引 (age, sex)， 则可以通过下述命令创建：

```
CREATE INDEX idx1 on t1(age, sex);
```

- 针对分区表可推荐具体索引类型，例如：

```
select "table", "column", "indextype" from gs_index_advise('select name, age, sex from range_table where age = 20;');
```

```
 table | column | indextype
-------+--------+-----------
 t1    | age    | global
(1 row)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> 系统函数gs_index_advise()的参数是文本型，如果参数中存在如单引号（'）等特殊字符，可以使用单引号（'）进行转义，可参考上述示例。

**虚拟索引**

虚拟索引功能支持用户在数据库中直接进行操作，将模拟真实索引的建立，避免真实索引创建所需的时间和空间开销，用户基于虚拟索引，可通过优化器评估该索引对指定查询语句的代价影响。

涉及的系统函数接口如下表所示：

| 函数名               | 参数                 | 功能                             |
| :------------------- | :------------------- | :------------------------------- |
| hypopg_create_index  | 创建索引语句的字符串 | 创建虚拟索引。                   |
| hypopg_display_index | 无                   | 显示所有创建的虚拟索引信息。     |
| hypopg_drop_index    | 索引的oid            | 删除指定的虚拟索引。             |
| hypopg_reset_index   | 无                   | 清除所有虚拟索引。               |
| hypopg_estimate_size | 索引的oid            | 估计指定索引创建所需的空间大小。 |

涉及的GUC参数如下：

| 参数名            | 功能                 | 默认值 |
| :---------------- | :------------------- | :----- |
| enable_hypo_index | 是否开启虚拟索引功能 | off    |

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE bmsql_customer (c_w_id int,name varchar,c_discount int);
INSERT INTO bmsql_customer values(1,a,11);
INSERT INTO bmsql_customer values(2,b,12);
INSERT INTO bmsql_customer values(3,c,13);
```

使用函数hypopg_create_index创建虚拟索引。例如：

```
select * from hypopg_create_index('create index on bmsql_customer(c_w_id)');
```

```
 indexrelid |             indexname              
------------+------------------------------------
      24040 | <24040>btree_bmsql_customer_c_w_id
(1 row)
```

2、开启GUC参数enable_hypo_index，该参数控制数据库的优化器进行EXPLAIN时是否考虑创建的虚拟索引。通过对特定的查询语句执行explain，用户可根据优化器给出的执行计划评估该索引是否能够提升该查询语句的执行效率。

开启GUC参数前，执行EXPLAIN + 查询语句：

```
explain SELECT c_discount from bmsql_customer where c_w_id = 3;
```

```
                              QUERY PLAN                              
----------------------------------------------------------------------
 Seq Scan on bmsql_customer  (cost=0.00..52963.06 rows=31224 width=4)
   Filter: (c_w_id = 3)
(2 rows)
```

开启GUC参数后，执行EXPLAIN + 查询语句：

```
set enable_hypo_index = on;
explain SELECT c_discount from bmsql_customer where c_w_id = 3;
```

```
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using <329726>btree_bmsql_customer_c_w_id on bmsql_customer  (cost=0.00..39678.69 rows=31224 width=4)
   Index Cond: (c_w_id = 3)
(3 rows)
```

通过对比两个执行计划可以观察到，该索引预计会降低指定查询语句的执行代价，用户可考虑创建对应的真实索引。

3、使用函数hypopg_display_index展示所有创建过的虚拟索引（可选）。例如：

```
select * from hypopg_display_index();
```

```
         indexname              | indexrelid |     table      |  column  

------------------------------------+------------+----------------+----------
 <24040>btree_bmsql_customer_c_w_id |      24040 | bmsql_customer | (c_w_id)
 (2 rows)
```

4、使用函数hypopg_estimate_size估计虚拟索引创建所需的空间大小（单位：字节）（可选）。例如：

```
 select * from hypopg_estimate_size(329730);
```

```
 hypopg_estimate_size 
----------------------
             15687680
(1 row)
```

5、删除虚拟索引。

使用函数hypopg_drop_index删除指定oid的虚拟索引。例如：

```
select * from hypopg_drop_index(329726);
```

```
 hypopg_drop_index 
-------------------
 t
(1 row)
```

使用函数hypopg_reset_index一次性清除所有创建的虚拟索引。例如：

```
select * from hypopg_reset_index();
```

```
 hypopg_reset_index 
--------------------
    
(1 row)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> - 执行EXPLAIN ANALYZE不会涉及虚拟索引功能。
> - 创建的虚拟索引是数据库实例级别的，各个会话（session）之间可共享设置，关闭会话后虚拟索引仍可存在，但是重启数据库后将被清空。
> - 本功能暂不支持视图、物化视图、列存表。

**WORKLOAD级别索引推荐**

对于workload级别的索引推荐，用户可通过运行数据库外的脚本使用此功能，本功能将包含有多条DML语句的workload作为输入，最终生成一批可对整体workload的执行表现进行优化的索引。同时，本功能提供从日志中抽取业务数据SQL流水的功能。

**前提条件**

- 数据库状态正常、客户端能够正常连接。
- 当前执行用户下安装有gsql工具，该工具路径已被加入到PATH环境变量中。
- 若使用本功能提供的业务数据抽取功能，需提前将要收集的节点的GUC参数按如下设置：
  - log_min_duration_statement = 0
  - log_statement= 'all'

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
>  业务数据抽取完毕建议将上述GUC参数复原，否则容易导致日志文件膨胀。

**业务数据抽取脚本使用步骤**

1、按前提条件中要求设置相关GUC参数。<a id='步骤1'></a>

2、执行根据日志抽取SQL语句的功能，命令如下：

```
gs_dbmind component extract_log [l LOG_DIRECTORY] [f OUTPUT_FILE] [p LOG_LINE_PREFIX] [-d DATABASE] [-U USERNAME][--start_time] [--sql_amount] [--statement] [--json] [--max_reserved_period] [--max_template_num]
```

其中的输入参数依次为：

- LOG_DIRECTORY：pg_log的存放目录。
- OUTPUT_PATH：输出SQL流水文件文件的保存路径，即抽取出的业务数据存放的文件路径。
- LOG_LINE_PREFIX：指定每条日志信息的前缀格式。
- DATABASE：（可选）数据库名称，不指定默认所有数据库。
- USERNAME：（可选）用户名称，不指定默认所有用户。
- start_time：（可选）日志收集的开始时间，不指定默认所有文件。
- sql_amount：（可选）收集SQL数量的最大值，不指定默认收集所有SQL。
- statement：（可选）表示收集pg_log日志中statement标识开头的SQL，不指定默认不收集。
- json：（可选）指定收集日志的文件存储格式为SQL归一化后的json，不指定默认格式每条SQL占一行。
- max_reserved_period：（可选）指定json模式下，增量收集日志中保留的模板的最大的更新时长，不指定默认都保留，单位/天。
- max_template_num：（可选）指定json模式下保留的最大模板数量，不指定默认都保留。

使用示例：

```
gs_dbmind component extract_log $GAUSSLOG/pg_log/dn_6001 sql_log.txt '%m %c %d %p %a %x %n %e' -d postgres -U omm --start_time '2021-07-06 00:00:00' --statement
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> 若指定-d/-U参数，日志打印每条日志信息的前缀格式需包含%d、%u，若需要抽取事务，必须指定%p，详见log_line_prefix参数。max_template_num参数设置建议不超5000条，避免workload索引推荐执行时间过长。

3、将[1](#步骤1)中设置的GUC参数还原为设置前的值。

**索引推荐脚本使用步骤**

1、准备好包含有多条DML语句的文件作为输入的workload，文件中每条语句占据一行。用户可从数据库的离线日志中获得历史的业务语句。

2、运行本功能，命令如下：

```
gs_dbmind component index_advisor [p PORT] [d DATABASE] [f FILE] [--h HOST] [-U USERNAME] [-W PASSWORD][--schema SCHEMA]
[--max_index_num MAX_INDEX_NUM][--max_index_storage MAX_INDEX_STORAGE] [--multi_iter_mode] [--multi_node]  [--json] [--driver] [--show_detail]
```

其中的输入参数依次为：

- PORT：连接数据库的端口号。
- DATABASE：连接数据库的名字。
- FILE：包含workload语句的文件路径。
- HOST：（可选）连接数据库的主机号。
- USERNAME：（可选）连接数据库的用户名。
- PASSWORD：（可选）连接数据库用户的密码。
- SCHEMA：模式名称。
- MAX_INDEX_NUM：（可选）最大的索引推荐数目。
- MAX_INDEX_STORAGE：（可选）最大的索引集合空间大小。
- multi_node：（可选）指定当前是否为分布式数据库实例。
- multi_iter_mode：（可选）算法模式，可通过是否设置该参数来切换算法。
- json：（可选）指定workload语句的文件路径格式为SQL归一化后的json，默认格式每条SQL占一行。
- driver：（可选）指定是否使用python驱动器连接数据库，默认gsql连接。
- show_detail：（可选）是否显示当前推荐索引集合的详细优化信息。

例如：

```
gs_dbmind component index_advisor 6001 postgres tpcc_log.txt --schema public --max_index_num 10 --multi_iter_mode
```

推荐结果为一批索引，以多个创建索引语句的格式显示在屏幕上，结果示例。

```
create index ind0 on public.bmsql_stock(s_i_id,s_w_id);
create index ind1 on public.bmsql_customer(c_w_id,c_id,c_d_id);
create index ind2 on public.bmsql_order_line(ol_w_id,ol_o_id,ol_d_id);
create index ind3 on public.bmsql_item(i_id);
create index ind4 on public.bmsql_oorder(o_w_id,o_id,o_d_id);
create index ind5 on public.bmsql_new_order(no_w_id,no_d_id,no_o_id);
create index ind6 on public.bmsql_customer(c_w_id,c_d_id,c_last,c_first);
create index ind7 on public.bmsql_new_order(no_w_id);
create index ind8 on public.bmsql_oorder(o_w_id,o_c_id,o_d_id);
create index ind9 on public.bmsql_district(d_w_id);
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div> 
>
> multi_node参数需严格按照当前数据库架构进行指定，否则推荐结果不全，甚至导致无推荐结果。

###### AI4DB：慢SQL根因分析

**功能描述**

慢SQL一直是数据运维中的痛点问题，如何有效诊断慢SQL根因是当前一大难题，工具结合Vastbase自身特点融合了现网DBA慢SQL诊断经验，该工具可以支持慢SQL根因15+，能同时按照可能性大小输出多个根因并提供针对性的建议。

**语法格式**

用户可以通过 –help 选项获得该模式的帮助信息。

```
gs_dbmind component slow_query_diagnosis --help
```

```
usage:  [-h] -c DIRECTORY [--query SLOW_QUERY]
        [--start-time TIMESTAMP_IN_MICROSECONDS]
        [--end-time TIMESTAMP_IN_MICROSECONDS] [--retention-days DAYS]
        {show,clean}

Slow Query Diagnosis: Analyse the root cause of slow query

positional arguments:
  {show,clean}          choose a functionality to perform

optional arguments:
  -h, --help            show this help message and exit
  -c DIRECTORY, --conf DIRECTORY
                        set the directory of configuration files
  --query SLOW_QUERY    set a slow query you want to retrieve
  --start-time TIMESTAMP_IN_MICROSECONDS
                        set the start time of a slow SQL diagnosis result to
                        be retrieved
  --end-time TIMESTAMP_IN_MICROSECONDS
                        set the end time of a slow SQL diagnosis result to be
                        retrieved
  --retention-days DAYS
                        clear historical diagnosis results and set the maximum
                        number of days to retain data
```

**参数说明**

| 参数            | 参数说明                       | 取值范围                      |
| :-------------- | :----------------------------- | :---------------------------- |
| -h, –help       | 帮助命令                       | -                             |
| action          | 动作参数                       | show：结果展示clean：清理结果 |
| -c，–conf       | 配置目录                       | -                             |
| –query          | 慢SQL文本                      | *                             |
| –start-time     | 显示开始时间的时间戳，单位毫秒 | 非负整数                      |
| –end-time       | 显示结束时间的时间戳，单位毫秒 | 非负整数                      |
| –retention-days | 清理天数级结果                 | 非负实数                      |

**注意事项**

- 数据库运行正常。
- 指标采集系统运行正常。
- 已完成confpath目录初始化配置，可参考SERVICE子命令章节中配置初始化目录内容。

**示例**

- 仅启动慢SQL诊断功能（输出Top3根因），启动命令如下（更多用法参考对service子命令的说明）：

  ```
  gs_dbmind service start -c confpath --only-run slow_query_diagnosis
  ```

- 交互式慢SQL诊断，命令如下：

  ```
  gs_dbmind component slow_query_diagnosis show -c confpath --query SQL --start-time timestamps0 --end-time timestamps1
  ```

- 手动清理历史预测结果，命令如下：

  ```
  gs_dbmind component slow_query_diagnosis clean -c confpath --retention-days DAYS
  ```

- 停止已启动的服务，命令如下：

  ```
  gs_dbmind service stop -c confpath
  ```

**常见问题**

- 如果用户对没有执行过的慢SQL执行交互式诊断命令，则无法给出诊断结果。
- exporter指标采集功能没有启动时运行慢SQL诊断功能，此时功能无法正常运行。
- 配置文件中的参数重新设置后，需要重新启动服务进程才能生效。

###### 趋势预测

**功能描述**

趋势预测功能模块主要实现基于历史时序数据预测未来时序变化趋势。该模块框架解耦，可以实现不同预测算法的灵活替换，并且该模块功能可以实现不同特征时序的算法自动选择，支持线性特征时序预测LR回归算法和非线性特征预测ARIMA算法。目前该模块可以覆盖线性时序、非线性时序和周期时序的准确预测。

**语法格式**

```
gs_dbmind component forecast --help
```

```
usage:  [-h] -c DIRECTORY [--metric-name METRIC_NAME] [--host HOST] [--start-time TIMESTAMP_IN_MICROSECONDS] [--end-time TIMESTAMP_IN_MICROSECONDS] [--retention-days DAYS]
        {show,clean}

Workload Forecasting: Forecast monitoring metrics

positional arguments:
  {show,clean}          choose a functionality to perform

optional arguments:
  -h, --help            show this help message and exit
  -c DIRECTORY, --conf DIRECTORY
                        set the directory of configuration files
  --metric-name METRIC_NAME
                        set a metric name you want to retrieve
  --host HOST           set a host you want to retrieve
  --start-time TIMESTAMP_IN_MICROSECONDS
                        set a start time of for retrieving
  --end-time TIMESTAMP_IN_MICROSECONDS
                        set a end time of for retrieving
  --retention-days DAYS
                        clear historical diagnosis results and set the maximum number of days to retain data
```

**参数说明**

| 参数            | 参数说明                       | 取值范围                      |
| :-------------- | :----------------------------- | :---------------------------- |
| -h, –help       | 帮助命令                       | -                             |
| action          | 动作参数                       | show：结果展示clean：清理结果 |
| -c，–conf       | 配置目录                       | -                             |
| –metric-name    | 指定显示指标名，用于过滤       | -                             |
| –host           | 指定服务IP和端口号，用于过滤   | -                             |
| –start-time     | 显示开始时间的时间戳，单位毫秒 | 非负实数                      |
| –end-time       | 显示结束时间的时间戳，单位毫秒 | 非负实数                      |
| –retention-days | 保留结果天数                   | 非负实数                      |

**注意事项**

- 数据库运行正常。
- 指标采集系统运行正常。
- 已完成confpath目录初始化配置，可参考SERVICE子命令章节中配置初始化目录内容。

**示例**

- 仅启动趋势预测功能，启动命令如下（更多用法参考对service子命令的说明）：

  ```
  gs_dbmind service start -c confpath --only-run forecast
  ```

- 用户交互式趋势预测，查看timestamps0到timestamps1时间段内的预测结果，命令如下：

  ```
  gs_dbmind component forecast show -c confpath --start-time timestamps0 --end-time timestamps1
  ```

- 用户手动清理手动清理历史预测结果，命令如下：

  ```
  gs_dbmind component forecast clean -c confpath --retention-days DAYS
  ```

- 停止已启动的服务，命令如下：

  ```
  gs_dbmind service stop -c confpath
  ```

**常见问题**

- 综合实际业务与模型预测效果考虑，趋势预测时长建议不要太短，建议大于3600秒（如果指标采集周期为15秒，则数据量为240个），否则预测效果会变差，并且数据量极小时，服务会异常，因此默认配置为3600秒
- 配置文件中的参数重新设置后，需要重新启动服务进程才能生效。

###### SQL DIAG：慢SQL发现

**功能描述**

SQLdiag是一个SQL语句执行时间预测工具，通过模板化方法或者深度学习方法，实现在不获取SQL语句执行计划的前提下，依据语句逻辑相似度与历史执行记录，预测SQL语句的执行时间并以此发现异常SQL。

**语法格式**

```
gs_dbmind component sqldiag --help 
```

```
usage:   [-h] [-f CSV_FILE] [--predicted-file PREDICTED_FILE]
               [--model {template,dnn}] --model-path MODEL_PATH
               [--config-file CONFIG_FILE]
               {train,predict,finetune}

SQLdiag integrated by openGauss.

positional arguments:
  {train,predict,finetune}
                        The training mode is to perform feature extraction and
                        model training based on historical SQL statements. The
                        prediction mode is to predict the execution time of a
                        new SQL statement through the trained model.

optional arguments:
  -h, --help            show this help message and exit
  -f CSV_FILE, --csv-file CSV_FILE
                        The data set for training or prediction. The file
                        format is CSV. If it is two columns, the format is
                        (SQL statement, duration time). If it is three
                        columns, the format is (timestamp of SQL statement
                        execution time, SQL statement, duration time).
  --predicted-file PREDICTED_FILE
                        The file path to save the predicted result.
  --model {template,dnn}
                        Choose the model model to use.
  --model-path MODEL_PATH
                        The storage path of the model file, used to read or
                        save the model file.
  --config-file CONFIG_FILE
```

**参数说明**

| 参数            | 参数说明           | 取值范围      |
| :-------------- | :----------------- | :------------ |
| -f              | 训练或预测文件位置 | -             |
| –predicted-file | 预测结果存储位置   | -             |
| –model          | 模型选择           | template, dnn |
| –model-path     | 训练模型存储位置   | -             |

**注意事项**

- 需要保证用户提供训练数据。
- 如果用户通过提供的工具收集训练数据，则需要启用WDR功能，涉及到的参数为track_stmt_stat_level和log_min_duration_statement，具体情况见下面小结。
- 为保证预测准确率，用户提供的历史语句日志应尽可能全面并具有代表性。

**SQL流水采集方法**

本工具需要用户提前准备数据，训练数据格式如下，每个样本通过换行符分隔：

```
SQL,EXECUTION_TIME
```

预测数据格式如下：

```
SQL
```

其中SQL表示SQL语句的文本，EXECUTION_TIME表示SQL语句的执行时间，样例数据见sample_data中的train.csv和predict.csv。

用户可以按照要求格式自己收集训练数据，工具也提供了脚本自动采集（load_sql_from_rd），该脚本基于WDR报告获取SQL信息，涉及到的参数有log_min_duration_statement和track_stmt_stat_level：

- 其中log_min_duration_statement表示慢SQL阈值，如果为0则全量收集，时间单位为毫秒；
- track_stmt_stat_level表示信息捕获的级别，建议设置为track_stmt_stat_level='L0,L0'

参数开启后，可能占用一定的系统资源，但一般不大。持续的高并发场景可能产生5%以内的损耗，数据库并发较低的场景，性能损耗可忽略。下述脚本存在于sqldiag根目录（$GAUSSHOME/bin/components/sqldiag）中。

使用脚本获取训练集方式：

```
load_sql_from_wdr.py [-h] --port PORT --start_time START_TIME
                            --finish_time FINISH_TIME [--save_path SAVE_PATH]
```

**操作步骤**

1、提供历史日志以供模型训练

2、进行训练与预测操作。

基于模板法的训练与预测：

```
 gs_dbmind component sqldiag [train, predict] -f FILE --model template --model-path template_model_path 
```

基于DNN的训练与预测：

```
 gs_dbmind component sqldiag [train, predict] -f FILE --model dnn --model-path dnn_model_path
```

**示例**

- 使用提供的测试数据进行模板化训练：

```
gs_dbmind component sqldiag train -f ./sample_data/train.csv --model template --model-path ./template 
```

- 使用提供的测试数据进行模板化预测：

```
gs_dbmind component sqldiag predict -f ./sample_data/predict.csv --model template --model-path ./template --predicted-file ./result/t_result
```

- 使用提供的测试数据进行模板化模型更新：

```
gs_dbmind component sqldiag finetune -f ./sample_data/train.csv --model template --model-path ./template 
```

- 使用提供的测试数据进行DNN训练：

```
gs_dbmind component sqldiag train -f ./sample_data/train.csv --model dnn --model-path ./dnn_model 
```

- 使用提供的测试数据进行DNN预测：

```
gs_dbmind component sqldiag predict -f ./sample_data/predict.csv --model dnn --model-path ./dnn_model --predicted-file 
```

- 使用提供的测试数据进行DNN模型更新：

```
gs_dbmind component sqldiag finetune -f ./sample_data/train.csv --model dnn --model-path ./dnn_model
```

**常见问题**

- 训练场景失败：请检查历史日志文件路径是否正确，且文件格式符合上文规定。
- 预测场景失败：请检查模型路径是否正确。确保待预测负载文件格式正确。



# 快速入门

### 安装数据库

#### 字符安装（推荐）

##### 卸载数据库

**功能描述**

卸载Vastbase的过程包含卸载Vastbase和对Vastbase服务器的环境清理。

**注意事项**

需要使用数据库的操作系统用户，其他操作系统用户不允许执行卸载操作

**操作步骤**

1、以操作系统用户vastbase登录数据库节点。

```
su - vastbase
```

2、进入安装程序所在目录。

```
cd /soft/vb/vastbase-installer/
```

3、执行卸载命令。

```
./vastbase_installer --uninstall
```

4、如数据库正在运行会出现以下提示，选择Y即可停止数据库继续执行卸载

<div align="left"><img src="image/卸载提示.png" style="zoom:100%")</div>

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 卸载完成后，已安装的Vastbase程序（即$GAUSSHOME对应目录）和Vastbase相关环境变量将被删除，仅保留数据库实例。



# 工具参考

## 适配ECPG工具

**功能描述**

ECPG工具用于处理C中的嵌入式SQL语句，将包含嵌入式SQL语句的C程序转换成可以被C/C++编译器编译执行的C/C++程序。支持Vastbase SQL语句和ECPG SQL两种嵌入式SQL语句：

- 除部分SQL命令不支持外其余Vastbase SQL命令全部支持。以下为不支持的SQL命令：

  - 匿名块相关，包括开启匿名块和创建包含匿名块的函数。

```
    [DECLARE [declare_statements]] 
    BEGIN
    execution_statements  
    END;
    /
```

  - 不支持创建package。

    ```
    create package XXX
    ```

注：除以上SQL语句之外Vastbase支持的所有SQL语句都可以作为嵌入式SQL语句使用。

- ECPG SQL命令：详细的ECPG SQL语法使用及功能参考《PG11.2手册》（http://www.postgres.cn/docs/11/）。

  ECPG SQL语法列表如下：

  - ALLOCATE DESCRIPTOR ：分配一个SQL描述符区域

  - CONNECT ：建立一个数据库连接

  - DEALLOCATE DESCRIPTOR：释放一个SQL描述符区域

  - DECLARE ：定义一个游标

  - DESCRIBE ：得到有关一个预备语句或结果集的信息

  - DISCONNECT ： 终止一个数据库连接

  - EXECUTE IMMEDIATE ： 动态地准备和执行一个语句

  - GET DESCRIPTOR ： 从一个SQL描述符区域得到信息

  - OPEN ：打开一个动态游标

  - PREPARE ： 准备一个语句用于执行

  - SET AUTOCOMMIT ： 设置当前会话的自动提交行为

  - SET CONNECTION ： 选择一个数据库连接

  - SET DESCRIPTOR ： 在一个SQL描述符区域中设置信息

  - TYPE： 定义一种新数据类型

  - VAR ： 定义一个变量

  - WHENEVER ：指定一个要在一个SQL语句导致发生一个特定类别的情况时要采取的动作

  注：在Vastbase 中，ECPG SQL中的CALL和 IDENTIFIED改名为ECPGCALL和	ECPGIDENTIFIED。

**语法格式**

在C语言中使用嵌入式SQL语句的语法如下：

```
EXEC SQL stmt;
```

**参数说明**

stmt：一条SQL语句。

**使用流程**

1、安装EPCG工具及其依赖库。

2、编写一个C程序，后缀为.pgc，在文件中使用嵌入式SQL语句，例如在prog1.pgc文件中使用SQL命令。

```
EXEC SQL CREATE TABLE t1(id int, info text);  --定义表t1
```

3、使用ECPG工具将pgc文件，例如将prog1.pgc文件编译为prog1.c。

```
ecpg prog1.pgc
```

4、编译可执行程序。

```
cc -I/usr/local/pgsql/include -c prog1.c
cc -o prog1 prog1.o -L/usr/local/pgsql/lib -lecpg
```

5、运行可执行程序。

```
./prog1
```

**示例**

在C程序中通过嵌入式SQL实现数据库连接、创建表、插入、修改、查询、连接断开

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

EXEC SQL INCLUDE ../regression;

int main() {
  EXEC SQL BEGIN DECLARE SECTION;
  	int i1[3], i2[3], i3[3], i4;
  EXEC SQL END DECLARE SECTION;

  ECPGdebug(1, stderr);
  EXEC SQL CONNECT TO REGRESSDB1;

  EXEC SQL WHENEVER SQLWARNING SQLPRINT;
  EXEC SQL WHENEVER SQLERROR SQLPRINT;

  EXEC SQL CREATE TABLE insupd_test(a int, b int);

  EXEC SQL INSERT INTO insupd_test (a,b) values (1, 1);
  EXEC SQL INSERT INTO insupd_test (a,b) values (2, 2);
  EXEC SQL INSERT INTO insupd_test (a,b) values (3, 3) returning a into :i4;

  EXEC SQL UPDATE insupd_test set a=a+1 returning a into :i3;
  EXEC SQL UPDATE insupd_test set (a,b)=(5,5) where a = 4;
  EXEC SQL UPDATE insupd_test set a=4 where a=3;;

  EXEC SQL SELECT a,b into :i1,:i2 from insupd_test order by a;

  printf("changes\n%d %d %d %d\n", i3[0], i3[1], i3[2], i4);
  printf("test\na b\n%d %d\n%d %d\n%d %d\n", i1[0], i2[0], i1[1], i2[1], i1[2], i2[2]);

  EXEC SQL DISCONNECT ALL;

  return 0;
}
```





## 系统内部使用的工具

#### vb_basebackup

**功能描述**

Vastbase部署成功后，在数据库运行的过程中，可能会遇到各种问题及异常状态。Vastbase提供了vb_basebackup工具做基础的物理备份。vb_basebackup的实现目标是对服务器数据库文件的二进制进行拷贝，其实现原理使用了复制协议。远程执行vb_basebackup时，需要使用系统管理员账户。vb_basebackup当前支持热备份模式和压缩格式备份模式。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - vb_basebackup仅支持主机和备机的全量备份，不支持增量。
> - vb_basebackup当前支持热备份模式和压缩格式备份模式。
> - 若打开增量检测点功能且打开双写，vb_basebackup也会备份双写文件。
> - vb_basebackup在备份包含绝对路径的表空间时，如果在同一台机器上进行备份，可以通过tablespace-mapping重定向表空间路径或使用归档模式进行备份。
> - 若pg_xlog目录为软链接，备份时将不会建立软链接，会直接将数据备份到目的路径的pg_xlog目录下。
> - 备份过程中收回用户备份权限，可能导致备份失败或者备份数据不可用。
> - 如果因为网络临时故障等原因导致Server端无法应答，vb_basebackup将在最长等待120秒后退出。

**前提条件**

- 可以正常连接Vastbase数据库。
- 备份过程中用户权限没有被回收。
- pg_hba.conf中需要配置允许复制链接，且该连接必须由一个系统管理员建立。
- 如果xlog传输模式为stream模式，需要配置max_wal_senders的数量，至少有一个可用。
- 如果xlog传输模式为fetch模式，有必要把wal_keep_segments参数设置得足够高，这样在备份末尾之前日志不会被移除。
- 在进行还原时，需要保证各节点备份目录中存在备份文件，若备份文件丢失，则需要从其他节点进行拷贝。

**语法格式**

- 显示帮助信息

  ```
  vb_basebackup -? | --help
  ```

- 显示版本号信息

  ```
  vb_basebackup -V | --version
  ```

**参数说明**

vb_basebackup参数可以分为如下几类：

- -D directory

  备份文件输出的目录，必选项。

- 常用参数：

  - -c，–checkpoint=fast|spread：设置检查点模式为fast或者spread（默认）。

  - -l，–label=LABEL：为备份设置标签。

  - -P，–progress：启用进展报告。

  - -v，–verbose：启用冗长模式。

  - -V，–version：打印版本后退出。

  - -?，–help：显示vb_basebackup命令行参数。

  - -T，–tablespace-mapping=olddir=newdir：在备份期间将目录olddir中的表空间重定位到newdir中。为使之有效，olddir必须正好匹配表空间所在的路径（但如果备份中没有包含olddir中的表空间也不是错误）。olddir和newdir必须是绝对路径。如果一个路径凑巧包含了一个=符号，可用反斜线对它转义。对于多个表空间可以多次使用这个选项。

  - -F，–format=plain|tar：设置输出格式为plain（默认）或者tar。没有设置该参数的情况下，默认–format=plain。plain格式把输出写成平面文件，使用和当前数据目录和表空间相同的布局。当集簇没有额外表空间时，整个数据库将被放在目标目录中。如果集簇包含额外的表空间，主数据目录将被放置在目标目录中，但是所有其他表空间将被放在它们位于服务器上的相同的绝对路径中。tar模式将输出写成目标目录中的 tar 文件。主数据目录将被写入到一个名为base.tar的文件中，并且其他表空间将被以其 OID 命名。生成的tar包，需要用gs_tar命令解压。

  - -X，–xlog-method=fetch|stream：设置xlog传输方式。没有设置该参数的情况下，默认–xlog-method=stream。在备份中包括所需的预写式日志文件（WAL文件）。这包括所有在备份期间产生的预写式日志。fetch方式在备份末尾收集预写式日志文件。因此，有必要把wal_keep_segments参数设置得足够高，这样在备份末尾之前日志不会被移除。如果在要传输日志时它已经被轮转，备份将失败并且是不可用的。stream方式在备份被创建时流传送预写式日志。这将开启一个到服务器的第二连接并且在运行备份时并行开始流传输预写式日志。因此，它将使用最多两个由max_wal_senders参数配置的连接。只要客户端能保持接收预写式日志，使用这种模式不需要在主控机上保存额外的预写式日志。

  - -x，–xlog：使用这个选项等效于和方法fetch一起使用-X。

  - -Z ，–compress=level：启用对 tar 文件输出的 gzip 压缩，并且制定压缩级别（0 到 9，0 是不压缩，9 是最佳压缩）。只有使用 tar 格式时压缩才可用，并且会在所有tar文件名后面自动加上后缀.gz。

  - -z：启用对 tar 文件输出的 gzip 压缩，使用默认的压缩级别。只有使用 tar 格式时压缩才可用，并且会在所有tar文件名后面自动加上后缀.gz。

  - -t，–rw-timeout：设置备份期间checkpoint的时间限制，默认限制时间为120s。当数据库全量checkpoint耗时较长时，可以适当增大rw-timeout限制时间。

- 连接参数

  - -h，–host=HOSTNAME：指定正在运行服务器的主机名或者Unix域套接字的路径。

  - -p，–port=PORT：指定数据库服务器的端口号。可以通过port参数修改默认端口号。

  - -U，–username=USERNAME：指定连接数据库的用户。

  - -s，–status-interval=INTERVAL：发送到服务器的状态包的时间（以秒为单位）。

  - -w，–no-password：不出现输入密码提示。

  - -W，–password：当使用-U参数连接本地数据库或者连接远端数据库时，可通过指定该选项出现输入密码提示。

**示例**

```
vb_basebackup -D /home/vastbase/data/bak -h 127.0.0.1 -p 5432 
```

**从备份文件恢复数据**

当数据库发生故障时需要从备份文件进行恢复。因为vb_basebackup是对数据库按二进制进行备份，因此恢复时可以直接拷贝替换原有的文件，或者直接在备份的库上启动数据库。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> - 若当前数据库实例正在运行，直接从备份文件启动数据库可能会存在端口冲突，这时需要修改配置文件的port参数，或者在启动数据库时指定一下端口。
> - 若当前备份文件为主备数据库，可能需要修改一下主备之间的复制连接。即配置文件中的postgresql.conf中的replconninfo1、replconninfo2等。
> - 若配置文件postgresql.conf的参数data_directory打开且有配置，当使用备份目录启动数据库时候，data_directory和备份目录不同会导致启动失败。可以修改data_directory的值为新的数据目录，或者注释掉该参数。

若要在原库的地方恢复数据库，参考步骤如下：

1. 停止数据库服务器
2. 将原数据库和所有表空间复制到另外一个位置, 以备后面需要。
3. 清理原库中的所有或部分文件。
4. 使用数据库系统用户权限从备份中还原需要的数据库文件。
5. 若数据库中存在链接文件，需要修改使其链接到正确的文件。
6. 重启数据库服务器，并检查数据库内容，确保数据库已经恢复到所需的状态。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - 暂不支持备份文件增量恢复。
> - 恢复后需要检查数据库中的链接文件是否链接到正确的文件。

# 管理员指南

### 备份与恢复

#### PITR指定时间点恢复

**功能描述**

当数据库崩溃或希望回退到数据库之前的某一状态时，Vastbase的即时恢复功能（Point-In-Time Recovery，简称PITR）可以支持恢复到备份归档数据之后的任意时间点。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - PITR仅支持恢复到物理备份数据之后的某一时间点。
> - 仅主节点可以进行PITR恢复，备机需要进行全量build达成与主机数据同步。

**注意事项**

- 要求具有基于经过物理备份的全量数据文件。
- 要求具有基于已归档的WAL日志文件。

**PITR恢复流程**

1. 将物理备份的文件替换目标数据库目录。
2. 删除数据库目录下pg_xlog/中的所有文件。
3. 将归档的WAL日志文件复制到pg_xlog文件中（此步骤可以省略，通过配置recovery.conf恢复命令文件中的restore_command项替代）。
4. 在数据库目录下创建恢复命令文件recovery.conf，指定数据库恢复的程度。
5. 启动数据库。
6. 连接数据库，查看是否恢复到希望预期的状态。
7. 若已经恢复到预期状态，通过pg_xlog_replay_resume()指令使主节点对外提供服务。

**recovery.conf文件配置**

**归档恢复配置**

- restore_command = string

这个SHELL命令是获取WAL文件系列中已归档的WAL文件。字符串中的任何一个%f是用归档检索中的文件名替换， 并且%p是用服务器上的复制目的地的路径名替换。 任意一个%r是用包含最新可用重启点的文件名替换。

示例：

```
restore_command = 'cp /mnt/server/archivedir/%f %p'
```

- archive_cleanup_command = string

这个选项参数声明一个shell命令。在每次重启时会执行这个shell命令。 archive_cleanup_command为清理备库不需要的归档WAL文件提供一个机制。 任何一个%r由包含最新可用重启点的文件名代替。这是最早的文件，因此必须保留以允许恢复能够重新启动，因此所有早于%r的文件可以安全的移除。

示例：

```
archive_cleanup_command = 'pg_archivecleanup /mnt/server/archivedir %r'
```

需要注意的是，如果多个备服务器从相同的归档路径恢复时， 需要确保在任何一个备服务器在需要之前，不能删除WAL文件。

- recovery_end_command = string

这个参数是可选的，用于声明一个只在恢复完成时执行的SHELL命令。recovery_end_command是为以后的复制或恢复提供一个清理机制。

**恢复目标设置**

- recovery_target_name = string

此参数声明命名还原到一个使用pg_create_restore_point()创建的还原点。

示例:

```
recovery_target_name = 'restore_point_1'
```

- recovery_target_time = timestamp

此参数声明命名还原到一个指定时间戳。

示例：

```
recovery_target_time = '2020-01-01 12:00:00'
```

- recovery_target_xid = string

这个参数声明还原到一个事务ID。

示例：

```
recovery_target_xid = '3000'
```

- recovery_target_lsn = string

这个参数声明还原到日志的指定LSN点。

示例：

```
recovery_target_lsn = '0/0FFFFFF'
```

- recovery_target_inclusive = boolean

声明是否在指定恢复目标（true）之后停止，或在这（false）之前停止。该声明仅支持恢复目标为recovery_target_time、recovery_target_xid和recovery_target_lsn的配置。

示例：

```
recovery_target_inclusive = true
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>   
>
> - recovery_target_name、recovery_target_time、recovery_target_xid、recovery_target_lsn这四个配置项仅同时支持一项。
> - 如果不配置任何恢复目标，或配置目标不存在，则默认恢复到最新的WAL日志点。

#### vb_probackup

**功能描述**

vb_probackup是一个用于管理Vastbase数据库备份和恢复的工具。它对Vastbase实例进行定期备份，以便在数据库出现故障时能够恢复服务器。

- 可用于备份单机数据库，也可对主机或者主节点数据库备机进行备份，为物理备份。
- 可备份外部目录的内容，如脚本文件、配置文件、日志文件、dump文件等。
- 支持增量备份、定期备份和远程备份。
- 可设置备份的留存策略。

**前提条件**

- 可以正常连接Vastbase数据库。
- 若要使用PTRACK增量备份，需在postgresql.conf中手动添加参数“enable_cbm_tracking = on”。
- 为了防止xlog在传输结束前被清理，请适当调高postgresql.conf文件中wal_keep_segements的值。

**注意事项**

- 备份必须由运行数据库服务器的用户执行。
- 备份和恢复的数据库服务器的主版本号必须相同。
- 如果要通过ssh在远程模式下备份数据库，需要在本地和远程主机安装相同主版本的数据库，并通过ssh-copy-id remote_user@remote_host命令设置本地主机备份用户和远程主机数据库用户的无密码ssh连接。
- 远程模式下只能执行add-instance、backup、restore子命令。
- 使用restore子命令前，应先停止Vastbase进程。
- 当存在用户自定义表空间时，备份的时候要加上 –external-dirs 参数，否则，该表空间不会被备份。
- 当备份的规模比较大时，为了防止备份过程中timeout发生，请适当调整postgresql.conf文件的参数 session_timeout、wal_sender_timeout。并且在备份的命令行参数中适当调整参数–rw-timeout的值。
- 恢复时，使用-T选项把备份中的外部目录重定向到新目录时，请同时指定参数–external-mapping。
- 当使用远程备份时，请确保远程机器和备份机器的时钟同步，以防止使用–recovery-target-time恢复的场合,启动gaussdb时有可能会失败。
- 当远程备份有效时(remote-proto=ssh)，请确保-h和–remote-host指定的是同一台机器。当远程备份无效时，如果指定了-h选项，请确保-h指定的是本机地址或本机主机名。
- 当前暂不支持备份逻辑复制槽。

**命令说明**

- 打印vb_probackup版本。

```
vb_probackup -V|--version
vb_probackup version
```

- 显示vb_probackup命令的摘要信息。如果指定了vb_probackup的子命令，则显示可用于此子命令的参数的详细信息。

```
vb_probackup -?|--help
vb_probackup help [command]
```

- init：初始化备份路径backup-path中的备份目录，该目录将存储已备份的内容。backup-path必须为空目录。

```
vb_probackup init -B backup-path [--help]
```

- add_instance：在备份路径backup-path内初始化一个新的备份实例，并生成pg_probackup.conf配置文件，该文件保存了指定数据目录pgdata-path的vb_probackup设置。

```
vb_probackup add-instance -B backup-path -D pgdata-path --instance=instance_name
[-E external-directories-paths]
[remote_options]
[--help]
```

- del-instance：在备份路径backup-path内删除指定实例相关的备份内容。

```
vb_probackup del-instance -B backup-path --instance=instance_name
[--help]
```

- set-config：将指定的连接、压缩、日志等相关设置添加到pg_probackup.conf配置文件中，或修改已设置的值。不推荐手动编辑pg_probackup.conf配置文件。

```
vb_probackup set-config -B backup-path --instance=instance_name
[-D pgdata-path] [-E external-directories-paths] [--archive-timeout=timeout]
[--retention-redundancy=retention-redundancy] [--retention-window=retention-window] [--wal-depth=wal-depth]
[--compress-algorithm=compress-algorithm] [--compress-level=compress-level]
[-d dbname] [-h hostname] [-p port] [-U username]
[logging_options] [remote_options]
[--help]
```

- set-backup：将备份相关设置添加到backup.control配置文件中，或修改已设置的值。

```
vb_probackup set-backup -B backup-path --instance=instance_name -i backup-id
[--note=text] [pinning_options]
[--help]
```

- show-config：显示位于备份目录中的pg_probackup.conf配置文件的内容。可以通过指定–format=json选项，以json格式显示。默认情况下，显示为纯文本格式。

```
vb_probackup show-config -B backup-path --instance=instance_name
[--format=plain|json]
[--help]
```

- show：显示备份目录的内容。如果指定了instance_name和backup_id，则显示该备份的详细信息。可以通过指定–format=json选项，以json格式显示。默认情况下，备份目录的内容显示为纯文本格式。

```
vb_probackup show -B backup-path
[--instance=instance_name [-i backup-id]] [--archive] [--format=plain|json]
[--help]
```

- backup：创建指定实例的备份。

```
vb_probackup backup -B backup-path --instance=instance_name -b backup-mode
[-D pgdata-path] [-C] [-S slot-name] [--temp-slot] [--backup-pg-log] [-j threads_num] [--progress]
[--no-validate] [--skip-block-validation] [-E external-directories-paths] [--no-sync] [--note=text]
[--archive-timeout=timeout] [-t rwtimeout]
[logging_options] [retention_options] [compression_options]
[connection_options] [remote_options] [pinning_options]
[--help]
```

- restore：从备份目录backup-path中的备份副本恢复指定实例。如果指定了恢复目标选项，vb_probackup将查找最近的备份并将其还原到指定的恢复目标。否则，使用最近一次备份。

```
vb_probackup restore -B backup-path --instance=instance_name
[-D pgdata-path] [-i backup_id] [-j threads_num] [--progress] [--force] [--no-sync] [--no-validate] [--skip-block-validation]
[--external-mapping=OLDDIR=NEWDIR] [-T OLDDIR=NEWDIR] [--skip-external-dirs] [-I incremental_mode]
[recovery_options] [remote_options] [logging_options]
[--help]
```

- merge：将指定的增量备份与其父完全备份之间的所有增量备份合并到父完全备份。父完全备份将接收所有合并的数据，而已合并的增量备份将作为冗余被删除。

```
vb_probackup merge -B backup-path --instance=instance_name -i backup_id
[-j threads_num] [--progress] [logging_options]
[--help]
```

- delete：删除指定备份，或删除不满足当前保留策略的备份。

```
vb_probackup delete -B backup-path --instance=instance_name
[-i backup-id | --delete-expired | --merge-expired | --status=backup_status]
[--delete-wal] [-j threads_num] [--progress]
[--retention-redundancy=retention-redundancy] [--retention-window=retention-window]
[--wal-depth=wal-depth] [--dry-run]
[logging_options]
[--help]
```

- validate：验证恢复数据库所需的所有文件是否存在且未损坏。如果未指定instance_name，vb_probackup将验证备份目录中的所有可用备份。如果指定instance_name而不指定任何附加选项，vb_probackup将验证此备份实例的所有可用备份。如果指定了instance_name并且指定backup-id或恢复目标相关选项，vb_probackup将检查是否可以使用这些选项恢复数据库。

```
vb_probackup validate -B backup-path
[--instance=instance_name] [-i backup-id]
[-j threads_num] [--progress] [--skip-block-validation]
[--recovery-target-time=time | --recovery-target-xid=xid | --recovery-target-lsn=lsn | --recovery-target-name=target-name]
[--recovery-target-inclusive=boolean]
[logging_options]
[--help] 
```

- archive-push：将WAL文件复制到备份目录的相应子目录中。

```
vb_probackup archive-push -B backup_dir --instance=instance_name 
--wal-file-name=wal-file-name
[-j num-threads][--batch-size=batch_size]
[--archive-timeout=timeout]
[--no-ready-rename][--no-sync][--overwrite][--compress]
[--compress-algorithm=compression-algorithm] [--compress-level=compression_level]
[--remote-proto][--remote-host]
[--remote-port][--remote-path][--remote-user]
[--ssh-options]
[--help]
```

**参数说明**

通用参数

- command：vb_probackup除version和help以外的子命令：init、add-instance、del-instance、set-config、set-backup、show-config、show、backup、restore、merge、delete、validate。

- -?, –help：显示vb_probackup命令行参数的帮助信息，然后退出。子命令中只能使用–help，不能使用-?。

- -V, –version：打印vb_probackup版本，然后退出。

- -B backup-path, –backup-path=backup-path：备份的路径。系统环境变量：$BACKUP_PATH

- -D pgdata-path, –pgdata=pgdata-path：数据目录的路径。系统环境变量：$PGDATA

- –instance=instance_name：实例名。

- -i backup-id, –backup-id=backup-id：备份的唯一标识。

- –format=format：指定显示备份信息的格式，支持plain和json格式。
	默认值：plain

- –status=backup_status：删除指定状态的所有备份，包含以下状态：

  - OK：备份已完成且有效。
  - DONE：备份已完成但未经过验证。
  - RUNNING：备份正在进行中。
  - MERGING：备份正在合并中。
  - DELETING：备份正在删除中。
  - CORRUPT：部分备份文件已损坏。
  - ERROR：由于意外错误，备份失败。
  - ORPHAN：由于其父备份之一已损坏或丢失，备份无效。

- -j threads_num, –threads=threads_num：设置备份、还原、合并进程的并行线程数。

- –archive：显示WAL归档信息。

- –progress：显示进度。

- –note=text：给备份添加note。

**备份相关参数**

- -b backup-mode, –backup-mode=backup-mode：指定备份模式，支持FULL和PTRACK。

  - FULL：创建全量备份，全量备份包含所有数据文件。
  - PTRACK：创建PTRACK增量备份。

- -C, –smooth-checkpoint：将检查点在一段时间内展开。默认情况下，vb_probackup会尝试尽快完成检查点。

- -S slot-name, -slot=slot-name：指定WAL流处理的复制slot，此参数只能与-stream参数一起使用。

- –temp-slot：在备份的实例中为WAL流处理创建一个临时物理复制slot，它确保在备份过程中，所有所需的WAL段仍然是可用的。此参数只能与–stream参数一起使用。默认的slot名为pg_probackup_slot，可通过选项–slot/-S更改。

  默认的slot名为pg_probackup_slot，可通过选项–slot/-S更改。

- –backup-pg-log：将日志目录包含到备份中。此目录通常包含日志消息。默认情况下包含日志目录，但不包含日志文件。如果修改了默认的日志路径，需要备份日志文件时可使用-E参数进行备份，使用方法见下文。

- -E external-directories-paths, –external-dirs=external-directories-paths：将指定的目录包含到备份中。此选项对于备份位于数据目录外部的脚本、sql转储和配置文件很有用。如果要备份多个外部目录，请在Unix上用冒号分隔它们的路径。例如：-E /tmp/dir1:/tmp/dir2

- –skip-block-validation：关闭块级校验，加快备份速度。

- –no-validate：在完成备份后跳过自动验证。

- –no-sync：不将备份文件同步到磁盘。

- -note：给备份添加note。

- –archive-timeout=timeout：以秒为单位设置流式处理的超时时间。

  默认值：300

- -t rwtimeout：以秒为单位的连接的超时时间。

  默认值: 120

**恢复相关参数**

- -I, –incremental-mode=none|checksum|lsn：若PGDATA中可用的有效页没有修改，则重新使用它们。

  默认值：none

- –external-mapping=OLDDIR=NEWDIR：在恢复时，将包含在备份中的外部目录从_OLDDIR_重新定位到_NEWDIR_目录。_OLDDIR_和_NEWDIR_都必须是绝对路径。如果路径中包含“=”，则使用反斜杠转义。此选项可为多个目录多次指定。

- -T OLDDIR=NEWDIR, –tablespace-mapping=OLDDIR=NEWDIR：在恢复时，将表空间从_OLDDIR_重新定位到_NEWDIR_目录。_OLDDIR_和_NEWDIR_必须都是绝对路径。如果路径中包含“=”，则使用反斜杠转义。多个表空间可以多次指定此选项。当-T参数值为外部表空间目录时，必须搭配--external-mapping参数使用。

- –skip-external-dirs：跳过备份中包含的使用–external-dirs选项指定的外部目录。这些目录的内容将不会被恢复。

- –skip-block-validation：跳过块级校验，以加快验证速度。在恢复之前的自动验证期间，将仅做文件级别的校验。

- –no-validate：跳过备份验证。

- –force：允许忽略备份的无效状态。如果出于某种原因需要从损坏的或无效的备份中恢复数据，可以使用此标志。请谨慎使用。

**恢复目标相关参数**

- –recovery-target-lsn=lsn：指定要恢复到的lsn，当前只能指定备份的stop lsn。
- –recovery-target-name=target-name：指定要将数据恢复到的已命名的保存点，保存点可以通过查看备份中recovery-name字段得到。
- –recovery-target-time=time：指定要恢复到的时间，当前只能指定备份中的recovery-time。
- –recovery-target-xid=xid：指定要恢复到的事务ID，当前只能指定备份中的recovery-xid。
- –recovery-target-inclusive=boolean：当该参数指定为true时，恢复目标将包括指定的内容。当该参数指定为false时，恢复目标将不包括指定的内容。该参数必须和–recovery-target-name、–recovery-target-time、–recovery-target-lsn或–recovery-target-xid一起使用。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 当前不支持配置连续的WAL归档的PITR，因而使用这些参数会有一定限制，具体如下描述。 如果需要使用持续归档的WAL日志进行PITR恢复，请按照下面描述的步骤： 
>
> 1、将物理备份的文件替换目标数据库目录。 
>
> 2、删除数据库目录下pg_xlog/中的所有文件。
>
> 3、将归档的WAL日志文件复制到pg_xlog文件中（此步骤可以省略，通过配置recovery.conf恢复命令文件中的restore_command项替代）。 
>
> 4、在数据库目录下创建恢复命令文件recovery.conf，指定数据库恢复的程度。 
>
> 5、启动数据库。 
>
> 6、连接数据库，查看是否恢复到希望预期的状态。若已经恢复到预期状态，通过pg_xlog_replay_resume()指令使主节点对外提供服务。

**留存相关参数**

- –retention-redundancy=retention-redundancy：指定在数据目录中留存的完整备份数。必须为正整数。0表示禁用此设置。

  默认值：0

- –retention-window=retention-window：指定留存的天数。必须为正整数。0表示禁用此设置。

  默认值：0

- –wal-depth=wal-depth每个时间轴上必须留存的执行PITR能力的最新有效备份数。必须为正整数。0表示禁用此设置。

  默认值：0

- –delete-wal：从任何现有的备份中删除不需要的WAL文件。

- –delete-expired：删除不符合pg_probackup.conf配置文件中定义的留存策略的备份。

- –merge-expired：将满足留存策略要求的最旧的增量备份与其已过期的父备份合并。

- –dry-run：显示所有可用备份的当前状态，不删除或合并过期备份。



> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 可以和backup和delete命令一起使用这些参数。

**固定备份相关参数**

- –ttl=interval：指定从恢复时间开始计算，备份要固定的时间量。必须为正整数。0表示取消备份固定。支持的单位：ms、 s、 min、 h、 d（默认为s）。

  例如：–ttl=30d。

- –expire-time=time：指定备份固定失效的时间戳。必须是ISO-8601标准的时间戳。

  例如：–expire-time='2020-01-01 00:00:00+03'

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 如果要将某些备份从已建立的留存策略中排除，可以和backup和set-backup命令一起使用这些参数。

**日志相关参数**

- –log-level-console=log-level-console：设置要发送到控制台的日志级别。每个级别都包含其后的所有级别。级别越高，发送的消息越少。指定off级别表示禁用控制台日志记录。
	默认值：info

- –log-level-file=log-level-file：设置要发送到日志文件的日志级别。每个级别都包含其后的所有级别。级别越高，发送的消息越少。指定off级别表示禁用日志文件记录。
	默认值：off

- –log-filename=log-filename：指定要创建的日志文件的文件名。文件名可以使用strftime模式，因此可以使用%-escapes指定随时间变化的文件名。

  例如，如果指定了“pg_probackup-%u.log”模式，则pg_probackup为每周的每一天生成单独的日志文件，其中%u替换为相应的十进制数字，即pg_probackup-1.log表示星期一；pg_probackup-2.log表示星期二，以此类推。如果指定了–log-level-file参数启用日志文件记录，则该参数有效。

    默认值：“pg_probackup.log”

- –error-log-filename=error-log-filename：指定仅用于error日志的日志文件名。指定方式与–log-filename参数相同。此参数用于故障排除和监视。

- –log-directory=log-directory：指定创建日志文件的目录。必须是绝对路径。此目录会在写入第一条日志时创建。

  默认值：$BACKUP_PATH/log

- –log-rotation-size=log-rotation-size：指定单个日志文件的最大大小。如果达到此值，则启动vb_probackup命令后，日志文件将循环，但help和version命令除外。0表示禁用基于文件大小的循环。

  支持的单位：KB、MB、GB、TB（默认为KB）。

  默认值：0

- –log-rotation-age=log-rotation-age：单个日志文件的最大生命周期。如果达到此值，则启动vb_probackup命令后，日志文件将循环，但help和version命令除外。$BACKUP_PATH/log/log_rotation目录下保存最后一次创建日志文件的时间。0表示禁用基于时间的循环。

  支持的单位：ms、 s、 min、 h、 d（默认为min）。

  默认值：0

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 日志级别：verbose、log、info、warning、error和off。

**连接相关参数**

- -d dbname, –pgdatabase=dbname：指定要连接的数据库名称。该连接仅用于管理备份进程，因此您可以连接到任何现有的数据库。如果命令行、PGDATABASE环境变量或pg_probackup.conf配置文件中没有指定此参数，则vb_probackup会尝试从PGUSER环境变量中获取该值。如果未设置PGUSER变量，则从当前用户名获取。

  系统环境变量：$PGDATABASE

- -h hostname, –pghost=hostname：指定运行服务器的系统的主机名。如果该值以斜杠开头，则被用作到Unix域套接字的路径。

  系统环境变量：$PGHOST

  默认值：local socket

- -p port, –pgport=_port：指定服务器正在侦听连接的TCP端口或本地Unix域套接字文件扩展名。

  系统环境变量：$PGPORT

  默认值：5432

- -U username, –pguser=username：指定所连接主机的用户名。

  系统环境变量：$PGUSER

- -w, –no-password：不出现输入密码提示。如果主机要求密码认证并且密码没有通过其它形式给出，则连接尝试将会失败。 该选项在批量工作和不存在用户输入密码的脚本中很有帮助。

- -W password, –password=password：指定用户连接的密码。如果主机的认证策略是trust，则不会对系统管理员进行密码验证，即无需输入-W选项；如果没有-W选项，并且不是系统管理员，则会提示用户输入密码。



> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 可以和backup命令一起使用这些参数。

**压缩相关参数**

- --compress-algorithm=compress-algorithm：指定用于压缩数据文件的算法。取值包括zlib、pglz和none。如果设置为zlib或pglz，此选项将启用压缩。默认情况下，压缩功能处于关闭状态。

  默认值：none

  注意：

  - 当--compress-algorithm=zlib时，–compress-level参数取值不能为0。
  - 多线程备份不支持pglz压缩，即当--compress-algorithm=pglz时，不能使用–j参数，否则会报错。

- –compress-level=compress-level：指定压缩级别。该参数必须搭配–compress-algorithm一起使用，否则会报错。

  取值范围：0~9，

  - 0表示无压缩。
  - 1表示压缩比最小，处理速度最快。
  - 9表示压缩比最大，处理速度最慢。
  - 可与–compress-algorithm选项一起使用。

  默认值：1

- –compress：以–compress-algorithm=zlib和–compress-level=1进行压缩。



> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 可以和backup命令一起使用这些参数。

**远程模式相关参数**

- –remote-proto=protocol：指定用于远程操作的协议。目前只支持SSH协议。取值包括：

  ssh：通过SSH启用远程备份模式。这是默认值。

  none：显式禁用远程模式。

  如果指定了–remote-host参数，可以省略此参数。

- –remote-host=destination：指定要连接的远程主机的IP地址或主机名。

- –remote-port=port：指定要连接的远程主机的端口号。

  默认值：22

- –remote-user=username：指定SSH连接的远程主机用户。如果省略此参数，则使用当前发起SSH连接的用户。

  默认值：当前用户

- –remote-path=path：指定vb_probackup在远程系统的安装目录。

  默认值：当前路径

- –remote-libpath=libpath：指定vb_probackup在远程系统安装的lib库目录。

- –ssh-options=ssh_options：指定SSH命令行参数的字符串。例如：–ssh-options='-c cipher_spec -F configfile'

**备份流程**

1、初始化备份目录。在指定的目录下创建backups/和wal/子目录，分别用于存放备份文件和WAL文件。

```
vb_probackup init -B backup_dir
```

2、添加一个新的备份实例。vb_probackup可以在同一个备份目录下存放多个数据库实例的备份。

```
vb_probackup add-instance -B backup_dir -D data_dir --instance instance_name
```

3、创建指定实例的备份。在进行增量备份之前，必须至少创建一次全量备份。

```
vb_probackup backup -B backup_dir --instance instance_name -b backup_mode
```

4、从指定实例的备份中恢复数据。

```
vb_probackup restore -B backup_dir --instance instance_name -D pgdata-path -i backup_id
```

><div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
>- 如果因为网络临时故障等原因导致server端无应答,vb_probackup将在等待archive->timeout（默认300秒）后退出。
>
>- 如果备机lsn与主机有差别时，数据库会不停地刷以下log信息，此时应重新build备机。
>
>```
>LOG: walsender thread shut down
>LOG: walsender thread started
>LOG: received wal replication command: IDENTIFY_VERSION
>LOG: received wal replication command: IDENTIFY_MODE
>LOG: received wal replication command: IDENTIFY_SYSTEM
>LOG: received wal replication command: IDENTIFY_CONSISTENCE 0/D0002D8
>LOG: remote request lsn/crc: [xxxxx] local max lsn/crc: [xxxxx]
>```

# MySQL兼容性

#### **SELECT_LIST中可以使用非分组列**

**功能描述**

兼容MySQL、MariaDB中select_list可以使用非分组列。支持在select语句的目标列中，可以使用group by和order by中未列出的列。

**语法格式**

```
[ WITH [ RECURSIVE ] with_query [, ...] ] 
SELECT [/*+ plan_hint */] [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ] 
{ * | {expression [ [ AS ] output_name ]} [, ...] } 
[ FROM from_item [, ...] ] 
[ WHERE condition ] 
[ GROUP BY grouping_element [, ...] ] 
[ HAVING condition [, ...] ] 
[ WINDOW {window_name AS ( window_definition )} [, ...] ] 
[ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ] 
[ ORDER BY {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause ] [ NULLS { FIRST | LAST } ]} [, ...] ] 
[ LIMIT { [offset,] count | ALL } ] 
[ OFFSET start [ ROW | ROWS ] ] 
[ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ] 
[ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ]} [...] ];
```

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- vastbase_sql_mode='ONLY_FULL_GROUP_BY'（默认值）时，select list中不可以使用非分组列。

- vastbase_sql_mode=''时，select list中可以使用非分组列。

**兼容性**

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql dbcompatibility='B';
\c db_mysql
```

2、创建测试表student，并插入测试数据。

```
CREATE TABLE student(sid int,name varchar2(20),age int, class varchar2(20));
INSERT INTO student VALUES(1,'陈一',22,'java');
INSERT INTO student VALUES(2,'黄二',23,'python');
INSERT INTO student VALUES(3,'张三',21,'java');
INSERT INTO student VALUES(4,'李四',20,'C#');
INSERT INTO student VALUES(5,'王五',19,'python');
INSERT INTO student VALUES(6,'赵六',21,'java');
INSERT INTO student VALUES(7,'钱七',21,'java');
INSERT INTO student VALUES(8,'孙八',20,'C++');
INSERT INTO student VALUES(9,'杨九',19,'C++');
```

3、设置vastbase_sql_mode并验证。

```
set vastbase_sql_mode='';
SHOW vastbase_sql_mode; 
```

当结果显示如下信息，则表示设置完成。

```
-------------------

(1 row)
```

4、验证结果。

```
SELECT * FROM student GROUP BY class;
```

当结果显示如下信息，则表示验证完成。

```
 sid | name | age | class  
-----+------+-----+--------
   8 | 孙八 |  20 | C++
   4 | 李四 |  20 | C#
   2 | 黄二 |  23 | python
   1 | 陈一 |  22 | java
(4 rows)
```



#### SHOW CREATE TABLE 语法

**功能描述**

显示用于创建指定表的CREATE TABLE语句。

**语法格式**

```
SHOW CREATE TABLE [schema_name.]table_name;
```

**参数说明**

- schema_name：模式的名称。

- table_name ：指定表的名称。

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- 不支持显示分区表分区信息。

- 不支持临时表、外部表。

- 不支持显示表空间信息。

**兼容性**

完全兼容。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql dbcompatibility='B';
\c db_mysql
```

2、创建测试表test_myssql。

```
CREATE TABLE test_mysql(c1 int);
```

3、验证结果。

```
SHOW CREATE TABLE public.test_mysql;
```

当结果显示如下信息，则表示验证完成。

```
    Table    |         Create Table
-------------------+----------------------------------------------
 public.test_mysql |  CREATE TABLE test_mysql(c1 integer(32)  );
(1 row)
```



#### DATE_FORMAT函数

**功能描述**

DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据，返回根据格式字符串格式化的日期值字符串。

**语法格式**

```
DATE_FORMAT(date timestamp with time zone,format text)
DATE_FORMAT(date timestamp without time zone,format text)
```

**参数说明**

- date ：合法的日期。

- format ：规定日期/时间的输出格式。

以下说明符可用在 format 字符串中：

| 说明符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| %a     | 工作日的缩写名称 (Sun-Sat)                                   |
| %b     | 月份的缩写名称 (Jan-Dec)                                     |
| %c     | 月份，数字形式(0-12)                                         |
| %D     | 带有英语后缀的该月日期 (0th, 1st, 2nd, 3rd, ...)             |
| %d     | 该月日期, 数字形式 (00-31)                                   |
| %e     | 该月日期, 数字形式(0-31)                                     |
| %f     | 微秒 (000000-999999)                                         |
| %H     | 小时(00-23)                                                  |
| %h     | 小时(01-12)                                                  |
| %I     | 小时 (01-12)                                                 |
| %i     | 分钟,数字形式 (00-59)                                        |
| %j     | 一年中的天数 (001-366)                                       |
| %k     | 小时 (0-23)                                                  |
| %l     | 小时 (1-12)                                                  |
| %M     | 月份名称 (January-December)                                  |
| %m     | 月份, 数字形式 (00-12)                                       |
| %p     | 上午（AM）或下午（ PM）                                      |
| %r     | 时间 , 12小时制 (小时hh:分钟mm:秒数ss 后加 AM或PM)           |
| %S     | 秒 (00-59)                                                   |
| %s     | 秒 (00-59)                                                   |
| %T     | 时间 , 24小时制 (小时hh:分钟mm:秒数ss)                       |
| %U     | 周 (00-53), 其中周日为每周的第一天                           |
| %u     | 周 (00-53), 其中周一为每周的第一天                           |
| %V     | 周 (01-53), 其中周日为每周的第一天 ; 和 %X同时使用           |
| %v     | 周 (01-53), 其中周一为每周的第一天 ; 和 %x同时使用           |
| %W     | 工作日名称 (周日-周六)                                       |
| %w     | 一周中的每日 (0=周日-6=周六)                                 |
| %X     | 该周的年份，其中周日为每周的第一天, 数字形式,4位数;和%V同时使用 |
| %x     | 该周的年份，其中周一为每周的第一天, 数字形式,4位数;和%v同时使用 |
| %Y     | 年份, 数字形式,4位数                                         |
| %y     | 年份, 数字形式 (2位数)                                       |
| %%     | '%'文字字符                                                  |

**注意事项**

该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

完全兼容。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、调用函数验证结果。

```
SELECT DATE_FORMAT(now(),'%Y/%m/%d %H:%i:%s');
```

当结果显示如下信息，则表示验证完成。

```
     date_format     
-------------------------
 2022/06/29 09:00:13
(1 row)
```



#### DATE_ADD函数

**功能描述**

DATE_ADD() 函数向日期添加指定的时间间隔。

**语法格式**

```
DATE_ADD(date_input,INTERVAL expr unit)
```

**参数说明**

- date_input ：合法的日期表达式，用来指定起始时间，增加支持四种数据类型：time、timetz、timestamp和timestamptz。

- expr ：表达式，用来指定从起始日期添加或减去的时间间隔值。对于负值的时间间隔，它可以以一个'-'开头。

- unit：表示加上或减去的时间类型，比如年，月，日，周等，可参考下表type值。

以下表显示了type 和expr 参数的关系：

| type 值            | 预期的 expr 格式             |
| ------------------ | ---------------------------- |
| MICROSECOND        | MICROSECONDS                 |
| SECOND             | SECONDS                      |
| MINUTE             | MINUTES                      |
| HOUR               | HOURS                        |
| DAY                | DAYS                         |
| WEEK               | WEEKS                        |
| MONTH              | MONTHS                       |
| QUARTER            | QUARTERS                     |
| YEAR               | YEARS                        |
| SECOND_MICROSECOND | 'SECONDS.MICROSECONDS'       |
| MINUTE_MICROSECOND | 'MINUTES.MICROSECONDS'       |
| MINUTE_SECOND      | 'MINUTES:SECONDS'            |
| HOUR_MICROSECOND   | 'HOURS.MICROSECONDS'         |
| HOUR_SECOND        | 'HOURS:MINUTES:SECONDS'      |
| HOUR_MINUTE        | 'HOURS:MINUTES'              |
| DAY_MICROSECOND    | 'DAYS.MICROSECONDS'          |
| DAY_SECOND         | 'DAYS HOURS:MINUTES:SECONDS' |
| DAY_MINUTE         | 'DAYS HOURS:MINUTES'         |
| DAY_HOUR           | 'DAYS HOURS'                 |
| YEAR_MONTH         | 'YEARS-MONTHS'               |

**注意事项**

该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

完全兼容。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、调用函数。

```
SELECT DATE_ADD('2021-08-13',interval 1 DAY);
```

当结果显示如下信息，则表示验证完成。

```
       date_add        
-----------------------
 2021-08-14 00:00:00+08
(1 row)
```



####  数据类型

兼容MySQL数据类型如下所示：

| 类型     | 描述                                                         | 存储空间                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| binary   | BINARY类型是固定长度二进制字符串，与char相似，可存储字符。不同的是BINARY存储的是二进制值，BINARY无字符集的概念，对其排序和比较都是按照二进制值进行对比。BINARY（N）中的N指的是字节长度。N取值范围（1-255）。 | 最大为1GB                                                    |
| longtext | 变长字符串                                                   | 最大为1GB，但还需要考虑到列描述头信息的大小， 以及列所在元组的大小限制（也小于1GB），因此TEXT类型最大大小可能小于1GB。 |
| datetime | datetime[n]函数用于设置显示毫秒后面的多少位，n表示获取的位数，取值[1-6]。 | 8字节                                                        |
| longblob | 二进制大对象                                                 | 最大为4GB                                                    |

**注意事项**

- binary、datetime、longblob三个数据类型仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。
- longtext在Oracle和MySQL兼容模式下均支持。
- datetime[n]数据类型的实现依赖Vastbase现有timestamp数据类型，因此，在一些场景中，例如\d元命令中，datetime数据类型会被显示成timestamp类型。
- 当datetime[n]类型指定了小数位之后，如果datetime[n]类型的数据小数位都是0，则在Vastbase数据库中，受到timestamp数据类型的局限，其小数位上的0将不做显示。

**兼容性**



**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、创建测试binary类型的表test_mysql_type2并插入测试数据。

```
CREATE TABLE test_mysql_type2(c1 binary);
INSERT INTO test_mysql_type2 values('a');
INSERT INTO test_mysql_type2 values('张三');
```

3、验证binary数据类型。

```
SELECT * FROM test_mysql_type2;
```

当结果显示如下信息，则表示验证完成。

```
    c1
-----------------------
 \x61
 \xe5bca0e4b889
(2 rows)
```

4、创建测试longtext类型的表test_mysql_type3并插入测试数据。

```
CREATE TABLE test_mysql_type3(c1 longtext);
INSERT INTO test_mysql_type3 values('测试abc123');
```

验证longtext数据类型。

```
SELECT * FROM test_mysql_type3;
```

当结果显示如下信息，则表示验证完成。

```
   c1
------------------
 测试abc123
(1 row)
```

5、创建测试datetime类型的表test_mysql_type4并插入测试数据。

```
CREATE TABLE test_mysql_type4(c1 datetime);
INSERT INTO test_mysql_type4 values('2019-03-05 01:53:55.63');
```

6、验证datetime数据类型。

```
SELECT * FROM test_mysql_type4;
```

当结果显示如下信息，则表示验证完成。

```
     c1
--------------------------
 2019-03-05 01:53:55.63
(1 row)
```

#### DISTINCT列时可以使用非ORDER BY列

**功能描述**

兼容MySQL、MariaDB中distinct语句的目标列中，可以使用order by中未列出的列。

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- 利用GUC参数vastbase_sql_mode，控制该功能。
  - vastbase_sql_mode='ONLY_FULL_GROUP_BY'时，distinct list中不可以使用非分组列。
  - vastbase_sql_mode=''时，distinct list中可以使用非分组列。

**语法格式**

```
SELECT DISTINCT column1, column2
FROM table_name
WHERE [condition]
ORDER BY column3
```

**兼容性**

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
create  database  db_mysql  dbcompatibility 'B';
\c  db_mysql
```

2、创建测试表并插入数据。

```
create  table  test  (id  varchar(32)  ,names  varchar(32));
insert  into  test  values('1','zhangsan');
insert  into  test  values('12','lisi');
insert  into  test  values('2','wangwu');
insert  into  test  values('2','maliu');
```

 3、设置vastbase_sql_mode。

```
set  vastbase_sql_mode  ='';
show vastbase_sql_mode;
```

结果显示如下： 

```
 vastbase_sql_mode 
-------------------
 
(1 row)
```

4、执行查询。

```
select distinct(id) from test order by (id+0), (names+0);
```

结果显示如下： 

```
id 
----
 1
 2
 12
(3 rows)
```

#### 创建存储过程和函数时支持DEFINER

**功能描述**

定义存储过程、函数时支持语法DEFINER = user指定属主。

**前提条件**

该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

**语法格式**

- 存储过程

```
CREATE
[DEFINER = user]
PROCEDURE sp_name() 
routine_body
```

- 函数

```
CREATE
[DEFINER = user]
FUNCTION sp_name()
RETURNS type
routine_body
```

**参数说明**

- DEFINER = user：当创建存储过程、函数时指定SECURITY DEFINER、AUTHID DEFINER、AUTHID DEFINER或者SECURITY DEFINER时声明该函数将以DEFINER指定的用户的权限执行。

- user后面可以跟@'主机名'或者@'ip'，但并不校验主机名或者ip的合法性。

- sp_name() ：自定义的存储过程或者函数名称。

- routine_body：过程体代码块。


**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。
- 用户如果是有“系统管理员”角色，可以定义存储过程、函数的DEFINER 属性为任意用户。
- 非“系统管理员”创建存储过程、函数的时候，DEFINER属性只能定义为自己。
- 创建存储过程、函数definer指定的用户不存在时，则会报错。
- 存储过程的名称sp_name()与过程体的代码之间必须使用“as”或“is”。
- 存储过程的代码主块中，必须包裹在begin...end；的代码块中。
- SQL SECURITY 属性为DEFINER时，数据库中必须存在DEFINER指定的定义者用户，并且该定义者用户拥有对应的操作权限及引用的相关对象的权限，执行者以该用户的权限去执行存储过程、函数。
- CREATE OR REPLACE DEFINER = use创建存储过程、函数过程时，则会报错。
- 当使用CREATE DEFINER = user FUNCTION/PROCEDURE指定了所属用户时，后来又使用CREATE OR REPLACE进行替换函数存储过程、函数时，仍保留创建函数存储过程、函数时DEFINER指定的用户作为其属主。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
create  database  db_mysql  dbcompatibility  'B';
\c  db_mysql
```

2、创建普通用户definer1。

```
CREATE USER definer1 IDENTIFIED BY 'bigdata@123';
```

3、普通用户definer1创建函数指定定义者，创建成功，并执行函数成功。

```
CREATE DEFINER=definer1  function func() returns void
AS  $$
BEGIN
  raise info 'definer ';
END;
$$ LANGUAGE plpgsql  SECURITY definer;
```

6、给普通用户definer1赋予该函数的执行权限，普通用户definer1下执行该函数，执行成功。

```
grant EXECUTE on procedure func() to definer1;
\c - definer1
```

```
select func();
```

结果显示如下：

```
INFO:  definer 
CONTEXT:  referenced column: func

 func 
-------------
(1 row)
```

#### SELECT INTO OUTFILE语法

**功能描述**

select into outfile将查询到的数据导出到文件。

**语法格式**

```
SELECT ... INTO OUTFILE 'file_name'
[CHARACTER SET charset_name]
[export_options]
```

export_options:

```
[{FIELDS | COLUMNS}
[TERMINATED BY 'string']
[[OPTIONALLY] ENCLOSED BY 'char']
[ESCAPED BY 'char']
]
[LINES
[STARTING BY 'string']
[TERMINATED BY 'string']]
```

**参数说明**

- file_name：自定义文件名

- FILEDS子句：在FIELDS子句中有三个亚子句：TERMINATED BY、 [OPTIONALLY] ENCLOSED BY和ESCAPED BY。如果指定了FIELDS子句，则这三个亚子句中至少要指定一个。
  - TERMINATED BY：用来指定字段值之间的符号。例如："TERMINATED BY ',' "指定了逗号作为两个字段值之间的标志。
  - ENCLOSED BY：用来指定包裹文件中字符值的符号。例如："ENCLOSED BY ' " ' "表示文件中字符值放在双引号之间，若加上关键字OPTIONALLY表示所有的值都放在双引号之间。
  - ESCAPED BY：子句用来指定转义字符。例如："ESCAPED BY '\*' "将"\*"指定为转义字符，取代"\\"，如空格将表示为"*N"。
- LINES子句：在LINES子句中使用TERMINATED BY指定一行结束的标志，如"LINES TERMINATED BY '?' "表示一行以"?"作为结束标志。
- charset_name：字符集名称。
- GUC参数：secure_file_priv该参数为PG_SIGHUP级别，修改后仅在数据库服务reload后的会话中生效
  - secure_file_priv参数指定的导出目录必须是绝对路径且不能为已有文件。
  - secure_file_priv参数设置为空，则变量无效。
  - secure_file_priv参数设置为NULL（默认值），则禁用select into file导出操作。

**注意事项**

- select into outfile依赖SELECT语句IntoClause的相关功能。

- select into outfile依赖COPY到文件时的用户权限要求以及输出文件名要求。

- select into outfile依赖COPY到文件时可选参数功能。
- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。
- 用户必须具有导出文件的写入权限。
- 如果使用了FIELDS子句，则最少要指定分隔符、包裹字符或转义字符中的一项；如果使用了LINES子句则最少要指定行起始字符或结束符中的一项。

**示例**

1、修改参数secure_file_priv为空。

```
alter system set  secure_file_priv='';
select pg_reload_conf();
```

2、创建兼容MySQL的库db_mysql，并进入。

```
create  database  db_mysql  dbcompatibility  'B';
\c  db_mysql
```

3、创建测试表并写入数据。

```
create table test(id1 int, id2 char(10), id3 text);
insert into test values(1,'a','zhangsan');
insert into test values(2,'b','lisi');
insert into test values(3,'c','wangwu'); 
```

 4、用户有文件权限，直接导出并查看。

```
select * into outfile '/home/vastbase/test.txt' fields terminated by ',' optionally enclosed by '"' lines starting by '<<' terminated by '\r\n' from test;
```

查看文件。

```
cat /home/vastbase/test.txt
<<1,"a     ","zhangsan"
<<2,"b     ","lisi"
<<3,"c     ","wangwu"
```

#### UTF8MB4编码字符集

**功能描述**

UTF8MB4用来兼容4字节的unicode的字符集。Vastbase G100版本在如下场景中兼容UTF8MB4：

- 初始化数据库，执行initdb命令的场景。

- 创建数据库的语句中。

- 客户端可设置client_encoding 参数为 utf8mb4或utf-8mb4。

**背景信息**

unicode是一种国际组织制定能容纳所有文字和符号的字符编码方案。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。

**语法格式**

- 初始化数据库，执行initdb命令的场景。

```
-E | --encoding=UTF8MB4 | UTF-8MB4
```

- 创建数据库的语句中。

```
CREATE DATABASE testdb1 ENCODING 'UTF8MB4 | UTF-8MB4';
```

- 客户端可设置client_encoding 参数为 utf8mb4或utf-8mb4。

```
set client_encoding='UTF8MB4 |UTF-8MB4 ';
```

**兼容性**

完全兼容。

**示例**

- 初始化时指定字符集（操作系统执行）。

```
mkdir ~/test1
vb_initdb -w Aa123456 -D ~/test1 --nodename='vbnode1' --encoding=utf8mb4
```

- 创建数据库时指定字符集。

```
create database dbutf8mb4 with template=template0 encoding='utf8mb4' lc_ctype='C' lc_collate='C';
```

- 客户端设置指定的字符集。

```
set client_encoding='utf8mb4';
```

#### AUTO_INCREMENT自增列

**功能描述**

auto_increment语法用于生成自增列，一般出现在创建表语句和修改表语句中。

**语法格式**

- 创建表语句

```
create  table  t1  (id  int  primary  key  auto_increment,  b  int);
```

- 修改表语句

```
alter  table  t1  auto_increment  =  ai_val;
```

**参数说明**

- id（自增列）：t1表的id列为自增列，即对该表插入数据时，可不指定id列的值，数据库内部会自动为其分配自增值。

- ai_val：该值大于自增字段最大值时，修改才生效。

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- 创建表语句

  - 默认情况下，自增列的初始值为1，增量值为1。
  - 列类型表支持以下三种数据类型：

  | 模式             | 描述                                      |
  | ---------------- | ----------------------------------------- |
  | int2/smallint    | -32768至32767                             |
  | int4/int/integer | -2147483648至2147483647                   |
  | int8/bigint      | -9223372036854775808至9223372036854775807 |

  - 一张表只允许存在一个auto_increment字段。
  - auto_increment字段必须是主键字段或联合主键字段之一。
  - 对表插入数据时，若指定了auto_increment字段的值，且该值大于表中该自增列的最大值时，需要更新自增列的下一个值为当前插入数据值加1。
  - Vastbase G100 V2.2版本仅支持insert单行数据，暂不支持insert多行和insert...select。
  - 对表插入数据时，若指定auto_increment字段为NULL或0，则依旧触发自增机制。
  - 在MySQL兼容模式下，Serial类型字段与auto_increment类型字段特性一致。
  - 自增列可以插入负值或更新负值。
  - 自增列的值被更新后无法回退，即使其所在的事务后续回滚依旧如此。多个session并发插入时应保证可用性，需要慎重考虑插入操作导致自增值更新所带来的后果。

- 修改表语句

  - MySQL兼容模式下一张表只允许存在一个auto_increment字段，数据库会自动找到对应字段，修改其自增属性。
  - 修改语句与插入语句都可能改变下一个自增值，需要加锁。
  - Vastbase G100 V2.2版本仅支持修改普通表和分区表的auto_increment属性。不支持物化视图，复合类型等其他类型的关系。

**兼容性**

完全兼容。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql dbcompatibility='B';
\c db_mysql
```

2、创建带有auto_increment字段的表，指定主键。

```
create table test1(a int primary key auto_increment, b int);
```

3、插入数据进行测试。

```
insert into test1(b) values(1);
insert into test1(b) values(1);
insert into test1 values(0,3);   --自增
insert into test1 values(NULL,4);  --自增
insert into test1 values(10000,5);  --此处改变自增列的下一个值为10001
insert into test1(b) values(6);
insert into test1 values(10,7);  --此处由于10较小，不改变序列下一个值
insert into test1(b) values(8);
```

4、查询结果。

```
select * from test1;
```

结果显示如下：

```
  a  | b 
-------+---
   1 | 1
   2 | 1
   3 | 3
   4 | 4
 10000 | 5
 10001 | 6
  10 | 7
 10002 | 8
(8 rows)
```

#### CURDATE函数

**功能描述**

curdate函数用于获取当前时间，返回年月日。

**语法格式**

```
select curdate()
```

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- 输出类型：DATE

- 输出格式：'YYYY-MM-DD'

**兼容性**

完全兼容。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、执行函数验证。

```
select curdate();
```

结果返回如下：

```
  curdate   
------------
 2022-07-25
(1 row)

```

#### YEARWEEK函数

**功能描述**

yearweek函数获取年份和周数。

**语法格式**

```
YEARWEEK(date,mode)
```

**参数说明**

- date：提取年和周的日期或日期时间。

- mode：它指定一周中的哪一天开始。

下表描述了mode参数的工作方式：

| 模式 | 一周的第一天 | 范围 | 初始周计算规则   |
| ---- | ------------ | ---- | ---------------- |
| 0    | Sunday       | 0-53 | 今年有一个星期天 |
| 1    | Monday       | 0-53 | 今年有四天或以上 |
| 2    | Sunday       | 1-53 | 今年有一个星期天 |
| 3    | Monday       | 1-53 | 今年有四天或以上 |
| 4    | Sunday       | 0-53 | 今年有四天或以上 |
| 5    | Monday       | 0-53 | 今年有一个星期一 |
| 6    | Sunday       | 1-53 | 今年有四天或以上 |

**兼容性**

完全兼容。

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- 入参需要支持time、timestamp和date等时间类型。

**示例**

创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

示例1：在14/07/2022使用Year()函数查找当前年和周。

```
SELECT YEARWEEK(NOW()) AS Current_YearWeek;
```

当前年为2022，星期数为28，结果返回如下：

```
 Current_YearWeek 
------------------
           202230
(1 row)
```

示例2：使用YEARWEEK()函数从给定的日期时间查找年份和星期。

```
SELECT YEARWEEK('2018-04-22 08:09:22') AS Year_Week ;
```

年份是2018，星期数为16，结果返回如下：

```
-----------
 Year_Week 
-----------
  201816 
-----------
```

#### TO_DAYS函数

**功能描述**

to_days()函数用于给定一个日期，返回一个天数（自0001-01-01以来的天数）。

**语法格式**

```
TO_DAYS(date)
```

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- to_days函数的入参需要支持time，timestamp，date等时间类型。

- to_days函数的返回值类型是整型。

- 如果输入参数是timestamp或其他包含日期和时间的类型，返回的是整数，并且对结果进行向下取整。

- Vastbase定义0001-01-01为366（MySQL定义0000-01-01为1），所以两者计算结果一致。

**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、执行函数验证。

```
select to_days('2010-01-01 12:00:00');
```

结果返回如下：

```
 to_days 
---------
  734138
(1 row)
```

#### FIND_IN_SET()函数

**功能描述**

find_in_set(str,strlist)函数可以查询参数1（str）在参数2（strlist）根据'，'分隔列表中第一次出现的位置。

**语法格式**

```
FIND_IN_SET(str,strlist)
```

**参数说明**

- str：要查询的字符串。

- strlist：字段名参数以“,”分隔如(1,2,6,8,10,22)。

- 查询字段（strlist）中包含（str）的结果，返回结果为null或记录。

**注意事项**

该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。



**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、执行函数验证。

```
select find_in_set('','1,,2');
```

结果返回如下：

```
 find_in_set 
-------------
           2
(1 row)
```

#### REPLACE INTO语法

**功能描述**

replace是MySQL的一个扩展语法，它的工作原理与insert几乎相同，不同点在于表中存在唯一性约束时，replace into先删除冲突行，再插入新行。

**语法格式**

```
REPLACE  [INTO]  tbl_name  VALUES   …
REPLACE  [INTO]  tbl_name  VALUE  {expr  |  DEFAULT}   …
REPLACE  [INTO]  tbl_name  SET  col_name  =  value  [,  col_name  =  value  ]...
REPLACE  [INTO]  tbl_name  SELECT
```

**注意事项**

- 该功能仅在数据库兼容模式为MySQL时能够使用（即创建DB时DBCOMPATIBILITY='B'），在其他数据库兼容模式下不能使用该特性。

- 主体（用户）在使用replace语句，必须对操作的表（客体）具有insert和delete权限。

- 不能将要做replace操作的表通过子查询语句的形式，作为replace操作的目标值，例如以下写法是错误的：

```
REPLACE INTO test VALUES (1, 'Old', select aTime from test where id =2；
```

- replace语句是原MySQL数据库中语法，适用于行存表，针对Vastbase的列存表和MOT表是否支持replace语法，Vastbase G100 V2.2版本对该功能不做硬性要求。

- 在MySQL数据库中replace支持使用带有逗号分隔的分区、子分区或两者名称列表的partition子句进行显式分区选择。与insert一样，如果无法将新行插入这些分区或子分区中的任何一个，则replace语句将失败，错误为“ Found a row not matching the given partition set”。由于目前Vastbase无法在insert的时候显式指定分区，故Vastbase G100 V2.2版本对该功能不做硬性要求。当Vastbase实现insert 语法可以显式指定分区的操作后，replace也同步具备了该功能特性。



**示例**

1、创建兼容MySQL的库db_mysql，并进入。

```
CREATE DATABASE db_mysql DBCOMPATIBILITY='B';
\c db_mysql
```

2、创建一张表，并指定主键。

```
CREATE TABLE test (
id int,
id2 int,
name varchar(50) DEFAULT NULL,
PRIMARY KEY(id)
);
```

 3、插入测试数据，并查询结果。

```
replace test  values(1,1000,'test1');
replace test  values(2,2000,'test2');
replace test  values(3,3000,'test3');
replace test  values(4,4000,'test4');
select * from test;
```

结果返回如下：

```
----+------+-------
  1 | 1000 | test1
  2 | 2000 | test2
  3 | 3000 | test3
  4 | 4000 | test4
(4 rows)
```

 4、执行replace 操作的数据，会与主键产生冲突。

```
replace test  values(1,4000,'test5');
```

5、查询ID为1数据是否被替换。

```
select * from test;
```

当结果显示如下信息，则表示替换成功。

```
 id | id2  | name  
----+------+-------
  2 | 2000 | test2
  3 | 3000 | test3
  4 | 4000 | test4
  1 | 4000 | test5
(4 rows)
```

> <div align="left"><img src="image/image2.png" style="zoom:20%")</div>
>
> 如果表包含多个唯一索引，并且新行在不同的唯一索引中重复了不同旧行的值，则replace的单行可能出现替换多个旧行的结果（新插入一行，删除了多行）。

#### 字符串类型的数字可按照数字顺序排序

**功能描述**

数据定义的是varchar类型，实际存放的是字符串类型的数字，Vastbase可按数字顺序进行排序。

**语法格式**

```
SELECT [column] FROM [table] order by (column+0);
```

**参数说明**

column+0：表示将字符串排序方式改为按照数字排序的语法。

**注意事项**

无。

**示例**

1、创建测试表并插入测试数据。

```
create table test (id varchar(32) ,names varchar(32));
insert into test values('1','zhangsan');
insert into test values('12','lisi');
insert into test values('2','wangwu');
```

2、正常查询。 

```
select * from test;
```

结果显示如下：

```
 id |  names   
----+----------
 1  | zhangsan
 12 | lisi
 2  | wangwu
(3 rows)
```

3、排序查询进行对比。

```
select * from test order by (id+0);
```

结果显示如下，字段id按数字顺序排序：

```
 id |  names   
----+----------
 1  | zhangsan
 2  | wangwu
 12 | lisi
(3 rows)
```

#### YEAR函数

**功能描述**

该功能是为了获取给定时间的年。函数参数time的类型是：date，timestamp，timestamptz，time，timetz等类型。返回值是整型类型。

**语法格式**

```
YEAR(date)
```

**注意事项**

- 若函数的参数是time类型时，由于time类型不包含年月日，按照MySQL的处理，返回当前的年份和月份。

- 输入null时，返回值为空。

- 输入的时间格式非法时，报错信息为时间格式语法异常。

- 数据的时间超范围时，报错信息为输入的时间范围异常。
- 具备该函数的访问权限，例如Year(time)函数如果位于pg_catalog模式下，用户需要具备以下权限：
  - pg_catalog模式的usage权限。
  - Year(time)函数的excute权限。

**兼容性**

完全兼容。

**示例**

```
select year(current_date);
```

结果返回如下：

```
 year 
------
 2022
(1 row)
```

#### MONTH函数

**功能描述**

该功能是为了获取给定时间的月份。函数参数time的类型是：date，timestamp，timestamptz，time，timetz等类型。返回值是整型类型。

**语法格式**

```
MONTH(date)
```

**注意事项**

- 若函数的参数是time类型时，由于time类型不包含年月日，按照MySQL的处理，返回当前的年份和月份。

- 输入null时，返回值为空。

- 输入的时间格式非法时，报错信息为时间格式语法异常。

- 数据的时间超范围时，报错信息为输入的时间范围异常。

- 具备该函数的访问权限，例如Month(time)函数如果位于pg_catalog模式下，用户需要具备以下权限：

  - pg_catalog模式的usage权限。

  - Month(time)函数的excute权限。

**兼容性**

完全兼容。

**示例**

```
select month(current_date);
```

结果返回如下：

```
 month
-------
   5
(1 row) 
```



# Oracle兼容性

## SQL语法

### 数据类型

#### BINARY_FLOAT数据类型

**功能描述**

binary_float类型是Oracle支持的一种浮点数类型，大小为4字节。本功能是支持Vastbase数据库能够使用binary_float这一类型,并且该数据类型也可以包含在plpgsql中使用。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

- 表的增删改查支持binary_float数据类型

1、创建测试表并插入数据。

```
CREATE  TABLE test(id int, var binary_float);
INSERT INTO test VALUES(1,1.25),(2,8.234),(3,0.1234);
```

2、查询表的数据。

```
select * from test;
```

返回结果为：

```
 id |  var
----+-------
  1 |  1.25
  2 | 8.234
  3 | .1234
(3 rows)

```

3、更新表中的数据并查询结果。

```
UPDATE test SET var = 7.321 WHERE id = 2;
SELECT * FROM test;
```

返回结果为：

```
 id |  var
----+-------
  1 |  1.25
  3 | .1234
  2 | 7.321
(3 rows)
```

4、更新表中的数据并查询结果。

```
DELETE FROM test WHERE id = 3;
SELECT * FROM test;
```

返回结果为：

```
 id |  var
----+-------
  1 |  1.25
  2 | 7.321
(2 rows)
```

- PL/PGSQL中支持binary_float数据类型

1、创建存储过程。

```
create or replace function test()
return binary_float as 
declare
    a binary_float := 1.23;
    b binary_float :=3.45;
begin
    return a + b;
end;
/
```

2、查询结果。

```
SELECT test();
```

返回结果为：

```
 test
------
 4.68
(1 row)
```

#### DATE数据类型

**功能描述**

date数据类型用于存储日期和时间信息，对于每一个date值：

- 展示格式为：YYYY/MM/DD，也可以是YYYY/MM/DD HH24:MI:SS
- 存储格式只有一种：YYYY/MM/DD HH24:MI:SS
- date类型的值在数据库图形界面中可以有不同的显示格式（具体格式由工具设置决定），但其实际存储格式只是其中一种，当只存储年月日时，date实际存储的是:年月日0时0分0秒，在图形界面中，其展示格式为：YYYY/MM/DD。
- date类型对插入带有毫秒的部分直接去除毫秒，不进行四舍五入。
- 支持date数据类型和to_char字符串的转换。

**注意事项**

无

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table t1(id int,col date,col1 timestamp);
insert into t1 select 1,current_timestamp,current_timestamp from dual;
```

2、将date数据类型转换为to_char类型，并查询结果。

```
select id,to_char(col,'yyyy-mm-dd hh24:mi:ss'),to_char(col1,'yyyy-mm-dd hh24:mi:ss.ff6') from t1;
```

返回结果如下(其中col字段去除毫秒，不会做四舍五入)：

```
 id |       to_char       |          to_char
----+---------------------+----------------------------
  1 | 2022-07-04 17:15:16 | 2022-07-04 17:15:16.174639
(1 row)
```

3、获取时间的年份。

```
select to_char(col,'yyyy') as nowyear from t1;
```

返回结果为当前年份：

```
 nowyear
---------
 2022
(1 row)
```

#### TIMESTAMP数据类型


**功能描述**

该数据类型是DATE数据类型的扩展，它可以存储更加精确的时间值。Vastbase G100支持14位(秒)或者17位（毫秒）数字格式数输入。


**注意事项**

无

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table test_timestamp(a timestamp,b timestamptz);
insert into test_timestamp values('2022-1-12 12:23:23','2022-1-12 12:23:23');
insert into test_timestamp values('20220112122323','20220112122323');
```

2、查询表中数据。

```
select * from test_timestamp ;
```

返回结果如下：

```
          a          |           b            
---------------------+------------------------
 2022-01-12 12:23:23 | 2022-01-12 12:23:23+08
 2022-01-12 12:23:23 | 2022-01-12 12:23:23+08
(2 rows)
```

#### BFILE数据类型

**功能描述**

bfile用于存储服务器文件系统中的物理二进制文件数据对象。bfile文件存储在操作系统文件中，而不是在数据库中，bfile列存储对操作系统文件的引用。操作系统访问的任何存储设备都可以保存bfile数据，包括硬盘驱动器、CD-ROM、PhotoCD和DVD。如果操作系统支持对操作系统文件的流模式访问，则数据库可以访问bfile。

bfile类型的数据是：

- 在应用程序运行时不会更改的二进制数据，例如图形。
- 加载到其他大型对象类型（例如BLOB或CLOB）中的数据，可以在其中操作数据。
- 适用于字节流访问的数据，例如多媒体数据。

在对bfile类型的SQL操作中，需要支持bfilename函数。bfilename函数返回一个bfile文件定位器，该定位器指向操作系统中一个物理文件。
bfilename函数主要用于bfile类型数据的构造，构造的数据源为一个directory对象和一个操作系统物理二进制文件名，函数语法格式为：

```
BFILENAME('directory', 'filename')
```

- directory对象：指向一个操作系统的物理目录。该目录不应为数据库数据目录，以及操作系统控制文件、日志文件和其他系统文件所在的目录。必须在bfilename函数调用前创建，并且对名区分大小写。
- filename：文件名，操作系统上一个物理二进制文件，由于bfile为只读数据类型，必须在访问文件数据前创建该文件。

bfile数据类型主要用于对bfilename函数构造的数据进行存储，然后调用dbms_lob内置包的接口对该数据进行操作。bfile数据类型的功能主要分为三个部分：

- bfile数据的存储和打印。
- bfile数据的使用，主要为对操作系统物理文件的读取过程，即分为以下三部分：
  - 打开操作系统物理文件。bfile为只读数据类型，因此打开文件的模式只能为只读。
  - 对文件进行读取。可根据参数设置来决定读取文件的字节数，如需读取整个文件，可先调用dbms_lob包的getlength，函数获取文件的大小。需注意的是，单次读取文件的字节数不能超过32767字节，如文件过大，可通过设置参数对文件进行多次读取。
  - 关闭文件。对打开的物理文件进行关闭。

bfile数据的修改：对于bfile数据的持久引用（如存储在表中），bfile数据可以作为表的列值进行修改。

**注意事项**
bfilename函数依赖openGauss自带的directory功能。

**使用流程**

1、创建directory对象，创建需访问的文件并将其置于directory对象所指向的操作系统目录中。

2、创建包含bfile数据类型列的表。

3、调用bfilename函数对数据进行构造并插入到表中进行存储。

**示例**

1、操作系统环境下创建文件，并输入数据。

```
 vi /home/vastbase/bfile.data
 cat /home/vastbase/bfile.data
```

文件内容为：

```
张三
李四
```

2、在数据库中执行如下命令创建目录和表。

```
drop directory d_bfile;
drop table testbfile1;
create directory d_bfile as '/home/vastbase';
create table testbfile1(id number,bfile_name bfile);
```

3、插入数据。

```
insert into testbfile1 values (1,bfilename('d_bfile','bfile.data'));
```

4、查询数据。

```
select * from  testbfile1;
```

返回结果为：

```
 id |            bfile_name
----+-----------------------------------
  1 | bfilename('d_bfile','bfile.data')
```


### ^=运算符

**功能描述**

实现oracle^=运算符，即不等于运算符，类似于!=和<>。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table t_ysf4(
  id int,
  col_varchar varchar(30),
  col_int int,
  col_date date
  );
  insert into t_ysf4 values(1,'1',1,'1997-02-20');
  insert into t_ysf4 values(2,'2',2,'2007-02-20');
```

2、使用^=运算符。

```
select * from t_ysf4 where col_int ^='1';
```

返回结果如下：

```
 id | col_varchar | col_int |      col_date
----+-------------+---------+---------------------
  2 | 2           |       2 | 2007-02-20 00:00:00
(1 row)
```

4、使用^=运算符进行判断。

```
select '1' ^= '2';
```

返回结果为：

```
 ?column?
----------
 t
(1 row)
```

### INSERT支持别名

**功能描述**

支持在INSERT语句中对表名使用别名。

**语法格式**

```
INSERT INTO table_name t1(t1.col1,t1.col2);
```

**参数说明**

- table_name：表名。
- t1：表的别名。
- col1：表的列1。
- col2：表的列2。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table table1 (col1 int,col2 int);
create table table2 (col1 int,col2 int);
insert into table2 values(1,2);
insert into table2 values(2,3);
insert into table1  t1(t1.col1,t1.col2) select  t2.col1,t2.col2 from table2 t2;
```

2、查询测试表table1。

```
select * from table1;
```

返回结果如下：

```
 col1 | col2
------+------
    1 |    2
    2 |    3
(2 rows)
```

### ROWID

**功能描述**

ROWID是一个伪列，该值表明了该行在Oracle数据库中的详细物理地址，通过ROWID，数据库可以快速定位某行具体数据的位置。

**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。
- 子查询中也可以使用rowid。目前具体需求只有一层子查询。对于多层子查询嵌套的时候，在各层中都可以使用rowid不做强制要求。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table t01(id int,name varchar2(32));
insert into t01(id,name) values(1,'a'),(2,'b'),(3,'c'),(4,'d');
```

2、查询ROWID。

```
 select rowid,t.* from (select a.* from t01 a) t;
```

返回结果为：

```
        rowid         | id | name
----------------------+----+------
 h1IAAA==AAAAAA==AQA= |  1 | a
 h1IAAA==AAAAAA==AgA= |  2 | b
 h1IAAA==AAAAAA==AwA= |  3 | c
 h1IAAA==AAAAAA==BAA= |  4 | d
(4 rows)
```

3、子查询外层支持ROWID。

```
select rowid as rowid_2,t.* from (select rowid,a.* from t01 a) t;
```

返回结果为：

```
       rowid_2        |        rowid         | id | name
----------------------+----------------------+----+------
 h1IAAA==AAAAAA==AQA= | h1IAAA==AAAAAA==AQA= |  1 | a
 h1IAAA==AAAAAA==AgA= | h1IAAA==AAAAAA==AgA= |  2 | b
 h1IAAA==AAAAAA==AwA= | h1IAAA==AAAAAA==AwA= |  3 | c
 h1IAAA==AAAAAA==BAA= | h1IAAA==AAAAAA==BAA= |  4 | d
(4 rows)
```

### 递归查询语法

**功能描述**

Vastbase兼容Oracle递归查询START WITH...CONNECT BY...语法。

**语法格式**

```
[START WITH condition] CONNECT BY condition
或者
CONNECT BY condition [ START WITH condition ]
```

**参数说明**

condition：任何条件语句。condition的格式必须为：

```
[prior column1 = column2 | column1 = prior column2]
```

**兼容性**

Vastbase G100 V2.2版本与Oracle 11G R2版本对比，语法中不支持的选项为[NOCYCLE]。

 **示例**

1、创建测试表并插入数据。

```
create table employee(
emp_id number(18),
lead_id number(18),
emp_name varchar2(200),
salary number(10,2),
dept_no varchar2(8)
);

insert into employee values('1',0,'king','1000000.00','001');
insert into employee values('2',1,'jack','50500.00','002');
insert into employee values('3',1,'arise','60000.00','003');
insert into employee values('4',2,'scott','30000.00','002');
insert into employee values('5',2,'tiger','25000.00','002');
insert into employee values('6',3,'wudde','23000.00','003');
insert into employee values('7',3,'joker','21000.00','003');
```

2、查询以emp_id为3开始的节点的所有直属节点。

```
select emp_id,lead_id,emp_name
from employee
start with lead_id=3
connect by prior emp_id = lead_id;
```

返回结果为：

```
 emp_id | lead_id | emp_name
--------+---------+----------
      6 |       3 | wudde
      7 |       3 | joker
(2 rows)
```

#### 支持connect_by_isleaf

**功能描述**

递归查询中的一个伪列，用于指示当前行是否为树的叶子节点（即没有子节点的节点），如果是返回1，否则返回0。

**语法格式**

```
SELECT cloumn,exper.. CONNECT_BY_ISLEAF "IsLeaf",[LEVEL],
from table
start with condition
connect by [prior column1 = column2 | column1 = prior column2];
```

**参数说明**

LEVEL：一个伪列（可选），代表当前这个节点所在的层级，对于根节点，level返回1。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE EMP
(EMPNO NUMBER(4) NOT NULL,
ENAME VARCHAR2(10),
JOB VARCHAR2(9),
MGR NUMBER(4),
HIREDATE DATE,
SAL NUMBER(7, 2),
COMM NUMBER(7, 2),
DEPTNO NUMBER(2));
INSERT INTO EMP VALUES (7369, 'SMITH', 'CLERK', 7902,TO_DATE('17-DEC-1980', 'DD-MON-YYYY'), 800, NULL, 20);
INSERT INTO EMP VALUES (7499, 'ALLEN', 'SALESMAN', 7698,TO_DATE('20-FEB-1981', 'DD-MON-YYYY'), 1600, 300, 30);
INSERT INTO EMP VALUES (7521, 'WARD', 'SALESMAN', 7698,TO_DATE('22-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 30);
INSERT INTO EMP VALUES (7566, 'JONES', 'MANAGER', 7839,TO_DATE('2-APR-1981', 'DD-MON-YYYY'), 2975, NULL, 20);
INSERT INTO EMP VALUES (7654, 'MARTIN', 'SALESMAN', 7698,TO_DATE('28-SEP-1981', 'DD-MON-YYYY'), 1250, 1400, 30);
INSERT INTO EMP VALUES (7698, 'BLAKE', 'MANAGER', 7839,TO_DATE('1-MAY-1981', 'DD-MON-YYYY'), 2850, NULL, 30);
INSERT INTO EMP VALUES (7782, 'CLARK', 'MANAGER', 7839,TO_DATE('9-JUN-1981', 'DD-MON-YYYY'), 2450, NULL, 10);
INSERT INTO EMP VALUES (7788, 'SCOTT', 'ANALYST', 7566,TO_DATE('09-DEC-1982', 'DD-MON-YYYY'), 3000, NULL, 20);
INSERT INTO EMP VALUES (7839, 'KING', 'PRESIDENT', NULL,TO_DATE('17-NOV-1981', 'DD-MON-YYYY'), 5000, NULL, 10);
INSERT INTO EMP VALUES (7844, 'TURNER', 'SALESMAN', 7698,TO_DATE('8-SEP-1981', 'DD-MON-YYYY'), 1500, 0, 30);
INSERT INTO EMP VALUES (7876, 'ADAMS', 'CLERK', 7788,TO_DATE('12-JAN-1983', 'DD-MON-YYYY'), 1100, NULL, 20);
INSERT INTO EMP VALUES (7900, 'JAMES', 'CLERK', 7698,TO_DATE('3-DEC-1981', 'DD-MON-YYYY'), 950, NULL, 30);
INSERT INTO EMP VALUES (7902, 'FORD', 'ANALYST', 7566,TO_DATE('3-DEC-1981', 'DD-MON-YYYY'), 3000, NULL, 20);
INSERT INTO EMP VALUES (7934, 'MILLER', 'CLERK', 7782,TO_DATE('23-JAN-1982', 'DD-MON-YYYY'), 1300, NULL, 10); 
```

2、查询当前行是否为叶子节点

```
SELECT  ename, CONNECT_BY_ISLEAF "IsLeaf",LEVEL
FROM emp
WHERE LEVEL <= 3 AND deptno= 10
START WITH empno = 7839
CONNECT BY PRIOR deptno = mgr AND LEVEL <= 4
order by ename,"IsLeaf";
```

返回结果为：

```
 ename | IsLeaf | level
-------+--------+-------
 KING  |      1 |     1
(1 row)
```

#### 支持order siblings by

**功能描述**

排序子句，可对结果集进行排序，仅用于层次查询connect by中，可以让兄弟节点（即同一父级的兄弟）按照指定的列进行排序（升序或者降序）。

**语法格式**

```
SELECT cloumn,exper..
FROM table
start with condition
connect by[prior column1 = column2 | column1 = prior column2]
ORDER [ SIBLINGS ] BY  {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause 
```

**参数说明**

NULLS FIRST和NULLS LAST：两者都是用来控制空值在输出结果中出现的顺序。

- NULLS FIRST表示在排序表达式上的结果为空值的行总是出现在输出结果的最前面。
- NULLS LAST表示在排序表达式上的结果为空值的行总是出现在输出结果的最后面。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE family_tree(id int primary key,appellation varchar(30),parent_id int,age int);
insert into family_tree values(1,'爷爷',0,88);
insert into family_tree values(2,'大伯',1,66);
insert into family_tree values(5,'堂兄',2,32);
insert into family_tree values(6,'堂妹',2,24);
insert into family_tree values(3,'爸爸',1,58);
insert into family_tree values(7,'小明',3,26);
insert into family_tree values(4,'小姑',1,52);
insert into family_tree values(8,'表姐',4,28);
insert into family_tree values(9,'表弟',4,20);
```

2、对同已父级的兄弟进行排序。

```
SELECT * FROM family_tree 
CONNECT BY PRIOR id= parent_id
start with appellation ='爷爷' 
order siblings by age asc;
```

返回结果为：

```
 id | appellation | parent_id | age
----+-------------+-----------+-----
  1 | 爷爷        |         0 |  88
  4 | 小姑        |         1 |  52
  9 | 表弟        |         4 |  20
  8 | 表姐        |         4 |  28
  3 | 爸爸        |         1 |  58
  7 | 小明        |         3 |  26
  2 | 大伯        |         1 |  66
  6 | 堂妹        |         2 |  24
  5 | 堂兄        |         2 |  32
(9 rows)
```

#### 支持connect_by_root

**功能描述**

一个一元运算符，可用于限定列，仅在递归查询中有效，可以根据当前行返回被视为根节点的行的列值，即就是可以根据当前行得到其根节点的列值。

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> CONNECT_BY_ROOT运算符可在SELECT列表、WHERE子句、GROUP BY子句、HAVING子句、ORDER BY子句和ORDER SIBLINGS BY子句中使用，只要SELECT命令用于分层查询。不能在分层查询的CONNECT BY子句或START WITH子句中使用。可将CONNECT_BY_ROOT应用于一个涉及列的表达式，但这样做时，该表达式必须用圆括号括起。

**语法格式**

```
SELECT CONNECT_BY_ROOT cloum,expre..
from table
start with condition
connect by [prior column1 = column2 | column1 = prior column2];
```

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
DROP TABLE family_tree;
CREATE TABLE family_tree(id int primary key,appellation varchar(30),parent_id int,age int);
insert into family_tree values(1,'爷爷',0,88);
insert into family_tree values(2,'大伯',1,66);
insert into family_tree values(5,'堂兄',2,32);
insert into family_tree values(6,'堂妹',2,24);
insert into family_tree values(3,'爸爸',1,58);
insert into family_tree values(7,'小明',3,26);
insert into family_tree values(4,'小姑',1,52);
insert into family_tree values(8,'表姐',4,28);
insert into family_tree values(9,'表弟',4,20);
```

2、对同已父级的兄弟进行排序。

```
SELECT connect_by_root parent_id root, connect_by_isleaf isleaf,id,appellation,age
FROM family_tree 
CONNECT BY PRIOR id= parent_id
start with appellation ='爷爷' 
order siblings by age;
```

返回结果为：

```
 root | isleaf | id | appellation | age
------+--------+----+-------------+-----
 0    |      0 |  1 | 爷爷        |  88
 0    |      0 |  4 | 小姑        |  52
 0    |      1 |  9 | 表弟        |  20
 0    |      1 |  8 | 表姐        |  28
 0    |      0 |  3 | 爸爸        |  58
 0    |      1 |  7 | 小明        |  26
 0    |      0 |  2 | 大伯        |  66
 0    |      1 |  6 | 堂妹        |  24
 0    |      1 |  5 | 堂兄        |  32
(9 rows)
```

### SELECT语句使用MONTH、CONTENT、PERCENT，PASSWORD关键字做列别名

**功能描述**

select语句中已支持部分关键字作为目标字段的别名，Vastbase G100 V2.2版本增加关键字month、content、percent和password作为目标字段的别名。

**语法格式**

```
SELECT [/*+ plan_hint */] [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
{ * | {expression [output_name ]} [, ...] }
[ FROM from_item [, ...] ]
[ WHERE condition ]
...
```

**参数说明**

output_name：用month、content、percent和password关键字给输出字段起别名。

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**示例**

1、创建兼容Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle DBCOMPATIBILITY='A';
\c db_oracle
```

2、验证功能。

```
select 1  month,2  content,3  percent,4  password from dual;
```

结果返回如下： 

```
month | content | percent | password 
-------+---------+---------+---------
   1 |    2 |    3|    4
(1  rows)
```

###  DATE类型的减法与乘法

**功能描述**

在以下场景中，查询结果与Oracle数据库一致：

- date类型的数据相减，结果是number类型（保留小数），结果不含小数部分则展示为整数。

- date类型的数据相减，再和整数类型数据相乘，结果是number类型（保留小数），结果不含小数部分则展示为整数。

**注意事项**

受显示格式和数据类型精度等原因影响，如果同样的数据计算形式，结果在小数位上与Oracle不完全一致，此为正常现象。

**示例**

示例一：减法（结果为number类型，由客户端控制保留几位小数）。

```
select to_date('20220110 10:10:10','yyyymmdd hh24:mi:ss')-to_date('20220101 9:9:9','yyyymmdd hh24:mi:ss')  res from dual;
```

 结果显示如下：

```
    RES
----------
9.04237268518519
(1 row)
```

结果说明：

- 单位：天（day）。

- 小数计算方式：日期相差换算为秒数/(24\*60\*60)。该例中前后相差为9天零1小时零1分零1秒，则结果为9+(1\*60\*60+1\*60+1)/(24\*60*60)≈9.04237268518519，由客户端控制保留几位小数，如果客户端控制保留7位，则最终结果为9.04237269。

- 刚好为整数日时，显示结果不带小数部分。

示例二：日期相减的差，再做乘法。

```
select (to_date('20220110 10:10:10','yyyymmdd hh24:mi:ss')-to_date('20220101 9:9:9','yyyymmdd hh24:mi:ss'))*86400  as res from dual;
```

 结果显示如下：

```
    RES
----------
781261.000000000416
(1 row)
```

### 虚拟列语法

**功能描述**

创建数据表时（CREATE TABLE）可指定字段为虚拟列，在修改数据表（ALTER TABLE）可添加虚拟列字段。

**语法格式**

```
GENERATED ALWAYS AS ( generation_expr ) STORED;
```

**参数说明**

generation_expr：表达式

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table t_virtual(c1 int,c2 int,v_c3 int GENERATED ALWAYS AS(c1 + c2) stored);
insert into t_virtual values(1, 2);
select * from t_virtual;
```

返回结果为：

```
 c1 | c2 | v_c3 
----+----+------
  1 |  2 |    3
(1 row)
```

2、更新表的内容。

```
update t_virtual set c1=2;
select * from t_virtual;
 c1 | c2 | v_c3 
----+----+------
  2 |  2 |    4
(1 row)
```

3、删除表中的字段。

```
ALTER TABLE t_virtual drop c1;
select * from t_virtual;
 c2 
----
  2
(1 row)
```

### 宏变量

**功能描述**

系统提供的宏变量包括dbtimezone,sessiontimezone和systimestamp。

- dbtimezone：返回数据库时区。
- sessiontimezone：返回会话时区。
- systimestamp：返回本机数据库上当前系统日期和时间，精确到毫秒。

**示例**

- dbtimezone

```
select dbtimezone;
```

返回结果为：

```
 dbtimezone
------------
 PRC
(1 row)
```

- sessiontimezone

```
select sessiontimezone;
```

返回结果为：

```
 sessiontimezone
-----------------
 PRC
(1 row)
```

- systimestamp

```
select systimestamp;
```

返回结果为：

```
       sysdate
---------------------
 2022-07-01 16:43:47
(1 row)
```

### ROWNUM

**功能描述**

ROWNUM伪列会在查询时返回行的编号。

**注意事项**

无

**兼容性**

完全兼容。

**示例**

1、创建临时表并插入数据

```
CREATE TEMPORARY TABLE empsalary (
depname varchar,
empno bigint,
salary int,
enroll_date date
);
INSERT INTO empsalary VALUES
('develop', 10, 5200, '2007-08-01'),
('sales', 1, 5000, '2006-10-01'),
('personnel', 5, 3500, '2007-12-10'),
('sales', 4, 4800, '2007-08-08'),
('personnel', 2, 3900, '2006-12-23'),
('develop', 7, 4200, '2008-01-01'),
('develop', 9, 4500, '2008-01-01'),
('sales', 3, 4800, '2007-08-01'),
('develop', 8, 6000, '2006-10-01'),
('develop', 11, 5200, '2007-08-15');
```

2、执行查询语句。

```
select rownum,depname,empno,salary from empsalary where rownum <3;
```

返回结果为：

```
 rownum | depname | empno | salary
--------+---------+-------+--------
      1 | develop |    10 |   5200
      2 | sales   |     1 |   5000
(2 rows)
```

### Insert All&First子句语法

**功能描述**

Insert All&First语句允许用户在一条Insert语句中往不同的表同时插入数据，也可以实现有条件的插入。

- Insert All表示所有满足条件的插入语句都会被执行。
- Insert First在执行第一个满足条件的插入语句后就会结束。

**语法格式**

```
Insert [ First | All ] 
[ WHEN { Condition } THEN INTO table [ [ AS ] alias ] Values (v1, ...), ...]
{ Subquery }
```

**参数说明**

WHEN { Condition }：任意一个判断表达式，表达式中可以使用常量或引用查询中的表字段。

**注意事项**

 无。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE small_orders 
  ( order_id       NUMERIC   NOT NULL,
    customer_id    NUMERIC    NOT NULL,
    order_total    NUMERIC );
CREATE TABLE medium_orders AS SELECT * FROM small_orders;
CREATE TABLE large_orders AS SELECT * FROM small_orders;
CREATE TABLE special_orders 
  (  order_id       NUMERIC  NOT NULL,
     customer_id    NUMERIC  NOT NULL,
     order_total    NUMERIC,
     other          NUMERIC
   );

CREATE TABLE orders 
(   order_id       NUMERIC NOT NULL,
    customer_id    NUMERIC NOT NULL,
    order_total    NUMERIC ,
    other          NUMERIC );

INSERT INTO orders SELECT 1, 1, 10000, 1 ;
INSERT INTO orders SELECT 1, 1, 20000, 1 ; 
INSERT INTO orders SELECT 1, 1, 30000, 1 ;
INSERT INTO orders SELECT 1, 1, 210000, 1 ;
INSERT INTO orders SELECT 1, 1, 220000, 1 ;
INSERT INTO orders SELECT 1, 1, 110000, 1 ;
INSERT INTO orders SELECT 1, 1, 120000, 1 ;
INSERT INTO orders SELECT 1, 1, 130000, 1 ;
INSERT INTO orders SELECT 1, 1, 140000, 1 ;
INSERT INTO orders SELECT 1, 1, 140000, 1 ;
INSERT INTO orders SELECT 1, 1, 340000, 1 ;
```

2、使用INSERT ALL向不同表中插入数据。

```
INSERT ALL
WHEN ottl < 100000 THEN
INTO small_orders
VALUES(oid, ottl, cid)
WHEN ottl > 100000 and ottl < 200000 THEN
INTO medium_orders
VALUES(oid, ottl, cid)
WHEN ottl > 200000 THEN
into large_orders
VALUES(oid, ottl, cid)
SELECT o.order_id oid, o.customer_id cid, o.order_total ottl,
o.other
FROM orders o;
```

3、查询INSERT ALL结果。

```
select * from small_orders;
```

返回结果如下，则表示插入数据成功:

```
 order_id | customer_id | order_total
----------+-------------+-------------
        1 |       10000 |           1
        1 |       20000 |           1
        1 |       30000 |           1
(3 rows)
```

```
select * from medium_orders;
```

返回结果如下，则表示插入数据成功:

```
 order_id | customer_id | order_total
----------+-------------+-------------
        1 |      110000 |           1
        1 |      120000 |           1
        1 |      130000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
(5 rows)
```

```
select * from large_orders;
```

返回结果如下，则表示插入数据成功:

```
 order_id | customer_id | order_total
----------+-------------+-------------
        1 |      210000 |           1
        1 |      220000 |           1
        1 |      340000 |           1
(3 rows)

```

```
select * from special_orders;
```

返回结果如下，则表示插入数据成功:

```
 order_id | customer_id | order_total | other
----------+-------------+-------------+-------
(0 rows)
```

4、使用INSERT FIRST向不同表中插入数据。

```
INSERT First
WHEN ottl > 10000 THEN
INTO small_orders
VALUES(oid, ottl, cid)
INTO small_orders
VALUES(oid, ottl, cid)
INTO small_orders
VALUES(oid, ottl, cid)
WHEN ottl > 100000 THEN
INTO medium_orders
VALUES(oid, ottl, cid)
WHEN ottl > 200000 THEN
into large_orders
VALUES(oid, ottl, cid)
SELECT o.order_id oid, o.customer_id cid, o.order_total ottl,
o.other
FROM orders o;
```

5、查询INSERT First结果。

```
select * from small_orders;
```

返回结果如下，则表示插入数据成功:

```
 order_id | customer_id | order_total
----------+-------------+-------------
        1 |       10000 |           1
        1 |       20000 |           1
        1 |       30000 |           1
        1 |       20000 |           1
        1 |       20000 |           1
        1 |       20000 |           1
        1 |       30000 |           1
        1 |       30000 |           1
        1 |       30000 |           1
        1 |      210000 |           1
        1 |      210000 |           1
        1 |      210000 |           1
        1 |      220000 |           1
        1 |      220000 |           1
        1 |      220000 |           1
        1 |      110000 |           1
        1 |      110000 |           1
        1 |      110000 |           1
        1 |      120000 |           1
        1 |      120000 |           1
        1 |      120000 |           1
        1 |      130000 |           1
        1 |      130000 |           1
        1 |      130000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
        1 |      340000 |           1
        1 |      340000 |           1
        1 |      340000 |           1
(33 rows)

```

```
select * from medium_orders;
```

返回结果如下（与第三步查询结果相同时），则表示语句执行成功:

```
 order_id | customer_id | order_total
----------+-------------+-------------
        1 |      110000 |           1
        1 |      120000 |           1
        1 |      130000 |           1
        1 |      140000 |           1
        1 |      140000 |           1
(5 rows)
```

```
select * from large_orders;
```

返回结果如下（与第三步查询结果相同时），则表示语句执行成功:

```
 order_id | customer_id | order_total
----------+-------------+-------------
        1 |      210000 |           1
        1 |      220000 |           1
        1 |      340000 |           1
(3 rows)
```

```
select * from special_orders;
```

返回结果如下（与第三步查询结果相同时），则表示语句执行成功:

```
 order_id | customer_id | order_total | other
----------+-------------+-------------+-------
(0 rows)
```

### WITH FUNCTION子句

**功能描述**

with function功能实现了再with语句中定义临时函数，在后续的子语句中可以重复使用该函数。

**语法格式**

```
WITH { FUNCTION func_name ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } default_expr ] [, ...] ] )
    [ RETURNS rettype
      | RETURNS TABLE ( column_name column_type [, ...] ) ] AS ‘definition’ } [, …]
{ SelectStmt }
```

**参数说明**

- func_name：自定义的函数名称。取值范围：字符串，要符合标识符命令规范。

- argmode：函数参数的模式。取值范围：IN，OUT，INOUT或VARIADIC（用于声明数组类型的参数），缺省值是IN。只有OUT模式的参数后面能跟VARIADIC。并且  OUT和INOUT模式的参数不能用在RETURNS TABLE的函数定义中。

- argname：函数参数的名称。取值范围：字符串，要符合标识符命令规范。

- argtype：函数参数的类型。

- rettype：函数返回值的数据类型。如果存在OUT或IN OUT参数，可以省略RETURNS子句。如果出现了，那么它必须和输出参数隐含的结果类型兼容：如果有多个输出参数，必须是 RECORD， 如果只有一个输出参数，则与其相同。

- column_name：字段名称。

- column_type：字段类型。

- definition：一个定义函数的字符串长，含义取决于语言。它可以是一个内部函数名称、一个指向某个目标文件的路径、一个SQL查询、一个过程语言文本。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

使用WITH FUNCTION字句调用函数。

```
WITH FUNCTION withfunc (x integer) RETURNS INTEGER AS $$
BEGIN
RETURN x+1;
END
$$,
FUNCTION withfunc2(x INTEGER, y INTEGER) RETURNS INTEGER AS $$
BEGIN
RETURN x+y;
END;
$$,
FUNCTION withfunc3(x TEXT) RETURNS TEXT AS $$
BEGIN
RETURN x || '-test';
END;
$$
SELECT withfunc(1),withfunc2(2,3),withfunc3('4');
```

当结果显示如下，则表示函数调用成功：

```
 withfunc | withfunc2 | withfunc3
----------+-----------+-----------
        2 |         5 | 4-test
(1 row)
```

### SAMPLE抽样采集语法

**功能描述**

sample字句允许从表中的随机数据样本中进行选择，而不是从整个表中选择。

**语法格式**

```
TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ];
```

**参数说明**

- sampling_method：采样方法。
  - BERNOULLI：随机抽取表的数据行数据，抽样级别为数据行级别。使用全表扫描的采样方法，按采样参数百分比返回。相比于SYSTEM 具有更好的随机性，但是性能要差很多。
  - SYSTEM：块级采样方法，随机抽取表的数据块上的数据，按采样参数百分比返回（被采样到的数据块内的所有记录都将被返回）。因此离散度不如BERNOULLI，但是效率高很多。
  - SYSTEM_ROWS：tsm_system_rows模块提供了表采样方法SYSTEM_ROWS，它可以用SELECT命令的TABLESAMPLE子句中。这种表采样方法接受一个整数参数，它是要读取的最大行数。得到的采样将总是包含正好这么多行，除非该表中没有足够的行，在那种情况下整个表都会被选择出来。和内建的SYSTEM采样方法一样， SYSTEM_ROWS执行块级别的采样，所以采样不是完全随机的，而是服从于聚簇效果，特别是只要求少量行时。
    注意：SYSTEM_ROWS不支持 REPEATABLE子句。

- 要采样的表的百分数，表示为一个0到100之间的百分数。取这个参数可以是任意的实数值表达式（除了BERNOULLI以及SYSTEM采样，其他的采样方法可能接受更多或者不同的参数）.

- REPEATABLE(seed)：采样随机种子，如果种子一样多，南无多次采样得到的结果是一样的。如果忽略REPEATABLE则每次都是使用新的seed值，得到不同的结果。seed取值为任何非空浮点值。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
create table test_sample (id int4,message text);
insert into test_sample(id,message) select n,md5(random()::text) from generate_series(1,1000000) n;
```

2、使用SYSTEM采样方法进行选择。

```
select * from test_sample tablesample system(0.1);
```

返回结果如下，则表示采样成功：

```
   id   |             message
--------+----------------------------------
 108681 | de5d879fcd627af8a0fae0d4e8c99952
 108682 | 348e18ff6e162f774569eb0107882023
 108683 | 67520adbc0d5b6e0a98238559740abf0
 108684 | 9046cc4117baba71ee616de9e389b065
 108685 | 8300ccfb5072ae931be4d2eb82d8048a
 108686 | 08189d0630f699d10f7cf62bec2837a8
 108687 | 9035049b7ae8d70fbde7169b95ba91ec
 108688 | a8d7edb1dd058b2fc2a06d34dc036721
 108689 | 0a08c43a8d052f9e4cb6d66192b5aca5
 108690 | 3e0b3d680e2c78382210170c35d97da4
 108691 | 82b8edbaddd56a3533c166bf6110f11c
 108692 | 2174f782ee8087a4a99744581e1c90df
 108693 | 83682dfb7cb7ab64af11959226996b9e
 108694 | 82cac0957b88e4851d5503dcf2ddedb9
 108695 | 98d40852958d68f8dd469259a07953d3
 108696 | 2c3df1ff75d2bf40cf2ef130427f0099
 108697 | 306165368949c2add290394af980b20c
 108698 | 985a277365a31ae767a53af700220ff6
 108699 | 450ad7e79ded9887bf77adad59d1e30d
 108700 | 224dc5087e8238f885d68d7edb8c0a1c
 108701 | 0ce5ebfab7b11070689d31b1808038c1
 108702 | 5ac2d7bedfe0eb9026916c13e4b32b53
 108703 | 4fbe39926d7177b4ce1a418cdc1b3b1c
 108704 | 9305630170cd961cce5d391dcdbc47f2
 108705 | d0cfef23d155a8644c4f36fd235b60d2
 108706 | 1fa533a6e707a7aae2957ef9ad65414c
 108707 | 532bacb8035fbcd5e15ddd05180ad4a0
 108708 | ed7a3959905c1a5654dc00fc0456c81f
 108709 | e42540d240bb61539eaea8359943eee1
 108710 | 63f390eb4c546b8eb616bc36f8d184ab
 108711 | 01282b0d264b64711dc75a9e26f2cfa6
 108712 | 2e62cd74be4073a5b8c1c5d5dbd613f1
 108713 | 9a46e4b8b64c3d25b9a8b6c64e7f6931
 108714 | c94a77af8e839dd0237560bb4b9e74ba
 108715 | baa94146612c4723c4f8d10b95cef519
 108716 | 5142bc434e8795a83fef656392cbb67f
Cancel request sent
```

3、使用SYSTEM采样方法进行选择。

```
 select ctid,* from test_sample tablesample BERNOULLI(0.05);
```

返回结果如下，则表示采样成功过：

```
   ctid    |   id   |             message
------------+--------+----------------------------------
 (15,95)    |   1520 | fcf619fb848b2bbf4ef634f6e2917e53
 (19,79)    |   1884 | 9ad257e0a82ddd468a8b06d207b1066f
 (21,7)     |   2002 | 9c06503b99a9aa92148c3f0237de5384
 (96,11)    |   9131 | c27b199a6817f30215200af228e883de
 (106,40)   |  10110 | 194d225196af3794ffe57aabd67efc4f
 (121,16)   |  11511 | 7870876d5e85705f791714927e27fb2b
 (162,5)    |  15395 | 6dd96383b1ae18242073fbdd77b67d97
 (165,22)   |  15697 | 47a3ef5636891bff037b5d4d0daa86e1
 (178,83)   |  16993 | 6e3b6184e6435b39ad5c4be20e65c5d8
 (182,6)    |  17296 | 39f018ccf4645f4a173f3793b0219fe2
 (193,62)   |  18397 | af6316ee9907946673972245a94e4795
 (210,79)   |  20029 | 2f239bc81e70858a028efffac0875880
 (238,10)   |  22620 | f6f6d91b804ad3314d6dace36a0af3a5
 (238,52)   |  22662 | f305a3d35adf5f74d5e4fe8a5e8179cf
 (315,44)   |  29969 | 4793f9f7eae1f495231cc2c0a9589fd7
 (318,50)   |  30260 | 8f7bac87228b2ee35cb85715e24ed04c
 (341,13)   |  32408 | 2d9db260cf7b18fd69e991ed50be0695
 (360,28)   |  34228 | 7f405f35572d3d6b58c1ab27bcf30a87
 (383,50)   |  36435 | 38f3fd086c9a3ef3aa3e50e1b6282fdc
 (447,48)   |  42513 | 7de6905b59fcc6ee21e379e168d7c30c
 (447,71)   |  42536 | 69be111ed69babbafb7e1e8519be80b4
 (466,38)   |  44308 | b96a90360c187affd9ecde654490ba04
 (481,50)   |  45745 | 98e2ede63ff315e140248f72a2c9e896
 (484,29)   |  46009 | 16bd12b35fc82f98fd491757e3628377
 (484,62)   |  46042 | e151c49d5ef75098e429da334d89fbf8
 (495,3)    |  47028 | e73a88f5c4e20e88d0857b190ca1d6fb
 (503,6)    |  47791 | f083ec2b5b886e1bf2753e3861dc3aa0
 (514,71)   |  48901 | c2e1bdbaf0b972d7fe06e2fc8eb561d9
 (540,70)   |  51370 | 88fb8fb941646e9388af6af41bc9a8af
 (563,14)   |  53499 | 1ae6a5b32b5e5e2e831f6d0b18f6f507
 (576,63)   |  54783 | 0e311376ccc596be11716d237f3c677b
 (590,54)   |  56104 | b193f27a18bda8b53e1fac3c00a760af
 (592,39)   |  56279 | 3f58a044567207fd50f10c9632315248
 (617,13)   |  58628 | a677c86b9973003543618f1554250492
 (623,27)   |  59212 | 37a23fa568fc89175cc51933e541448c
 (634,95)   |  60325 | 38af9a0188c3bf09445b3b6ecdf86c28
Cancel request sent
```

### SELECT... FOR UPDATE

**功能描述**

SELECT ... FOR UPDATE语句用于锁定满足WHERE查询条件的行，以防止其他用户在您结束事务之前锁定或更新这些行。

**语法格式**

```
SELECT ... FOR UPDATE [ |WAIT integer| NOWAIT]
```

**参数说明**


- FOR UPDATE不跟任何参数：如果当前查询的结果中存在锁，则该查询一直等待（等待期间您无法执行其他操作），直到查询结果中的锁被释放后，立即返回查询结果。
- WAIT integer：如果当前查询的结果中存在锁，且超过integer秒后仍未释放锁，则报错，其中integer为等待超时时间。

  - integer取值范围：正整数。
  - integer取值0：等同NOWAIT。
- NOWAIT：当前查询的结果中存在锁，立即报错。

**注意事项**

- Vastbase G100数据库中可配置参数“update lockwait timeout”，该参数表示对单个锁的超时时间，默认为 120 秒。当select for update wait integer语句因为加锁需要进行等待时，其中integer值为等待所有行级锁的总计时长，因此，可能在总时长还未达指定值前，该语句因为等待单个行级锁超时而退出并解锁。
- Vastbase支持FOR UPDATE后跟表或者视图名，不支持跟列名。
- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11G R2版本对比，不支持的选项为：[SKIP LOCKED]。

**示例**

1、创建并切换至兼容模式为ORACLE的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';     
\c db_oracle
```

2、创建测试表并插入数据。

```
create table test8(
id number,
orderid number,
productid number,
price number(10,2),
quantity number
);
insert into test8(id,orderid,productid,price,quantity) 
values(1,1,1,6,10),
(2,1,2,4,5),
(3,1,3,10,2),
(4,2,1,3,6),
(5,2,2,4,6);
```

3、在会话1中，在事务中使用for update加锁，暂不提交。

```
begin;
select * from test8 where quantity <6 for update;
id | orderid | productid | price | quantity
--------------------------------------------
2 |        1  |          2   | 4.00 | 5
3 |        1  |          3   | 10.00 | 2
(2rows)
```

4、切换至会话2，使用for update nowait 获取同样数据时，提示获取锁失败。

```
select * from test8 where quantity <6 for update nowait;
```

返回结果如下：

```
ERROR:could not obtain lock on row in relation “test8”
```

5、切换至会话2，使用for update wait 2 获取同样数据，超时（2s）提示获取锁失败。

```
elect * from test8 where quantity <6 for update wait 2;
```

返回结果如下：

```
ERROR:could not obtain lock on row in relation “test8”
```

6、切换至会话2，使用for update wait 600 获取同样数据，n取足够大，阻塞等待会话1事务提交释放锁。

```
select * from test8 where quantity <6 for update wait 600;
```

7、切换至会话1，在等待返回结果的600秒内，提交事务，释放锁。

```
commit;
```

8、切换至会话2，成功返回查询结果。

```
id | orderid | productid | price | quantity
--------------------------------------------
2 |        1  |          2   | 4.00 | 5
3 |        1  |          3   | 10.00 | 2
(2rows)
```

### 字符串CHAR/VARCHAR/VARCHAR2指定BYTE和CHAR关键字

**功能描述**

常见的字符串类型varchar2、char、varchar数据类型的字段长度默认为字节byte，常见写法如varchar(10)。而在UTF-8字符集中，中文汉字一个字符占用了3字节，如果该字段指定限制字符串长度为10，实际上只能插入3个UTF-8汉字字符。

为了解决这种情况，Vastbase G100V2.2版本支持在创建字段的时候显式定义字段的长度单位为byte或者character（即在定义varchar2、char、varchar数据类型时支持指定byte和character关键字）。

- byte为按字节来定义字段长度，是该数据类型的缺省值。
- character为按字符来定义字段长度，可以简写成char。

**语法格式**

```
varchar(n byte)或者varchar(n character)
```

**参数说明**

- n character：表明该字段允许输入n个字符，等于n char。
- n byte：表明该字段允许输入n个字节。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

创建测试表。

```
create table test_char(
C1 char(10 char), --10 character ，允许输入最多10个字符，包括英文和中文
C2 char(10 byte), --10 byte，允许输入最多10个字节，能允许输入的字符数需要以字符具体所占字节数为准计算
C3 varchar(10 character), --10 character
C4 varchar(10), --10 byte
C5 char, --不指定限制长度，默认允许输入最多1个字节
C6 varchar, --不指定限制长度，默认不限制输入长度
C7 varchar2(10 character), --10 character
C8 varchar2(10) --10 byte
);
```

返回结果如下，则表示字符串char/varchar/varchar2指定byte和char关键字：

```
CREATE TABLE
```



### Q’转义字符语法

**功能描述**

Vastbase G100实现Oracle中的Q’转义字符，该转义字符开启Oracle中的alternative quoting（引号替换）机制。

**语法格式**

```
Q|q 'quote_delimiter c  quote_delimiter'
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 开启alternative quoting（引号替换）机制后，内部c的所有字符，包括单引号（'）、双引号（"）等均被作为字符处理。

**参数说明**

- Q or q ：表示将使用引号替代机制。这种机制允许为文本字符串使用广泛的分隔符。

- 最外面的''是两个单引号，分别位于左quote_delimiter和右quote_delimiter的前面和后面。

- c ：是用户字符集的任何成员。可以在由 c 字符组成的文本中包含引号（"）。还可以包括quote_delimiter，只要它不是紧跟在单引号之后。

- quote_delimiter：是除空格、制表符和回车之外的任何单字节或多字节字符。quote_delimiter可以是单引号。但是，如果quote_delimiter出现在文本本身中，请确保它后面不紧跟单引号。
  如果左quote_delimiter是 [, {, <, 或者 (，则右quote_delimiter必须是相应的], }, >, 或者 )。在所有其他情况下，左和右quote_delimiter必须是相同的字符。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

示例一：

```
select q'asdffwwda';
```

返回结果如下：

```
?column? 
----------
sdffwwd
(1 row)
```

示例二：

```
select q'[sfeew[]we]';
```

返回结果为：

```
?column?  
-----------
sfeew[]we
(1 row)
```

示例三：

1、创建测试表并插入数据。

```
create table qq_test(name char(20));
insert into qq_test values(q'd er'd 'wwd');
```

2、查询表中的数据。

```
select * from qq_test;
```

返回结果为：

```
      name         
----------------------
er'd 'ww           
(1 row)
```

### ALL语法

**功能描述**

ALL操作符用于将值与子查询返回的值列表的结果集进行比较。

**语法格式**

```
Operator ALL(v1,v2,v3)
Operator ALL(subquery)
```

**参数说明**

Operator：标准的比较运算符（=，<>，=，>，> =，<，或<！=）。

**注意事项**

该语法必须与比较运算符一起使用。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table testall(id int,name char(10));
insert into testall values(1,'amy');
insert into testall values(2,'tom');
insert into testall values(3,'jack');
insert into testall values(97,'jane');
insert into testall values(98,'alice');
insert into testall values(99,'taylor'); 

create table testall1(id int,name char(10));
insert into testall1 values(1,'taylor');
insert into testall1 values(99,'jane');
```

2、使用ALL(v1,v2,v3)语法查询。

```
 select * from testall where id  < all(3,98);
```

当结果返回如下，则表示查询成功：

```
id |    name    
----+------------
1 | amy       
2 | tom       
(2 rows)
```

3、使用ALL(subquery)语法。

```
select * from testall where id = all(select id from testall1 where name='taylor');
```

当结果返回如下，则表示查询成功：

```
 id |    name
----+------------
  1 | amy
(1 row)
```

### GROUP BY支持含有表达式或者函数的列

**功能描述**

在Vastbase G100现有group by功能的基础上增强对Oracle group by子句的兼容。针对含有子查询的分组列，不仅支持普通的列，而且支持含有表达式或者函数的列。

**语法格式**

```
select [grouping_element],
[expression] 
[WHERE condition]
[from table]
group by [grouping_element];
```

**参数说明**

- grouping_element：函数、表达式。

- expression：SQL语句中的子查询。

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**示例**

1、创建并切换至兼容模式为ORACLE的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility=’A’;     
\c db_oracle
```

2、创建测试表并插入数据。

```
create table test_a(c1 number,c2 varchar2(20));
insert into test_a values(1,'a');
insert into test_a values(2,'a_xxr');
insert into test_a values(3,'a_ytr');
insert into test_a values(4,'b');
insert into test_a values(5,'b_xxr');
insert into test_a values(6,'b_ytr');
create table test_b(c1 number,c2 varchar2(20));
insert into test_b values(11,'a');
insert into test_b values(22,'b');
insert into test_b values(33,'aa');
insert into test_b values(44,'ba');
insert into test_b values(55,'e');
insert into test_b values(66,'f');
```

3、使用group by字句包含函数。

```
SELECT substr(a.c2, 1, 1)
        , (
                SELECT b.c1
                FROM test_b b
                WHERE b.c2 = substr(a.c2, 1, 1)
        )
FROM test_a a
GROUP BY substr(a.c2, 1, 1);
```

返回结果为：

```
 substr | c1
--------+----
 a      | 11
 b      | 22
(2 rows)
```

### PIVOT和UNPIVOT

**功能描述**

pivot为select语句的子语句，该语句是将行旋转为列的交叉表查询，在旋转过程中聚合函数、数据透视（pivot data）是整个操作的关键。数据透视时，会对数据透视列值列表中的每个项应用聚合运算符。数据透视列不能包含任意表达式。

在pivot（行转列）语法中pivot for in查询子句支持关键字做为别名，支持的关键字为month、content、percent、password、begin、select、drop和on。

unpivot为select语句的子语句，该语句允许将列旋转为行的交叉表查询。

**语法格式**

- pivot

```
语法：
SELECT …
FROM <table-expr>
PIVOT
(
aggregate-function(<column>) AS <alias>
FOR <pivot-column> IN(<value1> [AS <alias1>], ..., <valuen> [AS <aliasn>])
) AS <alias>
WHERE …
子句划分：
SELECT …
FROM …
PIVOT[XML]
(pivot_clause
pivot_for_clause
pivot_in_clause) 
WHERE …
```

- unpivot

```
语法：
SELECT …
FROM <table-expr>
UNPIVOT [INCLUDE|EXCULDE NULLS]
(
unpivot_column1
FOR <unpivot-column2> IN ({(column_name,...)|column_name,}...)
) AS <alias_name>
WHERE …
子句划分：
SELECT …
FROM …
UNPIVOT[INCLUDE|EXCLUDE NULLS]
(unpivot_clause
unpivot_for_clause
unpivot_in_clause) 
WHERE …
```

  **参数说明**

- pivot_clause：定义需要聚合的列（pivot是一个聚合操作），即上述语法(部分聚合函数)：

```
aggregate-function(<column>) AS <alias>
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 聚合函数必须指定group by子句，但pivot_clause不包含显式group by子句。相反，pivot_clause执行隐式group by。隐式分组基于pivot_clause和 pivot_for_clause中未引用的所有列。

- pivot_for_clause：定义要分组和透视的列。即上述语法：

```
FOR <pivot-column>
```

- pivot_in_clause：定义pivot_for_clause中列的过滤器（即限制结果的值范围）。pivot_in_clause中每个值的聚合将被转置到单独的列中，并且pivot for in查询子句支持关键字做为别名：即上述语法：

```
 IN(<value1> [AS <alias1>], ..., <valuen> [AS <aliasn>])
```

pivot_in_clause子句中与xml结合使用subquery以及any。


- INCLUDE|EXCLUDE NULLS：用来控制unpivot是否包含null的记录，默认是不包含null的。
- unpivot_clause：行值的列名（即unpivot_in_clause中各列的值），即上述语法：

```
unpivot_column1
```

-  unpivot_for_clause：将原有多个列合并到单个列的列名（即把unpivot_in_clause中列名拼接），即上述语法：

```
FOR unpivot_column2
```

-  unpivot_in_clause：原始表的列名，即上述语法:

```
IN ({(column_name,...)|column_name,}...)
```

**注意事项**

pivot_in_clause：别名有两种方法

```
<value1> AS <alias1>
和
<value1> <alias1>
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 其中关键字别名只支持“<value1> AS <alias1>不支持“<value1> <alias1>
>
> 普通字符串别名“<value1> AS <alias1>”和“<value1> <alias1>”都支持。

**示例**

1、创建测试表并插入数据。

```
create table test_pivot (timetest varchar2(20), test varchar2(20), score number, class number);
insert into test_pivot values('张三','month', 78, 1);
insert into test_pivot values('张三','content',87, 2);
insert into test_pivot values('张三','content',90, 1);
insert into test_pivot values('张三','content',60, 2);
insert into test_pivot values('张三','percent',82, 3);
insert into test_pivot values('张三','percent',88, 1);
insert into test_pivot values('张三','percent',89, 2);
insert into test_pivot values('张三','password',90, 2);
insert into test_pivot values('张三','天文',90, 1);
insert into test_pivot values('李四','地理',90, 2);
insert into test_pivot values('李四','month',65, 2);
insert into test_pivot values('李四','month',95, 1);
insert into test_pivot values('李四','month',65, 3);
insert into test_pivot values('李四','content',77, 1);
insert into test_pivot values('李四','percent',65, 2);
insert into test_pivot values('李四','percent',85, 2);
insert into test_pivot values('李四','percent',95, 2);
insert into test_pivot values('李四','password',85, 3);
insert into test_pivot values('张三','Physics',100, 2);
insert into test_pivot values('张三','Math',70, 1);
insert into test_pivot values('李四','Physics',60, 2);
insert into test_pivot values('李四','Chinese',65, 2);
```

2、将行转为列。

```
select *  from test_pivot pivot (avg(score) for test in ('month' as month, 'content' as content, 'percent' as percent,'password' as password, '天文', '地理')) order by class;
```

返回结果为：

```
 timetest | class | month | content |       percent       | password | '天文' | '地理'
----------+-------+-------+---------+---------------------+----------+--------+--------
 李四     |     1 |    95 |      77 |                     |          |        |
 张三     |     1 |    78 |      90 |                  88 |          |     90 |
 张三     |     2 |       |    73.5 |                  89 |       90 |        |
 李四     |     2 |    65 |         | 81.6666666666666667 |          |        |     90
 张三     |     3 |       |         |                  82 |          |        |
 李四     |     3 |    65 |         |                     |       85 |        |
(6 rows)
```

3、创建一个测试表 testunpivot。

```
create table testunpivot(NAME varchar(10),yu int,shu int,ying int,wu int,zong int);
insert into testunpivot values('李四',65,75,85,95,320),('李五',61,71,81,91,324);
```

4、查询表中的数据。

```
 select * from testunpivot;
```

返回结果为：

```
 name | yu | shu | ying | wu | zong
------+----+-----+------+----+------
 李四 | 65 |  75 |   85 | 95 |  320
 李五 | 61 |  71 |   81 | 91 |  324
(2 rows)
```

5、将列转为行。

```
select * from testunpivot unpivot((wen,li) for kemu in((yu,shu),(yu,wu),(ying,shu),(ying,wu)));
```

返回结果为：

```
 name | zong |   kemu   | wen | li
------+------+----------+-----+----
 李四 |  320 | yu_shu   |  65 | 75
 李四 |  320 | yu_wu    |  65 | 95
 李四 |  320 | ying_shu |  85 | 75
 李四 |  320 | ying_wu  |  85 | 95
 李五 |  324 | yu_shu   |  61 | 71
 李五 |  324 | yu_wu    |  61 | 91
 李五 |  324 | ying_shu |  81 | 71
 李五 |  324 | ying_wu  |  81 | 91
(8 rows)
```

## 函数

###  SQLERRM

**功能描述**

SQLERRM函数的主要功能是根据入参错误号匹配RAISE_APPLICATION_ERROR(error_code, message)预定义函数定义的错误信息。

**前提条件**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**语法格式**

```
SQLERRM( error_code number)
```

**参数说明**

error_code：错误编号。

**使用场景**

- 当传入的错误编号在-20000到-20999时候，输出RAISE_APPLICATION_ERROR(error_code,  message)预定义函数的错误信息。

- 传入的错误编号不在-20000到-20999时候，输出Vastbase自身的错误信息。

**示例**

如果是-20000到-20999，那么raise_application_error定义的错误信息，进行输出对应结果。

1、创建兼容Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle DBCOMPATIBILITY='A';
\c db_oracle
```

2、创建存储过程

```
drop procedure if exists exp_sqlerrm;
set serveroutput on;
create procedure exp_sqlerrm(
t1 in date,
t2 in date
)is
begin
if t1<t2 then
raise_application_error(-20000,'testErr---Date t1 is earlier than t2.');
end if;
end;
/
```

3、调用存储过程，打印预定义的错误信息

```
DECLARE
past_due EXCEPTION;
PRAGMA EXCEPTION_INIT(past_due,-20000);
BEGIN
exp_sqlerrm('2020-01-01',sysdate);
EXCEPTION
WHEN past_due THEN
DBMS_OUTPUT.PUT_LINE(SQLERRM(-20000));
END;
/
```

结果返回如下：

```
testErr---Date t1 is earlier than t2.
```

### TABLE

**功能描述**

table表函数用于查询函数返回的结果集，并将结果集转换为表的形式（就如同查询普通表一样查询返回的结果集）。

**语法格式**

```
SELECT * FROM table(arg);
```

**参数说明**

arg：结果集。

**注意事项**

 无

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table testtable(id int);
insert into testtable values(123),(1234);
```

2、使用表函数查询结果。

```
SELECT * FROM table(testtable);
```

返回结果为：

```
id
------
  123
 1234
(2 rows)
```

### SINH，COSH，TANH

**功能描述**

- sinh函数：计算输入参数的双曲正弦值，并返回结果。
- cosh函数：计算输入参数的双曲余弦值，并返回结果。
- tanh函数：计算输入参数的双曲正切值，并返回结果。

**语法格式**

- sinh函数

```
sinh(arg)
```

- cosh函数

```
cosh(arg)
```

- tanh函数

```
tanh(arg)
```

**参数说明**

arg：输入float类型数值。

**注意事项**

无

**兼容性**

完全兼容。

**示例**

- cosh函数

```
select cosh(1);

       cosh
------------------
 1.54308063481524
(1 row)
```

- sinh函数

```
select sinh(33);

      sinh
-----------------
 107321789892958
(1 row)

```

- tanh函数

```
select tanh(9);

select tanh(9);
       tanh
------------------
 .999999969540041
(1 row)
```

### LNNVL，NANVL，NVL2

**功能描述**

- lnnvl函数：boolean类型取反输出，如果输入参数是NULL则返回true。
- nanvl函数：如果输入值（参数一）是NaN(不是数字)，它指示数据库返回一个替代值（参数二）。
- nvl2函数：nvl2允许根据指定的表达式是否为null来确定查询返回的值。如果expr1不为空，则nvl2返回expr2,。如果expr1为空，则nvl2返回expr3。

**语法格式**

- lnnvl函数

```
lnnvl(arg)
```

- nanvl函数

```
nanvl(arg1, arg2)
```

- nvl2函数

```
nvl2(expr1, expr2,expr3)
```

**参数说明**

- arg：输入boolean类型，可以是返回boolean类型的函数或者表达式，也可以是NULL。
- arg1，arg2：输入数值类型，还可以是可隐式转换为数值类型的其他类型。
- expr1, expr2,expr3：输入任意类型。3个参数需要是同一个类型，除了NULL。NULL可以和其他任意类型混用。

**注意事项**

无

**兼容性**

完全兼容。

**示例**

- lnnvl函数

```
select lnnvl(1=1);
 lnnvl
-------
 f
(1 row)
```

- nanvl函数

```
select nanvl(1,2);

 nanvl
-------
     1
(1 row)
```

- nvl2函数

```
select nvl2(1,2,3);
 nvl2
------
    2
(1 row)
```

### ROUND(date/timestamp)

**功能描述**
该函数可以对日期进行处理，返回四舍五入的结果

**语法格式**

```
ROUND(date [, fmt ]);
ROUND(timestamp [with[without] time zone] [, fmt ]);
```

**参数说明**

- date：输入date类型数值。
- timestamp：输入timestamp类型数值。
- fmt ：返回日期或时间四舍五入到格式模型fmt指定的单位。


**注意事项**

无

**示例**

1、使用round（date）函数。

```
select ROUND('2020-11-18 16:46:52'::date,'yy');
```

返回结果为：

```
        round
---------------------
 2021-01-01 00:00:00
(1 row)

```

2、使用round（timestamp）函数。

```
select ROUND('2020-11-18 16:46:52+08'::timestamp with time zone,'hh');
```

返回结果为：

```
         round
------------------------
 2020-11-18 17:00:00+08
(1 row)
```

### GROUPING_ID和GROUPING

**功能描述**

GROUPING函数用于区分分组后的普通行和聚合行。如果是聚合行，则返回1，反之，则是0。

GROUPING_ID函数相当于将多个GROUPING函数的结果串接成二进制数，返回这个二进制数对应的十进制数。

**语法格式**

```
GROUPING_ID(expr [, expr ]...)
```

**参数说明**

expr：列名。需要在GROUP BY表达式中，该函数返回由1和0组成的位向量对应的数字，指示哪些GROUP BY表达式不包括在当前分组集中。如果对应的expr包含在生成当前结果行的分组集中（常规分组行），则位为0，如果不包含(超聚合行，GROUPBYROLLUP/CUBE等生成）则为1。当有多个expr时，如2个expr，可能的返回值为：00 ->0，01 ->1，10-> 2，11 -> 3。

**注意事项**

- 该函数仅适用于select语句并包含GROUP BY的情况。

- grouping_id的字段，必须是group by包含的字段

**示例**

1、创建测试表并插入数据。

```
create table group_test (group_id int, job varchar2(10), name varchar2(10), salary int);
insert into group_test values (10,'Coding', 'Bruce',1000);
insert into group_test values (10,'Programmer','Clair',1000);
insert into group_test values (10,'Architect', 'Gideon',1000);
insert into group_test values (10,'Director', 'Hill',1000);
insert into group_test values (20,'Coding', 'Jason',2000);
insert into group_test values (20,'Programmer','Joey',2000);
insert into group_test values (20,'Architect', 'Martin',2000);
insert into group_test values (20,'Director', 'Michael',2000);
insert into group_test values (30,'Coding', 'Rebecca',3000);
insert into group_test values (30,'Programmer','Rex',3000);
insert into group_test values (30,'Architect', 'Richard',3000);
insert into group_test values (30,'Director', 'Sabrina',3000);
insert into group_test values (40,'Coding', 'Samuel',4000);
insert into group_test values (40,'Programmer','Susy',4000);
insert into group_test values (40,'Architect', 'Tina',4000);
insert into group_test values (40,'Director', 'Wendy',4000);
```

2、grouping函数：传入两个expr参数，使用GROUP BY ROLLUP生成分组集.

```
select group_id,job,grouping(group_id),grouping(job),grouping(group_id,job),sum(salary) from group_test group by rollup(group_id, job);
```

返回结果为：

```
 group_id |    job     | grouping | grouping | grouping |  sum
----------+------------+----------+----------+----------+-------
       10 | Architect  |        0 |        0 |        0 |  1000
       10 | Coding     |        0 |        0 |        0 |  1000
       10 | Director   |        0 |        0 |        0 |  1000
       10 | Programmer |        0 |        0 |        0 |  1000
       10 |            |        0 |        1 |        1 |  4000
       20 | Architect  |        0 |        0 |        0 |  2000
       20 | Coding     |        0 |        0 |        0 |  2000
       20 | Director   |        0 |        0 |        0 |  2000
       20 | Programmer |        0 |        0 |        0 |  2000
       20 |            |        0 |        1 |        1 |  8000
       30 | Architect  |        0 |        0 |        0 |  3000
       30 | Coding     |        0 |        0 |        0 |  3000
       30 | Director   |        0 |        0 |        0 |  3000
       30 | Programmer |        0 |        0 |        0 |  3000
       30 |            |        0 |        1 |        1 | 12000
       40 | Architect  |        0 |        0 |        0 |  4000
       40 | Coding     |        0 |        0 |        0 |  4000
       40 | Director   |        0 |        0 |        0 |  4000
       40 | Programmer |        0 |        0 |        0 |  4000
       40 |            |        0 |        1 |        1 | 16000
          |            |        1 |        1 |        3 | 40000
(21 rows)
```

3、调用grouping_id函数：grouping_id函数：传入一个expr参数，使用GROUP BY CUBE生成分组集。、

```
select group_id,job,grouping_id(group_id),grouping_id(job),sum(salary) from group_test group by cube(group_id, job);
```

当返回结果如下时，则表示支持grouping_id函数

```
 group_id |    job     | grouping | grouping |  sum
----------+------------+----------+----------+-------
       10 | Architect  |        0 |        0 |  1000
       10 | Coding     |        0 |        0 |  1000
       10 | Director   |        0 |        0 |  1000
       10 | Programmer |        0 |        0 |  1000
       10 |            |        0 |        1 |  4000
       20 | Architect  |        0 |        0 |  2000
       20 | Coding     |        0 |        0 |  2000
       20 | Director   |        0 |        0 |  2000
       20 | Programmer |        0 |        0 |  2000
       20 |            |        0 |        1 |  8000
       30 | Architect  |        0 |        0 |  3000
       30 | Coding     |        0 |        0 |  3000
       30 | Director   |        0 |        0 |  3000
       30 | Programmer |        0 |        0 |  3000
       30 |            |        0 |        1 | 12000
       40 | Architect  |        0 |        0 |  4000
       40 | Coding     |        0 |        0 |  4000
       40 | Director   |        0 |        0 |  4000
       40 | Programmer |        0 |        0 |  4000
       40 |            |        0 |        1 | 16000
          |            |        1 |        1 | 40000
          | Architect  |        1 |        0 | 10000
          | Coding     |        1 |        0 | 10000
          | Director   |        1 |        0 | 10000
          | Programmer |        1 |        0 | 10000
(25 rows)
```


### VSIZE

**功能描述**

VSIZE函数用于返回表达式的真实存储长度，以字节表示。

**语法格式**

```
vsize(expr)
```

**参数说明**

expr：需要返回存储长度的表达式，如果expr为null，函数返回null。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
create table t_col(id int primary key ,x varchar(20) );
insert into t_col values (1,'H');
insert into t_col values (2,'侯');
insert into t_col values (3,'H侯');
insert into t_col values (4,'');
select * from t_col;
```

返回结果为：

```
 id |  x
----+-----
  1 | H
  2 | 侯
  3 | H侯
  4 |
(4 rows)
```

2、使用VSIZE函数。

```
select id, x, length(x), vsize(x) from t_col;
```

返回结果如下，则表示支持该函数：

```
id ｜ x   | length | vsize
-------------------------

1 ｜ H    |    1     | 1
2 ｜ 侯    |    1     | 3
3 ｜ H侯   |    2      | 4
4 ｜       |          | 
```

### PERCENTILE_CONT

**功能描述**

percentile_cont是一个假定连续分布模型的逆分布函数，该函数具有一个百分比比值和一个排序规范，其返回值是在排序规范的给定给定百分比值范围内的内插值。

**语法格式**

```
PERCENTILE_CONT(percentile) 
WITHIN GROUP (ORDER BY expr DESC/ASC)
OVER([PARTITION BY expr_list])
```

**参数说明**

- percentile：数值类型的常量，取值范围为0-1之间(包含0和1)。
- WITHIN GROUP：指定了分组元素的排序方式。
- OVER：语句中指定了分组方式。
- DESC/ASC：asc是指定列按升序排列，desc则是指定列按降序排列。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

```
SELECT color,percentile_cont(0.5) WITHIN GROUP (ORDER BY value) over(partition by color) from (VALUES('red',1),('red',3),('blue',2),('blue',4)) v(color,value);
```

返回结果如下，则表示支持该函数：

```
color ｜ percrntile_cont
------------------------
blue   | 3
blue   | 3
red    | 2
red    | 2
(4 rows)
```

### TZ_OFFSET

**功能描述**

TZ_OFFSET函数用于返回与其输入参数相关的时区偏移量。

**语法格式**

```
select TZ_OFFSET ( { 'time_zone_name'| '{ + | - } hh : mi'| SESSIONTIMEZONE | DBTIMEZONE } )
```

**参数说明**

- time_zone_name：时区名，如'PRC'。
- {+|-} hh:mi：时区相对UTC的偏移，hh范围：0-15；mi范围：0-59。
- SESSIONTIMEZONE：返回当前会话时区。
- DBTIMEZONE：返回数据库时区。

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

完全兼容。

**示例**

- 查询PRC时区的偏移量

```
select tz_offset('PRC');
```

返回结果为：

```
 tz_offset
-----------
 +08:00
(1 row)
```

- 查询GMT时区的偏移量

```
select tz_offset('GMT');
```

返回结果为：

```
 tz_offset
-----------
 +00:00
(1 row)
```


- 查询America/Lima所在时区的时区偏移量

```
select tz_offset('America/Lima');
```

返回结果为：

```
 tz_offset
-----------
 -05:00
(1 row)
```

### TO_SINGLE_BYTE和TO_MULTI_BYTE

**功能描述**

TO_MULTI_BYTE函数可以实现字符半角转全角功能，即将输入的字符或字符串从单字节转换成多字节。
TO_SINGLE_BYTE函数可以实现字符全角转半角功能，即将输入的字符或字符串从多字节转换成单字节。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、半角转全角

```
select   to_multi_byte('123$% 高AStest@【[');
```

返回结果如下，则表示支持该函数:

```
      to_multi_byte           
----------------------------------
１２３＄％　高ＡＳｔｅｓｔ＠【［
(1 row)
```

2、全角不变

```
select to_multi_byte('１２３＄％　高ＡＳｔｅｓｔ＠【［');
```

返回结果如下，则表示支持该函数:

```
      to_multi_byte           
----------------------------------
１２３＄％　高ＡＳｔｅｓｔ＠【［
(1 row)
```

3、半角不变

```
select to_single_byte('123$% 高AStest@【[');
```

返回结果如下，则表示支持该函数:

```
to_single_byte   
--------------------
123$% 高AStest@【[
(1 row)
```

4、全角转半角

```
select to_single_byte('１２３＄％　高ＡＳｔｅｓｔ＠【［'); 
```

返回结果如下，则表示支持该函数:

```
to_single_byte   
--------------------
123$% 高AStest@【[
(1 row)
```

### WM_CONCAT

**功能描述**

WM_CONCAT函数可以实现行转列功能，即将查询出的某一列的值使用逗号进行隔开拼接，使之成为一条数据，实现字段合并。

**语法格式**

```
SELECT column, WM_CONCAT(column1) FROM table GROUP BY column;
```

**参数说明**

column1：表中的某一列。

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE shopping (u_id int, goods text, num int);
INSERT INTO shopping VALUES (1, 'Apple', 2), (1, 'Melon', 4), (1, 'Orange', 3);
INSERT INTO shopping VALUES (2, 'Pear', 5);
INSERT INTO shopping VALUES (3, 'Grape', 1), (3, 'Banana', 1);
```

2、使用WM_CONCAT函数1。

```
SELECT u_id, WM_CONCAT(goods) as goods_sum
FROM shopping
GROUP BY u_id;
```

返回结果如下:

```
 u_id |     goods_sum
------+--------------------
    1 | Apple,Melon,Orange
    3 | Grape,Banana
    2 | Pear
(3 rows)
```

3、使用WM_CONCAT函数2。

```
SELECT u_id, WM_CONCAT(goods || '(' || num || ')' ) as goods_sum
FROM shopping
GROUP BY u_id;
```

返回结果如下：

```
 u_id |          goods_sum
------+-----------------------------
    1 | Apple(2),Melon(4),Orange(3)
    3 | Grape(1),Banana(1)
    2 | Pear(5)
(3 rows)
```

### SYS_GUID

**功能描述**

SYS_GUID可以生成一个全局唯一的字符串数据值。生成的依据主要是时间和随机数，具有全局唯一性。

**语法格式**

```
select * from sys_guid();
```

**注意事项**

无。

**兼容性**

完全兼容。

**示例**

```
select * from sys_guid();
```

其返回结果如下：

```
               sys_guid               
--------------------------------------
 48a5e783-bd94-4038-9547-0d8611aa8a33
(1 row)
```

### INSTRB

**功能描述**

INSTRB函数用于搜索一个字符串在指定的字符串中出现的位置，起始搜索位置和出现的次数（第几次）可以通过参数来指定。

当起始搜索位置为负数时，表示从指定字符串的尾部往回开始搜索。返回值为字符串在被搜索的字符串中出现的位置，该位置是按字节数来计算。如果未搜索到字符串，则返回0。

**语法格式**

```
instrb(C1,C2[,I[,J]]);
```

**参数说明**

- C1：varchar2类型，被搜索的字符串。
- C2：varchar2类型，指定的字符串。
- I：integer类型，起始搜索位置，默认为1。
- J：integer类型，第J次出现的位置，默认为1。

**注意事项**

无。

**示例**

示例一：默认编码为utf8，调用instrb函数。

```
select instrb('CORPORATE FLOOR','OR');
```

返回结果为：

```
instrb               
-------
  2
(1 row)
```

示例二：

```
select instrb('CORPORATE FLOOR','OR',5,2);
```

返回结果为：

```
instrb               
-------
  14
(1 row)
```

示例三：

```
select instrb('CORPORATE FLOOR','OR',-3,2);
```

返回结果为：

```
instrb               
-------
  2
(1 row)
```

示例四：

```
select instrb('测试CORPORATE FLOOR','OR');
```

utf8编码格式下一个中文为三个字节，故返回结果为:

```
instrb               
-------
  8
(1 row)
```

### MONTHS_BETWEEN

**功能描述**

该函数用于返回两个日期之间的月份数。

**语法格式**

```
MONTHS_BETWEEN(date1, date2)
```

**参数说明**

date1/date2：指定时间值。取值范围是date或TIMESTAMP WITH TIME ZONE

**注意事项**

- 如果date1比date2晚，则返回结果为正数，反之则为负数，即返回结果为date1 减去 date2 的差值。
- 如果date1和date2都为其所在月份的第几天，或者都为某个月份的最后一天，那么返回值为一个整数。否则，返回的是一个浮点数，整数部分为两个时间差中完整月份的差数，小数部分则为剩余时间差与一个月（31天）的比例值。
- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**示例**

```
select months_between('2020-05-20'::date,'2020-03-20'::date);
```


返回结果为：

```
 months_between 
----------------
            2
(1 row)
```


###  DECODE

**功能描述**

decode函数将输入数值与函数中的对应参数相比较，若与其中一个参数相等则根据输入值返回一个对应的结果。

函数的参数列表是由输入值，若干用于比较的数值及其对应结果值和默认值组成的。假如输入值未能与任何一个比较数值匹配成功，则函数返回默认值。

**语法格式**

```
DECODE(expr, search1, result1 [, search2, result2 ]...  [, default ])
```

**参数说明**

- expr：可以是数值类型，也可以是字符类型。

- 若expr=search1，则输出result1，expr=search1，输出result1，expr=search2，输出result2……若expr不等于所列出的所有value，则输出为default。

**注意事项**

无。

**示例**

调用函数。

- 输入expr=search1，返回result1。

```
select decode(1,1,'2004-05-07 13:23:44',0,4,5);
```

当结果显示为如下信息，则表示验证成功

```
        case         
---------------------
 2004-05-07 13:23:44
(1 row)
```

- 输入expr=search2返回result2。

```
select decode(0,1,'2004-05-07 13:23:44',0,4,5);
```

当结果显示为如下信息，则表示验证成功

```
 case 
------
 4
(1 row)
```

### RATIO_TO_REPORT

**功能描述**

RATIO_TO_REPORT函数是一个分析函数，主要功能根据over窗口函数的作用区间，求出作用区间中的单个值（expr）在整个区间的总值的比重。
注：如果over（）中为空，就是对整张表的一个分组处理，如果over（coln）中写了分组字段名，就按coln字段分组进行运算。

**语法格式**

```
RATIO_TO_REPORT(expr) OVER([query_partition_clause])
```

**参数说明**

- expr：表达式。
- OVER：对应关键字。
  query_partition_clause：使用query_partition_clause子句定义窗口进行计算。语法格式为partition by col，其中，col为用于分组的列名。如果省略该子句，会计算房前值占所有值的比率。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
create table day_empsalary (
depname varchar,
empno bigint,
salary int,
working_days int
);

insert into day_empsalary values
('develop', 10, 5200, 12),
('sales', 1, 5000, 10),
('personnel', 5, 3500, 11),
('sales', 4, 4800, 5),
('personnel', 2, 3900, 10),
('develop', 7, 4200, 2),
('develop', 9, 4500, 3),
('sales', 3, 4800, 4),
('develop', 8, 6000, 3),
('develop', 11, 5200, 2);
```

2、调用分析函数（省略query_partition_clause子句）

```
select depname, empno, salary, ratio_to_report(salary) over () from day_empsalary order by 1,2;
```

返回结果为:

```
depname  | empno | salary |  ratio_to_report  
-----------+-------+--------+-------------------
develop   |     7 |   4200 |  .089171974522293
develop   |     8 |   6000 |  .127388535031847
develop   |     9 |   4500 | .0955414012738854
develop   |    10 |   5200 |  .110403397027601
develop   |    11 |   5200 |  .110403397027601
personnel |     2 |   3900 | .0828025477707006
personnel |     5 |   3500 | .0743099787685775
sales     |     1 |   5000 |  .106157112526539
sales     |     3 |   4800 |  .101910828025478
sales     |     4 |   4800 |  .101910828025478
(10 rows)
```

3、调用分析函数（不省略query_partition_clause子句）

```
select depname, empno, salary, ratio_to_report(salary) over (partition by depname) from day_empsalary order by 1,2;
```

返回结果为：

```
depname  | empno | salary | ratio_to_report  
-----------+-------+--------+------------------
develop   |     7 |   4200 | .167330677290837
develop   |     8 |   6000 | .239043824701195
develop   |     9 |   4500 | .179282868525896
develop   |    10 |   5200 | .207171314741036
develop   |    11 |   5200 | .207171314741036
personnel |     2 |   3900 | .527027027027027
personnel |     5 |   3500 | .472972972972973
sales     |     1 |   5000 | .342465753424658
sales     |     3 |   4800 | .328767123287671
sales     |     4 |   4800 | .328767123287671
(10 rows)
```

### 函数调用时无入参

**功能描述**

支持在存储过程，函数和触发器中调用无传入参数的函数时省略括号。

**语法格式**
调用无传入参数的自定义函数，调用语法如下：

```
方式一：
select function_name from dual;
方式二：
select * from tab where col=function_name;
```

**注意事项**

如果查询的表字段出现同名函数的时候，where条件不允许输入函数。例如：

```
 create table t2(id int,fun1 varchar2(20));
 select t2 where id=fun1;
```

返回结果为：

```
ERROR:  column "t2" does not exist
LINE 1: select t2 where id=fun1;
               ^
CONTEXT:  referenced column: t2
```

**示例**

1、创建测试表并插入数据。

```
create table t(id int, name varchar2(200)); 
insert into t values (1,'al'); 
insert into t values (2,'a2');
```

2、创建存储存储过程。

```
create or replace function fun1 return number 
as
v_col varchar(100);
begin
select 1 into v_col from dual;
return v_col;
end;
/
```

3、调用方式一。

```
select fun1 from dual;
```

返回结果为：

```
 fun1
------
    1
(1 row)
```

4、调用方式二

```
select * from t where id = fun1;
```

返回结果为：

```
 id | name
----+------
  1 | al
(1 row)
```

5、调用方式三

```
select fun1,id from t where id=2; 
```

返回结果为：

```
 fun1 | id
------+----
    1 |  2
(1 row)
```

### 函数与存储过程传入参数与查询字段同名

**功能描述**

允许存储过程和函数传入参数和逻辑代码中查询的字段重名。

**语法格式**

- 函数创建

```
create or replace function 函数名（参数1 模式 数据类型，......）return 数据类型
```

- 存储过程创建

```
create or replace function 过程名（参数1 模式 数据类型，......）
```

**注意事项**

- 在查询的select部分，如果遇到表字段和传入的参数同名的情况，仍然按照表字段进行查询。
- 在查询的select部分，如果遇到表字段不和传入的参数同名，则查询出传入参数值。
- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**示例**

1、创建并切换至兼容Oracle的库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';
\c db_oracle
```

2、清除测试用表。

```
drop table if exists t1;
drop table if exists t2;
```

3、开启dbms_output功能。

```
set serveroutput on;
```

4、新建测试用表并插入数据（表t1与函数有重名字段id，表t2与函数没有重名字段）。

```
create table t1(id number, name varchar2(200));
Insert into t1 values(1,'a1');
create table t2(val number, name varchar2(200));
Insert into t2 values(1,'a1');
```

5、创建函数。

```
create or replace function func(id number) return number
as
v_id1 number;
v_id2 number;
v_col1 varchar2(100);
v_col2 varchar2(100);
begin
select id,name into v_id1, v_col1 from t1 where id = 1;
select id,name into v_id2, v_col2 from t2 where id = 2;
dbms_output.put_line('id: ' || id);
dbms_output.put_line('v_id1: ' || v_id1);
dbms_output.put_line('v_col1: ' || v_col1);
dbms_output.put_line('v_id2: ' || v_id2);
dbms_output.put_line('v_col2: ' || v_col2);
return 0;
end;
/
```

6、调用函数输入参数为1。

```
select func(1) from dual;
```

返回结果为：

```
id: 1
v_id1: 1
v_col1: a1
v_id2:
v_col2:
 func
------
    0
(1 row)
```

7、调用函数输入参数为2。

```
select func(2) from dual;
```

返回结果为：

```
id: 2
v_id1: 1
v_col1: a1
v_id2: 2
v_col2: a1
 func
------
    0
(1 row)
```

###  ROWIDROCHAR

**功能描述**

该函数用于将rowid类型转换为字符串类型。

**语法格式**

```
rowidtochar(rowid)
```

**参数说明**

rowid：输入的rowid值。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
drop table testrowid;
create table testrowid(c1 int,c2 varchar(20));
insert into testrowid values(1,'Lucy');
insert into testrowid values(2,'Sally');
```

2、调用 rowidtochar函数。

```
select rowidtochar(rowid) from testrowid;
```

返回结果如下：

```
     rowidtochar
----------------------
 hksAAA==AAAAAA==AQA=
 hksAAA==AAAAAA==AgA=
(2 rows)
```

### CHARTOROWID

**功能描述**

该函数用于字符串类型转换为将rowid类型。

**语法格式**

```
chartorowid(char)
```

**参数说明**

char：输入的字符串值，支持输入CHAR,VARCHAR2,NCHAR,NVARCHAR2的数据类型。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
DROP TABLE testrowid;
create table testrowid (c1 int,c2 varchar(20));
insert into testrowid values(1,'Lucy');
insert into testrowid values(2,'Sally');
insert into testrowid values(3,'Ben');
insert into testrowid values(4,'Black');
```

2、查询rowid。

```
select rowid from testrowid order by rowid;
        rowid
----------------------
 fksAAA==AAAAAA==AQA=
 fksAAA==AAAAAA==AgA=
 fksAAA==AAAAAA==AwA=
 fksAAA==AAAAAA==BAA=
(4 rows)
```

3、调用CHARTOROWID函数（其中单引号中的内容为步骤3中的最后一条数据）。

```
select * from testrowid where rowid < CHARTOROWID('fksAAA==AAAAAA==BAA=');
```

返回结果为：

```
 c1 |  c2
----+-------
  1 | Lucy
  2 | Sally
  3 | Ben
(3 rows)
```

###  ORA_HASH

**功能描述**

该函数用于为给定表达式计算哈希值。

**语法格式**

```
ora_hash（expr[,max_bucket[,seed_value]])
```

**参数说明**

- expr：需要计算hash值的表达式或者列。
- max_bucket：哈希函数返回的最大桶值，范围0到4294967295，默认为4294967295。
- seed_value：为同一组数据生成许多不同的结果，范围0到4294967295，默认为0。当seed_value值不一样时，产生的结果值不一样。

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**示例**

1、创建测试表并插入数据。

```
drop table test_hash ;
create table test_hash(c1 int,c2 varchar(20));
insert into test_hash values(1,'test1');
insert into test_hash values(2,'test2');
```

2、调用ORA_HASH函数。

```
select ora_hash(c2,12,11) from test_hash;
```

返回结果为：

```
 ora_hash
----------
        5
        6
(2 rows)
```

### JSON_MERGEPATCH

**功能描述**

json_mergepatch函数可查询和更新json文档的特定部分。

**语法格式**

```
 JSON_MERGEPATCH
         (target_expr,patch_expr[returning_clause] )
```

**参数说明**

- target_expr：需要修改的目标表达式（以下简称源）。

- patch_expr：一个json片段，表达要合并到目标表达式中的补丁（以下简称补丁）。

- json_returning_clause：指定操作符的返回类型。默认的返回类型是text。

**注意事项**

- 使用该函数需要具备该函数的访问权限，例如json_mergepatch函数如果位于pg_catalog模式下，用户需要具备以下权限：

  	- pg_catalog模式的usage权限。
  	- json_mergepatch函数的excute权限。

- json的数据类型有：空值null、布尔值false/true、字符串”string”、数组[]和对象{}。数组[]和对象{}称为复杂数据类型，可嵌套使用。

- 补丁必须为数组或者对象，否则会报错。

  - 补丁为数组时： 
    - 源是空值null、布尔值false/true或者字符串”string”时，返回null。
    - 源为数组或者对象时，使用补丁替换源。
  - 补丁为对象时：
    - 源是空值null、布尔值false/true或者字符串”string”时，返回null。
    - 源为数组时，去除补丁中值为null的键值对后再替换源。
    - 源为对象时，按照如下两个对象合并规则合并。

- 两个对象合并规则：

  - 如果补丁不是JSON对象。使用补丁替换源（补丁值为null时，若源中没有对应补丁的键，
    则该键值对不能出现在结果中）。
  - 如果补丁是JSON对象，请执行以下操作:

  (1)如果源不是对象，则将其视为空对象({})。
  (2)迭代补丁对象的(p-field:p-value)成员。

  - 如果补丁成员的p-value为null，则从源中删除相应的成员。
  - 否则，递归：源对应的值和p-value合并的结果，替换相应源字段的值。

- Vastbase处理json数据时会对object的键值对中的键进行排序和去除相同键，因此object中的键值对和输入时的顺序可能会不一样。Vastbase注重合并结果，不保证顺序或者空格的使用上和Oracle完全一致。

- 隐式转化规则新增了text和json/jsonb相互转化外。

**示例**
1、创建测试表并插入数据。

```
create table json_mergepatch_test(Id  bigint,Data json );
INSERT INTO json_mergepatch_test (id,data) values(1,'{"id":1,"first_name":"Iron","last_name":"Man"}');
```

2、查询数据。

```
SELECT JSON_MERGEPATCH(data, '{"last_name":"banana"}') AS data FROM json_mergepatch_test;
```

返回结果为：

```
                          data
--------------------------------------------------------
 {"id": 1, "last_name": "banana", "first_name": "Iron"}
(1 row)
```

3、更新表中的数据。

```
UPDATE json_mergepatch_test a SET a.data = JSON_MERGEPATCH(a.data, '{"last_name":"banana","new_element":"surprise"}');
```

4、查询数据。

```
SELECT data FROM json_mergepatch_test;
```

返回结果为：

```
                                       data
-----------------------------------------------------------------------------------
 {"id": 1, "last_name": "banana", "first_name": "Iron", "new_element": "surprise"}
(1 row)
```

### SYS_EXTRACT_UTC

**功能描述**

sys_extract_utc函数将一个带有时区的时间对象，转变成其等效的国际标准时间（格林威治时间）。即把timestamp with time zone类型，转成timestamp without time zone类型。

**语法格式**

```
SYS_EXTRACT_UTC(datetime_with_timezone)
```

**参数说明**

datetime_with_timezone：timestamptz（即timestamp with time zone）类型。

**注意事项**

使用该函数需要具备该函数的访问权限，例如sys_extract_utc函数如果位于pg_catalog模式下，用户需要具备以下权限：

- pg_catalog模式的usage权限

- sys_extract_utc函数的excute权限

**示例**

1、创建测试表。

```
DROP TABLE t_utc;
CREATE TABLE t_utc(c1 timestamptz);
```

2、向表中插入带有时区的数据。

```
insert into t_utc values('2022-02-02 10:00:00 +4:00');
insert into t_utc values('2022-02-03 12:00:00 -2:00');
insert into t_utc values('2010-01-03 11:09:00 +0:00');
```

3、查询数据。

```
select sys_extract_utc(c1) from t_utc; 
```

返回结果为：

```
   sys_extract_utc
---------------------
 2022-02-02 06:00:00
 2022-02-03 14:00:00
 2010-01-03 11:09:00
(3 rows)
```

### NLS_UPPER与NLS_LOWER

**功能描述**

nls_upper函数用于将字符转换为大写，nls_lower函数用于将字符转换为小写。

**语法格式**

nls_upper语法：

```
NLS_UPPER(char [, 'nlsparam' ])
```

nls_lower语法：

```
NLS_LOWER(char [, 'nlsparam' ])
```

**参数说明**

- char：需要转换的字符串，可以是char、varchar2、nchar、nvarchar2和clob。

- nlsparam：可选参数，不区分大小写，用于指定排序的方式，常见的有SCHINESE_RADICAL_M（部首、笔画）排序、SCHINESE_STROKE_M（笔画、部首)排序，SCHINESE_PINYIN_M（拼音）排序。

**注意事项**

使用该函数需要具备该函数的访问权限，例如nls_upper和nls_lower函数如果位于pg_catalog模式下，用户需要具备以下权限：

- pg_catalog模式的usage权限
- sys_extract_utc函数的excute权限

**示例**

- 将字符转化为大写。

```
select nls_upper('asdasd') from dual;
```

返回结果为：

```
 nls_upper
-----------
 ASDASD
(1 row)
```

- 将字符转化为小写。

```
select nls_lower('SADAS') from dual;
```

返回结果为：

```
 nls_lower
-----------
 sadas
(1 row)
```

### NUMTOYMINTERVAL

**功能描述**

NUMTOYMINTERVAL函数将数字n转换为年或者月的间隔。

**语法格式**

```
NUMTOYMINTERVAL(n,'interval_unit')
```

**参数说明**

- n：可以是任何NUMBER值或可以隐式转换为NUMBER值的表达式（n为NULL，输出为空）。

- interval_unit：可以是char、varchar2、nchar或nvarchar2数据类型。interval_unit的值指定n

  的单位，并且必须解析为以下字符串值之一（不区分大小写）：

  - YEAR：取值范围[-2147483648，2147483647]

  - MONTH：取值范围[-178956970.7,178956970.6]

**功能描述**

使用该函数需要具备该函数的访问权限，例如numtoyminterval函数如果位于pg_catalog模式下，用户需要具备以下权限：

- pg_catalog模式的usage权限
- numtoyminterval函数的excute权限

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比的差异，Oracle中interval_unit指定n单位，并且必须解析为以下字符串值之一：DAY，HOUR，MINUTS，SECOND。

**示例**

```
select sysdate,sysdate+numtoyminterval(3,'year') as res from dual;
```

返回结果为：

```
       sysdate       |         res
---------------------+---------------------
 2022-07-14 16:13:19 | 2025-07-14 16:13:19
(1 row)
```

### ROWIDTOCHAR和CHARTOROWID

**功能描述**

ROWIDTOCHAR函数，将rowid类型转换为字符串类型。

CHARTOROWID函数，将字符串类型转换为rowid类型。

**语法格式**

```
rowidtochar(rowid)
chartorowid(char)
```

**参数说明**

- rowid：输入的rowid值。

- char：输入的字符串。

**示例**

- **ROWIDTOCHAR函数**

1、创建测试表并插入数据。

```
drop table testrowid;
drop table testrowid1;
create table testrowid(c1 int);
create table testrowid1(c1 varchar(20));
insert into testrowid values(1);
insert into testrowid values(2);
```

2、使用ROWIDTOCHAR函数。

```
select rowidtochar(rowid) from testrowid;
```

返回结果为：

```
     rowidtochar
----------------------
 51IAAA==AAAAAA==AQA=
 51IAAA==AAAAAA==AgA=
(2 rows)
```

- **CHARTOROWID函数**

1、创建测试表并插入数据。

```
DROP TABLE testrowid;
create table testrowid (c1 int,c2 varchar(20));
insert into testrowid values(1,'Lucy');
insert into testrowid values(2,'Sally');
insert into testrowid values(3,'Ben');
insert into testrowid values(4,'Black');
```

2、查询ROWID。

```
select rowid from testrowid order by rowid;
```

返回结果为：

```
        rowid
----------------------
 81IAAA==AAAAAA==AQA=
 81IAAA==AAAAAA==AgA=
 81IAAA==AAAAAA==AwA=
 81IAAA==AAAAAA==BAA=
(4 rows)
```

3、将CHAR数据类型转换为ROWID数据类型(CHARTOROWID函数中单引号内的内容为上一步骤的第二条)。

```
select * from testrowid where rowid = CHARTOROWID('81IAAA==AAAAAA==AgA=');
```

返回结果为：

```
 c1 |  c2
----+-------
  2 | Sally
(1 row)
```

### MOD

**功能描述**

mod(nExp1,nExp2)函数是一个求余函数，即nExp1（被除数）除以nExp2（除数）运算后的余数。

**语法格式**

```
mod(nExp1,nExp2)
```

**参数说明**

- nExp2：除数
- nExp1：被除数

**注意事项**

- 两个整数求余时，其值的符号与除数（nExp2）的符号相同，取值为将两个整数看作是正数，再作除法运算。

  - 能整除时，其值为0。
  - 不能整除时，其值=除数×（整商+1）-被除数

  例：mod(36,-10)，结果为将36除以10的整商为3，因此结果=10×(3+1)-36=4，取除数（-10）的符号，最终结果-4。

- 两个小数求余，其值=被除数-（整商×除数）之后在第一位小数位进行四舍五入。

  例：mod(9,1.2)，结果为9除以1.2其整商为7，因此结果9-(7×1.2)=0.6。最终结果0.6。

**示例**

```
select mod(36,-10);
```

返回结果为：

```
 mod
-----
   6
(1 row)
```

### REMAINDER

**功能描述**

remainder(n2,n1)函数的主要功能是求余数，该函数返回第一个参数除以第二个参数的余数。

**语法格式**

```
REMAINDER(n2, n1)
```

**参数说明**

n1,n2：为数值类型或者可以隐式转换为数值类型的类型。

**注意事项**

- 使用该函数需要具备该函数的访问权限，例如remainder函数如果位于pg_catalog模式下，用户需要具备以下权限：

  - pg_catalog模式的usage权限

  - remainder函数的excute权限

- 如果n1=0或n2=infinity（无穷大），返回结果为：
  - 如果参数的类型为number，报错。
  - 如果参数是binary_float或binary_double，则为NaN。

- 如果n1!=0，则余数为n2-(n1*N)，其中N是最接近n2/n1的整数。如果n2/n1等于x.5，则N是最接近的偶数。例如：

```
在remainder(3.5,2)中，n2=3.5,n1=2，按计算规则，n2/n1=3.5/2=1.75,最接近的整数N为2。n2-(n1*N)=3.5-(2*2)=-0.5
```

- 如果n2是一个浮点数，如果余数是0，那么余数的符号就是n2的符号。对于number值，余数0是无符号的。

**兼容性**

完全兼容。

**示例**

```
select remainder(3.3,2);
```

返回结果为：

```
 remainder
-----------
       -.7
(1 row)
```

### TO_DSINTERVAL和TO_YMINTERVAL

**功能描述**

TO_DSINTERVAL 函数将时间转换为DAY TO SECOND INTERVAL数据类型，即处理时间时仅包含日期，小时，分钟和秒的部分。

TO_YMINTERVAL函数将其参数转换为YEAR TO MONTH INTERVAL数据类型，即处理时间时仅包含年和月的部分。

**语法格式**

to_dsinterval函数

```
TO_DSINTERVAL ('[+ | -] days hours : minutes : seconds ' [ DEFAULT return_value ON CONVERSION ERROR ]
```

to_yminterval函数

```
TO_YMINTERVAL ( '{ [+|-] years - months } ' [ DEFAULT return_value ON CONVERSION ERROR ])
```

**参数说明**

to_dsinterval函数：

- days：天，整形，范围0到999999999。
- hours：小时，整形，范围0到23。
- minutes：分，整形，范围0到59。
- seconds：秒，整形，范围0到59，Vastbase秒后的小数点支持到6位（Oracle秒后的小数点支持到9位）。
- DEFAULT return_value ON CONVERSION ERROR：可选参数，该子句允许指定此函数在将参数转换为INTERVAL DAY TO SECOND类型时发生错误时返回的值。

 to_yminterval函数：

- years：年，整形，Vastbase取值范围0到178956970（Oracle取值范围0到999999999）。
- months：小时，整形，范围0到11。
- u DEFAULT return_value ON CONVERSION ERROR：可选参数。该子句允许指定此函数在将参数转换为INTERVAL MONTH TO YEAR类型时发生错误时返回的值。

**注意事项**

- to_dsinterval函数将传入字符串转换为INTERVAL数据类型。函数接收两种格式字符串。

  -  SQL格式，兼容SQL标准（ISO/IEC9075）。

     - 不允许输入年和月。
     - 语法元素之间允许任意个空格。
  -  SISO格式，兼容ISO 8601:2004标准。
     -  不允许输入年和月。

     -  语法元素之间不允许有空格。

     -  输入的时间如果出现进位，进位之后的结果超出输入限制是允许的。
- to_yminterval函数将传入字符串转换为INTERVAL数据类型。函数接收两种格式字符串。
  - SQL格式，兼容SQL标准（ISO/IEC9075）。
    - 仅允许出现年和月。
    - 语法元素之间允许任意个空格。
  - ISO格式，兼容ISO 8601:2004标准。
    - 年、月、日、时、分、秒和小数秒，均允许输入，但除年和月以外的内容会被忽略。
    - 秒的小数位支持输入9位，超出后报错（虽然秒会被忽略，但会引发报错）。
    - Vastbase年数范围为0到178956970。如果输入月数大于等于12时，会出现向年份进位的情况，进位之后应保证年数范围依然在0到178956970，否则报错。
    - 语法元素之间不允许有空格。

**示例**

- to_dsinterval函数：

```
select to_dsinterval('1 12 : 34 : 56 ')  from dual;  
```

返回结果为：

```
 to_dsinterval
----------------
 1 day 12:34:56
(1 row)
```

- to_yminterval函数：

```
select to_yminterval('1-1') from dual;
```

返回结果为：

```
 to_yminterval
---------------
 1 year 1 mon
(1 row)
```

### TO_TIMESTAMP_TZ

**功能描述**

TO_TIMESTAMP_TZ函数用于将字符类型的输入转化成带时区的timestamptz（存储时间戳的数据类型）。

**语法格式**

```
TO_TIMESTAMP_TZ(char  [, fmt [, 'nlsparam' ] ])
```

**参数说明**

- char：接受CHAR、VARCHAR2、NCHAR和NVARCHAR2数据类型的字符串输入。

- fmt：沿用当前数据库时间日期格式。

- nlsparam：仅需支持'NLS_DATE_LANGUAGE=''SIMPLIFIED CHINESE''和"NLS_DATE_LANG

UAGE=ENGLISH"（即中文和英文输入）。

**注意事项**

- 暂不支持DEFAULT return_value ON CONVERSION ERROR可选参数。
- 此函数不会将字符串转换为timestamp with local time zone类型。

**示例**

```
select to_timestamp_tz('2003/12/13 10:13:18', 'YYYY/MM/DD HH:MI:SS');
```

返回结果为：

```
    to_timestamp_tz
------------------------
 2003-12-13 10:13:18+08
(1 row)
```

### ALL

**功能描述**

ALL函数用于判断数组中所有元素都是否为真（非零或true）。用逗号分隔的方式输入数组表达式的各个分量。

**语法格式**

```
op ALL(ARRAY[expr,])
```

**参数说明**

- op：指定的运算符，诸如‘>’，‘<’，‘=’等等。
- ARRAY：指显示指定数组表达式的关键字，中括号内部可以指定多个表达式。

**示例**

1、创建测试表并插入数据。

```
create table testall(id int,name char(10));
insert into testall values(1,'amy');
insert into testall values(2,'tom');
insert into testall values(3,'jack');
insert into testall values(97,'jane');
insert into testall values(98,'alice');
insert into testall values(99,'taylor');
```

2、使用ALL函数。

```
select * from testall where id  >= all(2,3);
```

返回结果为：

```
 id |    name
----+------------
  3 | jack
 97 | jane
 98 | alice
 99 | taylor
(4 rows)
```

##  内置包

###  DBMS_ROWID

**功能描述**
该内置包用于我们从PL/SQL和SQL中创建ROWIDs和获取关于ROWIDs的信息。该内置包包含以下函数：

- ROWID_CREATE函数：rowid_create函数用于创建一个rowid。


**语法格式**

```
dbms_rowid.rowid_create(
rowid_type number,
object_number number,
relative_fno number,
block_number number,
row_number number);
```

**参数说明**

- rowid_type：rowid类型（restricted或者extended），目前Vastbase G100的orwid只实现了extended类型，因此该参数目前不生效。
- object_number：数据库对象oid，Vastbase G100中主要是表的oid。不能小于0，不能为小数。
- relative_fno：所在数据库文件编号，Vastbase G100的rowid未实现此功能，因此不生效。
- block_number：数据块编号。不能小于0，不能为小数。
- row_number：块中偏移量。不能小于0，不能为小数。

**注意事项**

无。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：ROWID_BLOCK_NUMBER、 ROWID_INFO、 ROWID_OBJECT、ROWID_RELATIVE_FNO、ROWID_ROW_NUMBER、ROWID_TO_ABSOLUTE_FNO、ROWID_TO_EXTENDED、ROWID_TO_RESTRICTED、ROWID_TYPE、ROWID_VERIFY

**示例**

```
select dbms_rowid.rowid_create(0,1,1,1,1);
```

返回结果为：

```
rowid_create
----------------------
AQAAAA==AQAAAA==AQA=
(1 row)
```

###  DBMS_RANDOM

**功能描述**
dbms_random是一个PL/SQL包，用于生成随机数和随机字符。该内置包包含以下函数：

<table>
<tr>
<th>
函数
</td>
<th>
描述
</td>
</tr>
<tr>
<td>
<a href="#INITIALIZE">INITIALIZE</a>
</td>
<td>
使用种子值初始化包。
</td>
</tr>
<tr>
<td>
<a href="#NORMAL">NORMAL</a>
</td>
<td>
返回生态分布中随机数。
</td>
</tr>
<tr>
<td>
<a href="#RANDOM">RANDOM</a>
</td>
<td>
生成一个随机数。
</td>
</tr>
<tr>
<td>
<a href="#SEED">SEEd</a>
</td>
<td>
重置种子。
</td>
</tr>
<tr>
<td>
<a href="#STRING">STRING</a>
</td>
<td>
获取随机字符串。
</td>
</tr>
<tr>
<td>
<a href="#TERMINATE">TERMINATE</a>
</td>
<td>
终止包。
</td>
</tr>
<tr>
<td>
<a href="#VALUE">VALUE</a>
</td>
<td>
获取一个大于等于0小于1的随机数，或者得到指定区间的随机数。
</td>
</tr>
</table>


**注意事项**

无。

**兼容性**

完全兼容。

#### INITIALIZE函数<a id="INITIALIZE"></a>

**语法格式**

```
DBMS_RANDOM.INITIALIZE (
   val  IN  BINARY_INTEGER);
```

**参数说明**

val：用于生成随机数的种子号。

**示例**

```
select dbms_random.initialize(123456);
 initialize 
------------

(1 row)
```

#### NORMAL函数<a id="NORMAL"></a>

**语法格式**

```
DBMS_RANDOM.NORMAL
  RETURN NUMBER;
```

**示例**

```
select dbms_random.normal();
     normal     
----------------
 1.560225125239
(1 row)
```

#### RANDOM函数<a id="RANDOM"></a>

**语法格式**

```
DBMS_RANDOM.RANDOM
   RETURN binary_integer;
```

**示例**

```
select dbms_random.random();
   random   
------------
 1356653482
(1 row)
```

#### SEED函数<a id="SEED"></a>

**语法格式**

```
DBMS_RANDOM.SEED (
   val  IN  BINARY_INTEGER);

DBMS_RANDOM.SEED (
   val  IN  VARCHAR2);
```

**参数说明**

val：用于生成随机数的种子号或字符串。

**示例**

```
select dbms_random.seed('asda');
 seed 
------

(1 row)
```

#### STRING函数<a id="STRING"></a>

**语法格式**

```
DBMS_RANDOM.STRING
   opt  IN  CHAR,
   len  IN  NUMBER)
  RETURN VARCHAR2;
```

**参数说明**

- opt：字符串输出格式。
- len：字符串输出长度。

**示例**

```
select dbms_random.string('x',9);
  string   
-----------
 ZTZAXREFR
(1 row)

```

#### TERMINATE函数<a id="TERMINATE"></a>

**语法格式**

```
DBMS_RANDOM.TERMINATE;
```

**示例**

```
select dbms_random.terminate();
 terminate
-----------

(1 row)



```

#### VALUE函数<a id="VALUE"></a>

**语法格式**

```
DBMS_RANDOM.VALUE
  RETURN NUMBER;

DBMS_RANDOM.VALUE(
  low  IN  NUMBER,
  high IN  NUMBER)
RETURN NUMBER;
```

**参数说明**

- low：生成随机数范围内的最小数，生成的数字可能等于low。
- high：生成随机数的最大值，生成的数字将小于high。

**示例**

```
vastbase=# select dbms_random.value();
      value      
-----------------
 .48548461124301
(1 row)


vastbase=#  select dbms_random.value(100,2200);
      value       
------------------
 1328.65713294595
(1 row)

```

###  DBMS_ASSERT

**功能描述**

该内置包用于验证输入值的属性。该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td><a href="#ENQUOTE_LITERAL">ENQUOTE_LITERAL</a></td>
<td>输入字符串满足下述要求时，在字符串首位两端补充单引号：<br />
a. 必须保证除首尾两端的单引号之外，其余单引号必须紧邻成对出现，且成对紧邻出现时不能出现在字符串开头。<br />
b. 若原始字符串两端已有单引号，则本接口不再额外在字符串两端补充单引号。</td>
</tr>
<tr>
<td> <a href="#SCHEMA_NAME">SCHEMA_NAME</a></td>
<td>判断输入字符串是否为有效的模式名，若有效则返回该模式名。</td>
</tr>
<tr>
<td><a href="#SQL_OBJECT_NAME">SQL_OBJECT_NAME</a></td>
<td>判断输入字符串是否为有效的SQL对象名，若有效则返回该对象名。<br />输入的对象名可以是如下情况：<br />a. 若输入的对象名是同义词名，则要求其基本对象必须存在。<br />b. 该函数可识别的 SQL对象包括表，视图，同义词，索引，序列，包，触发器，函数，存储过程。<br />c. 输入内容可带从属关系，支持的从属关系输入方式包括：<br />模式名.表名   <br />模式名.视图名 <br />模式名.索引名  <br />模式名.序列名   <br />模式名.包名   <br />模式名.包名.函数名（SQL语句暂不支持) <br />模式名.包名.存储过程名（SQL语句暂不支持)  <br />模式名.包名.变量名( SQL语句暂不支持)<br />模式名.函数名   <br />模式名.存储过程名  <br />模式名.同义词   <br />模式名.表名.字段名   <br />模式名.视图名.字段名  <br />表名.字段名   <br />视图名.字段名</td>
</tr>
</table>


**注意事项**

无。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：ENQUITE_NAME、NOOP、QUALIFIED、SIMPLE_SQL_NAME。


#### ENQUOTE_LITERAL函数<a id="ENQUOTE_LITERAL"></a>

**语法格式**

```
DBMS_ASSERT.ENQUOTE_LITERAL (
   str            VARCHAR2);
```

**参数说明**

str：要引用的字符串。

**示例**

```
select DBMS_ASSERT.ENQUOTE_LITERAL('abcedf') from dual;
   enquote_literal 
  -----------------
   'abcedf'
  (1 row)
```

####  SCHEMA_NAME函数<a id="SCHEMA_NAME"></a>

**语法格式**

```
DBMS_ASSERT.SCHEMA_NAME (
   str      VARCHAR2 CHARACTER SET ANY_CS)；
```

**参数说明**

str：有效的模式名称。

**示例**

```
create schema testname;
select DBMS_ASSERT.SCHEMA_NAME('testname');
   schema_name 
  -------------
   testname
  (1 row)
```

####  SQL_OBJECT_NAME函数<a id="SQL_OBJECT_NAME"></a>

**语法格式**

```
DBMS_ASSERT.SQL_OBJECT_NAME (
   str      VARCHAR2 CHARACTER SET ANY_CS);
```


**参数说明**

str：有效的模式名称。

**示例**

1、创建函数test_f。

```
create function test_f(int) returns int as $$
  begin
  raise notice 'test_f%',$1;
  return $1;
  end $$ language plpgsql;
```

2、调用SQL_OBJECT_NAME函数。

```
select DBMS_ASSERT.SQL_OBJECT_NAME('test_f');
```

返回结果为：

```
  sql_object_name 
  -----------------
   test_f
  (1 row)
```

### DBMS_OUTPUT

**功能描述**

DBMS_OUTPUT内置包用于提供在存储过程或包内对外发送信息的功能，该内置包包含以下函数：

<table>
<tr>
<th>
函数
</td>
<th>
描述
</td>
</tr>
<tr>
<td>
enable
</td>
<td>
用来使dbms_output生效。
</td>
</tr>
<tr>
<td>
disable
</td>
<td>
用来使dbms_output失效。
</td>
</tr>
<tr>
<td>
put
</td>
<td>
将数据写入到缓存中，等到put_line/new_line时一起输出。
</td>
</tr>
<tr>
<td>
put_line
</td>
<td>
将数据写入到缓存中，并将缓存中的数据一起输出。
</td>
</tr>
<tr>
<td>
new_line
</td>
<td>
向put写入的行末尾添加终结符，如果缓存中有数据将其输出。
</td>
</tr>
<tr>
<td>
get_line
</td>
<td>
从缓存中读取一行数据。
</td>
</tr>
<tr>
<td>
get_lines
</td>
<td>
从缓存中读取多行数据。
</td>
</tr>
</table>

说明：serveroutput 为on 时允许将dbms_output.put_line的输出信息输出至vsql的命令界面的屏幕上。使用以下语句设置参数：

```
SET serveroutput =on 
```

serveroutput默认值是off  可以通过配置.psqlrc文件设置缺省值。

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。


**示例**

1、创建并切换至兼容模式为ORACLE的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility=’B’;     
\c db_oracle
```

2、创建测试表并插入数据。

```
CREATE TABLE emp (
 empno NUMBER(4) ,
 ename VARCHAR2(10),
 job VARCHAR2(9),
 mgr NUMBER(4),
 hiredate DATE,
 sal NUMBER(7,2) CONSTRAINT emp_sal_ck CHECK (sal > 0),
 comm NUMBER(7,2));
INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,'17-DEC-80',800,NULL);
INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN',7698,'20-FEB-81',1600,300);
INSERT INTO emp VALUES (7521,'WARD','SALESMAN',7698,'22-FEB-81',1250,500);
INSERT INTO emp VALUES (7566,'JONES','MANAGER',7839,'02-APR-81',2975,NULL);
INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN',7698,'28-SEP-81',1250,1400);
INSERT INTO emp VALUES (7698,'BLAKE','MANAGER',7839,'01-MAY-81',2850,NULL);
INSERT INTO emp VALUES (7782,'CLARK','MANAGER',7839,'09-JUN-81',2450,NULL);
INSERT INTO emp VALUES (7788,'SCOTT','ANALYST',7566,'19-APR-87',3000,NULL);
INSERT INTO emp VALUES (7839,'KING','PRESIDENT',NULL,'17-NOV-81',5000,NULL);
INSERT INTO emp VALUES (7844,'TURNER','SALESMAN',7698,'08-SEP-81',1500,0);
INSERT INTO emp VALUES (7876,'ADAMS','CLERK',7788,'23-MAY-87',1100,NULL);
INSERT INTO emp VALUES (7900,'JAMES','CLERK',7698,'03-DEC-81',950,NULL);
INSERT INTO emp VALUES (7902,'FORD','ANALYST',7566,'03-DEC-81',3000,NULL);
INSERT INTO emp VALUES (7934,'MILLER','CLERK',7782,'23-JAN-82',1300,NULL);
```

3、创建并调用存储过程。

```
CREATE OR REPLACE PROCEDURE list_emp()
 IS
 v_empno NUMBER(4);
 v_ename VARCHAR2(10);
 cursor emp_cur  is  SELECT empno, ename FROM emp ORDER BY empno;
BEGIN
 OPEN emp_cur;
 DBMS_OUTPUT.PUT_LINE('EMPNO ENAME');
 DBMS_OUTPUT.PUT_LINE('----- -------');
 LOOP
 FETCH emp_cur INTO v_empno, v_ename;
 EXIT WHEN emp_cur%NOTFOUND;
 DBMS_OUTPUT.PUT_LINE(v_empno || ' ' || v_ename);
 END LOOP;
 CLOSE emp_cur;
END;
/

vastbase=# call list_emp();
```

返回结果为：

```
EMPNO ENAME
----- -------
7369 SMITH
7499 ALLEN
7521 WARD
7566 JONES
7654 MARTIN
7698 BLAKE
7782 CLARK
7788 SCOTT
7839 KING
7844 TURNER
7876 ADAMS
7900 JAMES
7902 FORD
7934 MILLER
 list_emp
----------

(1 row)
```

### UTL_SMTP

**功能描述**

该内置包提供了发送邮件的功能。该内置包包含以下函数：

<table>
<tr>
<th>
函数
</td>
<th>
描述
</td>
</tr>
<tr>
<td>
<a href="#open_connection">OPNE_CONNECTION</a>
</td>
<td>
与SMTP服务器建立连接。
</td>
</tr>
<tr>
<td>
<a href="#auth">AUTH</a>
</td>
<td>
向SMTP服务器发送AUTH命令进行身份验证。
</tr>
<tr>
<td>
<a href="#helo">HELO</a>
</td>
<td>
使用helo命令与SMTP服务器进行初始化握手。
</td>
</tr>
<tr>
<td>
<a href="#mail">MAIL</a>
</td>
<td>
设置与SMTP服务器发送的邮箱地址。
</td>
</tr>
<tr>
<td>
<a href="#rcpt">RCPT</a>
</td>
<td>
指定接收邮箱地址。
</td>
</tr>
<tr>
<td>
<a href="#open_data">OPNE_DATA</a>
</td>
<td>
发送DATA命令，后面调用write_data写入要发送的文本信息。
</td>
</tr>
<tr>
<td>
<a href="#write_data">WRITE_DATA</a>
</td>
<td>
发送邮件文本内容，重复调用可以将数据附加到内容中。
</td>
</tr>
<tr>
<td>
<a href="#close_data">CLOSE_DATA</a>
</td>
<td>
结束发送电子邮件。
</td>
</tr>
<tr>
<td>
<a href="#quit">QUIT</a>
</td>
<td>
断开与SMTP服务器的连接。
</td>
</tr>
</table>

**注意事项**

- Vastbase G100 V2.2是基于plpython3u实现以上函数及存储过程，完成发送邮件的功能。

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：command、command_replies、date、ehlo、help、noop、starttls、vrfy、write_raw_data。

**使用流程**

1、安装python3。

由于该功能基于python3(python3.8)的环境，且带有libpython3.8.so库文件（编译时指定--enable-shared可生成）。

若需要启用tls安全认证，需要安装openssl及openssl-devel，且python3编译时指定--with-ssl-default-suites=openssl，如安装完在python3命令行执行import ssl成功，则说明安装ssl模块成功。

注：麒麟系统import ssl如出现symbol SSLv3_method not defined的错误，是openssl的版本不支持SSLv3。可在python3源码修改Mudule/_ssl.c中的SSLv3_method()为DTLS_method()，保存后重新编译python3即可。

2、添加如下环境变量。

- PYTHONHOME：python3安装路径
- LD_LIBRARY_PATH：增加python3安装路径下的lib目录
- PATH：增加python3安装路径bin目录

3、创建plython3u扩展。

```
--切换到目标DB
\c targetDB
--创建plpython3u扩展
vastbase=# create extension plpython3u;
--查看到内置包相关函数信息
\df utl_smtp.*
```

4、调用函数发送邮件。

```
--创建发送邮件函数：（v_sender填写企业邮箱发送邮箱地址，v_passwd填写邮箱密码）
CREATE OR REPLACE FUNCTION send_mail(recipient varchar, subject varchar, message varchar) returns void as
$$
declare
v_mailhost varchar := '119.147.3.176';
v_sender varchar := 'xxxx@vastdata.com.cn';
v_passwd varchar := 'xxxx';
v_conn utl_smtp.connection;
v_msg varchar;
crlf varchar(2) := CHR(10);
v_ret varchar;
err_context text;
begin
v_conn := utl_smtp.open_connection(v_mailhost, 587, 1000, true);
perform utl_smtp.auth(v_conn, v_sender, v_passwd, 'CRAM-MD5 PLAIN LOGIN');
perform utl_smtp.helo(v_conn, v_mailhost);
perform utl_smtp.mail(v_conn, v_sender);
perform utl_smtp.rcpt(v_conn, recipient);
v_msg := 'From: ' || v_sender || crlf ||
'To: ' || recipient || crlf ||
'Subject: ' || subject || crlf ||
crlf || message;
raise notice '%', v_msg;
perform utl_smtp.open_data(v_conn);
perform utl_smtp.write_data(v_conn, v_msg);
perform utl_smtp.close_data(v_conn);
perform utl_smtp.quit(v_conn);
exception
when others then
GET STACKED DIAGNOSTICS err_context = PG_EXCEPTION_CONTEXT;
RAISE INFO 'Error Name:%',SQLERRM;
RAISE INFO 'Error State:%', SQLSTATE;
RAISE INFO 'Error Context:%', err_context;
end;
$$ LANGUAGE plpgsql;

--调用send_mail函数发送邮件：（第一个参数填写接收邮箱地址）
select send_mail('xxx@qq.com', 'utl_smtp测试', '您好，这是测试邮件！');
```

#### OPEN_CONNECTION函数<a id="open_connection"></a>

**语法格式**

```
UTL_SMTP.OPEN_CONNECTION (
   host                            IN  VARCHAR2, 
   port                            IN  PLS_INTEGER DEFAULT 25, 
   c                               OUT connection, 
   tx_timeout                      IN  PLS_INTEGER DEFAULT NULL,
   wallet_path                     IN  VARCHAR2 DEFAULT NULL,
   wallet_password                 IN  VARCHAR2 DEFAULT NULL, 
   secure_connection_before_smtp   IN  BOOLEAN DEFAULT FALSE,
   secure_host                     IN  VARCHAR2 DEFAULT NULL)
 RETURN connection; 
```

**参数说明**

- host：SMTP服务器地址。

- port：SMTP服务器端口，默认25。

- c：SMTP连接。

- tx_timeout：UTL_SMTP包在连接中的读或写操作超时等待的时间（秒），默认为NULL。

- wallet_path：指定客户端钱包，默认为NULL（接口预留，暂不实现）。

- wallet_password：打开钱包的密码，默认为NULL（接口预留，暂不实现）。

- secure_connection_before_smtp：是否在smtp通信之间建立SSL/TLS的安全连接，默认为false。

- secure_host：使用安全连接的证书域名，默认为NULL（接口预留，暂不实现）

#### AUTH函数<a id="auth"></a>

**语法格式**

```
UTL_SMTP.AUTH (
   c          IN OUT NOCOPY connection,
   username   IN            VARCHAR2,
   password   IN            VARCHAR2,
   schemes    IN            VARCHAR2 DEFAULT NON_CLEARTEXT_PASSWORD_SCHEMES);
```

**参数说明**

- c：open_connection返回的smtp连接。
- username：发送邮件的用户名
- password：发送邮件用户的密码
- schemas：身份验证方案，默认为CRAM-MD5

#### HELO函数<a id="helo"></a>

**语法格式**

```
UTL_SMTP.HELO (
   c       IN OUT NOCOPY   connection, 
   domain  IN              VARCHAR2);
```

**参数说明**

- c：open_connection返回的smtp连接。
- domain：发送邮件的域名或者主机地址。

#### MAIL函数<a id="mail"></a>

**语法格式**

```
UTL_SMTP.MAIL (
   c           IN OUT NOCOPY   connection, 
   sender      IN              VARCHAR2, 
   parameters  IN              VARCHAR2 DEFAULT NULL);
```

**参数说明**

- c：open_connection返回的smtp连接。
- sender：发送邮件的邮箱地址
- parameters：定义邮箱命令的附加参数，默认为NULL（接口预留，暂不实现）

#### RCPT函数<a id="rcpt"></a>

**语法格式**

```
UTL_SMTP.RCPT (
   c           IN OUT NOCOPY     connection,
   recipient   IN                VARCHAR2,
   parameters  IN                VARCHAR2 DEFAULT NULL);
```

**参数说明**

- c：open_connection返回的smtp连接。
- recipient：接收电子邮件的地址。
- parameters：定义邮箱命令的附加参数，默认为NULL（接口预留，暂不实现）。


#### OPEN_DATA函数<a id="open_data"></a>

**语法格式**

```
UTL_SMTP.OPEN_DATA (
   c     IN OUT NOCOPY connection);
```

**参数说明**

c：open_connection返回的smtp连接。

#### WRITE_DATA函数<a id="write_data"></a>


**语法格式**

```
UTL_SMTP.WRITE_DATA (
   c     IN OUT NOCOPY connection, 
   data  IN VARCHAR2 CHARACTER SET ANY_CS);
```

**参数说明**

- c：open_connection返回的smtp连接。
- data：要发送消息文本，包括标题，采用RFC822格式。

#### QUIT函数<a id="quit"></a>

**语法格式**

```
UTL_SMTP.QUIT (
   c  IN OUT NOCOPY connection);
```

**参数说明**

c：open_connection返回的smtp连接。

#### CLOSE_DATA函数<a id="close_data"></a>

**语法格式**

```
UTL_SMTP.CLOSE_DATA (
   c     IN OUT NOCOPY connection);
```

**参数说明**
c：open_connection返回的smtp连接。

### DBMS_APPLICATION_INFO

**功能描述**

DBMS_APPLICATION_INFO通过视图v\$SESSION来跟踪脚本运行情况的能力，该内置包允许应用程序在v$session上设置如下三个字段的值：

- client_info：客户端信息。
- Module：主程序名称，如包的名称。
- Action：程序包中的过程名。

以上三个字段的内容可以在视图V$SESSION中查看。该功能主要用于对各模块的性能跟踪和调试，系统管理员可按模块跟踪性能，还可以使用此信息来跟踪模块的资源使用情况。该内置包包含以下函数：

<table>
<tr>
<th>
函数
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
READ_CLIENT_INFO
</td>
<td>
读取当前会话通过SET_CLIENT_INFO过程的最后一个信息值，即最后一次存储的客户端信息
</td>
</tr>
<tr>
<td>
READ_MODULE
</td>
<td>
读取当前会话的模块和操作字段信息。
</td>
</tr>
<tr>
<td>
SET_ACTION
</td>
<td>
用于设置当前会话下的当前模块下的操作名称。
</td>
</tr>
<tr>
<td>
SET_CLIENT_INFO
</td>
<td>
用于设置当前会话有关客户端应用程序的其他信息。
</td>
</tr>
<tr>
<td>
SET_MODUL
</td>
<td>
用于设置当前模块的名称。
</td>
</tr>
</table>


**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：SET_SESSION_LONGOPS。


**示例**

1、创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';    
\c db_oracle
```

2、创建函数。

```
CREATE OR REPLACE FUNCTION test_dbms_application_info RETURNS  VOID AS 
$$
DECLARE
result1 text:='test';
v_module text;
v_action text;
BEGIN
    dbms_application_info.set_client_info('client A');
    select * into result1 from dbms_application_info.read_client_info();
    dbms_application_info.set_module('module A','action A');
    dbms_application_info.set_action('action B');
    select * into v_module,v_action from dbms_application_info.read_module();
    raise notice 'result_read_client_info is %',result1;
    raise notice 'result_read_module is % and %',v_module,v_action;
END;
$$
LANGUAGE plpgsql;
```

3、调用函数。

```
select test_dbms_application_info();
```

返回结果为：

```
NOTICE:  result_read_client_info is client A
CONTEXT:  referenced column: test_dbms_application_info
NOTICE:  result_read_module is module A and action B
CONTEXT:  referenced column: test_dbms_application_info
 test_dbms_application_info
----------------------------

(1 row)
```

###  DBMS_PROFILER

**功能描述**

DBMS_PROFILER提供了一个接口，用于分析现有的PL/pgSQL应用程序并确定性能瓶颈。该内置包可以收集性能分析数据，用来提高性能或确定PL/pgSQL应用程序的代码覆盖率。

应用程序开发人员可以使用代码覆盖率数据来集中精力进行增量测试。使用该内置包的接口，可以为在会话中执行的所有命名库单元（package body、function、procedure、trigger、anonymous block）生成分析信息。该信息包括执行每行的总次数、执行该行所花费的总时间以及该行的特定执行所花费的最短和最长时间。分析信息存储在数据库表中，可查询数据、构建自定义报告（摘要报告、最热的行、代码覆盖率数据等）以及分析数据。该内置包包含以下函数：

<table>
<tr>
<th>
函数
</td>
<th>
描述
</td>
</tr>
<tr>
<td>
START_PROFILER
</td>
<td>
在用户会话中启动事件探查器数据收集。启动一次数据收集就要START_PROFILER，中间可以暂停、继续、刷新数据。如果一直不STOP_PROFILER，收集器就一直在收集	plpgsql执行的性能数据；如果不执行START_PROFILER就执行STOP_PROFILER、	暂停、继续、刷新数据也不会出错，但没有实际数据收集。
</td>
</tr>
<tr>
<td>
STOP_PROFILER
</td>
<td>
停止用户会话中的探查器数据收集。此功能将会刷新会话中已收集的数据。
</td>
</tr>
<tr>
<td>
PAUSE_PROFILER
</td>
<td>
暂停用户会话中的探查器数据收集。
</td>
</tr>
<tr>
<td>
RESUME_PROFILER
</td>
<td>
恢复暂停状态中的探查器数据收集。
</td>
</tr>
<tr>
<td>
FLUSH_DATA
</td>
<td>
刷新在用户会话中收集的探查器数据。
</td>
</tr>
<tr>
<td>
ROLLUP_UNIT
</td>
<td>
计算对应runid和unit所花费的时间，并将总花费的时间刷新到PLSQL_PROFILER_UNITS表中的total_time字段中。
</td>
</tr>
<tr>
<td>
ROLLUP_RUN
</td>
<td>
统计指定runid收集器下所有unit所花费的时间，并将花费时间刷新到	PLSQL_PROFILER_UNITS表中的total_time字段中。
</td>
</tr>
</table>

**注意事项**

- 使用DBMS_PROFILER内置包前，需要先加载安装目录/share/postgresql目录下的proload.sql文件。加载命令如下（该步骤需要在目标库内部执行）：

```
\i ./local/vastbase/share/postgresql/proload.sql;
```

如果该命令执行报错，可以找到preload.sql文件手动执行preload.sql文件中命令创建收集器。收集器相关表说明如下：

<table>
<tr>
<th>
收集器相关表名
</td>
<th>
描述
</td>
</tr>
<tr>
<td>
plsql_profiler_runs
</td>
<td>
记录运行中的收集器信息。
</td>
</tr>
<tr>
<td>
plsql_profiler_units
</td>
<td>
有关运行中每个库单元的信息。
</td>
</tr>
<tr>
<td>
plsql_profiler_data
</td>
<td>
收集器收集的详细数据。
</td>
</tr>
<tr>
<td>
plsql_profiler_runnumber序列
</td>
<td>
生成唯一运行编号。
</td>
</tr>
</table>


- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

- 可以通过profiler.sql工具产生HTML格式的性能报表，具体使用方法见示例。

**兼容性**

完全兼容。

**示例**

1、创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';    
\c db_oracle
```

2、创建测试表。

```
create table tab_test(col int);
```

3、创建要统计PL/pgSQL性能的存储过程sp_test。

```
create or replace procedure sp_test
as
begin
for i in 1..100
loop
insert into tab_test values(1);
end loop;
end; 
/
```

4、创建要统计PL/pgSQL性能的存储过程sp_test2。

```
create or replace procedure sp_test2
as
begin
for i in 1..10000
loop
  insert into tab_test values(i);
end loop;
end;
/
```

5、统计sp_test的执行性能。

```
select dbms_profiler.start_profiler('sp');
```

6、调用存储过程sp_test,sp_test2

```
call sp_test();
select dbms_profiler.flush_data();
select dbms_profiler.pause_profiler();

call sp_test2();
select dbms_profiler.resume_profiler();
select dbms_profiler.stop_profiler();

select dbms_profiler.rollup_unit(1,1);
select dbms_profiler.rollup_run(1);
```

7、查询结果。

```
select * from plsql_profiler_runs;
```

返回结果为：

```
runid | related_run | run_owner |          run_date          | run_comment | run_total_time | run_system_info | run_comment1 | spare1 
-------+-------------+-----------+----------------------------+-------------+----------------+-----------------+--------------+--------
     1 |           0 | vastbase  | 2022-06-28 01:58:56.578502 | sp          |           6668 |                 |              | 
(1 row)

select * from plsql_profiler_units;
 runid | unit_number | unit_type | unit_owner | unit_name |       unit_timestamp       | total_time | spare1 | spare2 
-------+-------------+-----------+------------+-----------+----------------------------+------------+--------+--------
     1 |           1 | PROCEDURE | vastbase   | sp_test   | 2022-06-28 01:59:02.830512 |       3334 |        |       
(1 row)

select * from plsql_profiler_data;
 runid | unit_number | line# | total_occur | total_time | min_time | max_time | spare1 | spare2 | spare3 | spare4 
-------+-------------+-------+-------------+------------+----------+----------+--------+--------+--------+--------
     1 |           1 |     4 |           1 |       1730 |     1730 |     1730 |        |        |        |       
     1 |           1 |     6 |         100 |       1604 |        9 |       26 |        |        |        |       
(2 rows)
```





### DBMS_CRYPTO

**功能描述**

DBMS_CRYPTO是一个PL/SQL包，提供用于加密和解密存储的数据的接口，可以对常用的数据类型进行加密和解密，比如raw和大对象clob，blob类型。

- raw类型：存储二进制数据或位串。
- blob类型：存储二进制大对象数据（如数码照片）。
- clob类型：存储大对象单字节的字符数据（如大型文本）。
  该包包含以下函数：ENCRYPT、DECRYPT、HASH、MAC、RANDOMBYTES、RANDOMINTEGER、RANDOMNUMBER。

该内置包包含以下函数，其中ENCRYPT、DECRYPT函数均存在两个，下面描述时记作ENCRYPT函数1、ENCRYPT函数2、DECRYPT函数1、DECRYPT函数2。

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td> <a href="#ENCRYPT1">ENCRYPT函数1</a></td>
<td>使用用户指定的加密套件来对raw类型数据进行加密，返回raw类型数据。 </td> 
</tr>
<tr>
<td><a href="#ENCRYPT2">ENCRYPT函数2</a></td>
<td>使用用户指定的加密套件来对blob、clob类型数据进行加密，返回blob类型数据。 </td> 
 </tr>
<tr>
<td><a href="#DECRYPT1">DECRYPT函数1</a></td>
<td>使用用户指定的加密套件来对raw类型数据进行解密。 </td> 
 </tr>
<tr>
<td><a href="#DECRYPT2">DECRYPT函数2</a></td>
 <td>使用用户指定的加密套件来对blob类型数据进行解密。 </td> 
</tr>
<tr>
<td><a href="#HASH">HASH函数</a></td>
 <td>使用用户指定的hash算法来返回一个raw类型的哈希值，使用哈希值来验证数据是否已更改。算法标识符是hash_md5，整数码为2。 </td> 
</tr>
<tr>
 <td><a href="#MAC">MAC函数</a></td>
 <td>使用用户指定的MAC算法来返回一个bytea类型数据的MAC哈希值。算法标识符是hmac_md5，整数码为1。 </td> 
</tr>
<tr>
  <td><a href="#RANDOM_BYTES">RANDOMBYTES函数</a></td>
<td>生成指定长度（范围为[1, 2000]）的随机字节raw值。 </td> 
 </tr>
<tr>
 <td><a href="#RANDOM_INTEGER">RANDOMINTEGER函数</a></td>
<td>用于返回integer数据类型的完整范围内的随机整数。 </td> 
 </tr>
<tr>
 <td><a href="#RANDOM_NUMBER">RANDOMNUMBER函数</a></td>
<td> 用于返回number数据类型范围为[0, 2^128 - 1]内的随机数据。 </td> 
    </tr>
</table>



**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

- 使用DBMS_CRYPTO内置包前，需要先加载pgcrypto插件。执行如下命令加载插件：

```
CREATE EXTENSION pgcrypto;
```

- ENCRYPT函数和DECRYPT函数支持的加密套件组合码如下表：

| 加密套件标识符 | 整数码 |
| -------------- | ------ |
| encrypt_des    | 1      |
| encrypt_3des   | 3      |
| chain_ecb      | 768    |
| chain_cbc      | 256    |
| pad_pkcs       | 4096   |
| pad_none       | 8192   |
| des_cbc_pkcs   | 4353   |
| des3_cbc_pkcs  | 4355   |
| hash_md5       | 2      |
| hmac_md5       | 1      |

-  使用加密函数时不能使用标识符名称，必须使用对应的整数码。
-  对于加密套件标识符相加的情况，只需要将其整数码数值相加即可。

例如

```
select dbms_crypto.decrypt('57E647BDA301C9FA'::raw,dbms_crypto.des_cbc_pkcs, '123456'::raw);
```

其中4353名称需要换成4353

```
select dbms_crypto.decrypt('57E647BDA301C9FA'::raw, 4353, '123456'::raw);
```

- **兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：SING、VERIFY、PKDECRYPT、PKENCRYPT。

#### ENCRYPT函数1 <a id="ENCRYPT1"></a>

**语法格式**

```
DBMS_CRYPTO.ENCRYPT(
   src IN RAW,
   typ IN PLS_INTEGER,
   key IN RAW,
   iv  IN RAW          DEFAULT NULL)
 RETURN RAW;
```

**参数说明**

- src：要破解的RAW数据。
- typ：加密类型。
- key：解密使用的key。
- iv：块密码初始化向量，缺省NULL。

**示例**

- 直接调用。

```
select dbms_crypto.encrypt('ABCABC'::raw, 4353, '123456'::raw);
     encrypt      
------------------
 57E647BDA301C9FA
(1 row)

select dbms_crypto.decrypt('57E647BDA301C9FA'::raw, 4353, '123456'::raw);
 decrypt 
---------
 ABCABC
(1 row)
```

- 加密表数据

1、创建测试表并插入数据。

```
create table t_select_raw(id int, col varchar2(20));
insert into t_select_raw values(1,'测试');
insert into t_select_raw values(2,'中文');

create table t_dml_raw(id int, col raw);
insert into t_dml_raw values(1,'1234AABBCCDDEEFF');
```

2、查询结果加密。

```
select dbms_crypto.encrypt(hextoraw(encode(col::bytea, 'hex')), 4353, '123456'::raw) from t_select_raw;

     encrypt      
------------------
 6C5B52D18B146E13
 B01C554C5102A8FE
(2 rows)

select dbms_crypto.encrypt(hextoraw(encode(col::bytea, 'hex')), 4353, hextoraw(encode(col::bytea, 'hex'))) from t_select_raw;
     encrypt      
------------------
 9A5296006CB243A3
 3D172C9ECA9B4A43
(2 rows)

select dbms_crypto.encrypt(hextoraw(encode(col::bytea, 'hex')), 4353, hextoraw(encode(col::bytea, 'hex')),  hextoraw(encode(col::bytea, 'hex'))) from t_select_raw;
     encrypt      
------------------
 58AEFBB87999E13C
 CE070EDF29322C9F
(2 rows)
```

3、查询raw数据

```
select dbms_crypto.encrypt(col, 4353, col,col) from t_dml_raw;
            encrypt              
----------------------------------
 8475EECF02BEE7E870B363D667785B6E
(1 row)
```

4、插入数据加密。

```
insert into t_dml_raw values(2, dbms_crypto.encrypt(hextoraw(encode('中文'::bytea, 'hex')), 4353, '1'::raw));

insert into t_dml_raw values(2, dbms_crypto.encrypt(hextoraw(encode('abc'::bytea, 'hex')), 4353, hextoraw(encode('2'::bytea, 'hex')), hextoraw(encode('2'::bytea, 'hex'))));

update t_dml_raw set col = dbms_crypto.encrypt(hextoraw(encode('测试'::bytea, 'hex')), 4353, '1'::raw) where id = 1;
select * from t_dml_raw;
```

5、显示加密后的结果。

```
select * from t_dml_raw;
 id |       col        
----+------------------
  2 | 634FE089F003C8AA
  2 | 10759AD6661DD7BC
  1 | 350968ECE5EBF882
(3 rows)
```

#### ENCRYPT函数2 <a id="ENCRYPT2"></a>

**语法格式**

```
DBMS_CRYPTO.ENCRYPT(
   dst IN OUT NOCOPY BLOB,
   src IN            BLOB,
   typ IN            PLS_INTEGER,
   key IN            RAW,
   iv  IN            RAW          DEFAULT NULL);

DBMS_CRYPTO.ENCRYPT(
   dst IN OUT NOCOPY BLOB,
   src IN            CLOB         CHARACTER SET ANY_CS,
   typ IN            PLS_INTEGER,
   key IN            RAW,
   iv  IN            RAW          DEFAULT NULL);
```

**参数说明**

- dst：解密数据的输出位置。
- src：要破解的LOB数据。
- typ：加密类型。
- key：解密使用的key。
- iv：块密码初始化向量，缺省NULL。

**示例**

- 对blob类型数据进行加密-直接调用。

```
select dbms_crypto.encrypt('abc'::blob,'ABCABC'::blob,4353, '123456'::raw);
     encrypt      
------------------
 57E647BDA301C9FA
(1 row)
```

- 对clob类型数据进行加密-直接调用。

```
select dbms_crypto.encrypt('abc'::blob,'ABCABC'::clob,4353, '123456'::raw);
     encrypt      
------------------
 D552672EE9151C95
(1 row)
```

#### DECRYPT函数1<a id="DECRYPT1"></a>

**语法格式**

```
DBMS_CRYPTO.DECRYPT(
   src IN RAW,
   typ IN PLS_INTEGER,
   key IN RAW,
   iv  IN RAW DEFAULT NULL)
 RETURN RAW;
```

**参数说明**

- src：要破解的RAW数据。
- typ：加密类型。
- key：解密使用的key。
- iv：块密码初始化向量，缺省NULL。

**示例**

1、对raw类型数据进行加密,使用相同的方式进行解密-直接调用(获取加密结果)。

```
select dbms_crypto.encrypt('ABCABC'::raw, 4353, '123456'::raw);
```

返回结果为：

```
     encrypt      
------------------
 57E647BDA301C9FA
(1 row)
```

2、将加密结果使用相同的方式进行解密(此处需要使用上一步加密结果数据来替换命令中的加密结果)。

```
select dbms_crypto.decrypt('加密后的结果'::raw, 4353, '123456'::raw);
decrypt 
---------
 ABCABC
(1 row)
```

#### DECRYPT函数2<a id="DECRYPT2"></a>

**语法格式**

```
DBMS_CRYPTO.DECRYPT(
   dst IN OUT NOCOPY BLOB,
   src IN            BLOB,
   typ IN            PLS_INTEGER,
   key IN            RAW,
   iv  IN            RAW          DEFAULT NULL);

DBMS_CRYPT.DECRYPT(
   dst IN OUT NOCOPY CLOB         CHARACTER SET ANY_CS,
   src IN            BLOB,
   typ IN            PLS_INTEGER,
   key IN            RAW,
   iv  IN            RAW          DEFAULT NULL);
```

**参数说明**

- dst：解密数据的输出位置。
- src：要破解的LOB数据。
- typ：加密类型。
- key：解密使用的key。
- iv：块密码初始化向量，缺省NULL。

**示例**

1、对blob类型数据进行解密-直接调用

```
select dbms_crypto.decrypt('abc'::blob,'D552672EE9151C95'::blob,4353, '123456'::raw);
   decrypt    
--------------
 414243414243
(1 row)
```

2、对blob类型数据进行加密,使用相同的方式进行解密-直接调用(获取加密结果)。

```
select dbms_crypto.encrypt('abc'::blob,'ABCABC'::blob,4353, '123456'::raw);
     encrypt      
------------------
 57E647BDA301C9FA
(1 row)
```

3、将加密结果使用相同的方式进行解密(此处需要使用上一步加密结果数据来替换命令中的加密结果)。

```
select dbms_crypto.decrypt('abc'::blob,'加密后的结果'::blob, 4353, '123456'::raw);
 decrypt 
---------
 ABCABC
(1 row)
```

#### HASH函数<a id="HASH"></a>

**语法格式**

```
DBMS_CRYPTO.Hash (
   src IN RAW,
   typ IN PLS_INTEGER)
 RETURN RAW;

DBMS_CRYPTO.Hash (
   src IN BLOB,
   typ IN PLS_INTEGER)
 RETURN RAW;

DBMS_CRYPTO.Hash (
   src IN CLOB CHARACTER SET ANY_CS,
   typ IN PLS_INTEGER)
 RETURN RAW;
```

**参数说明**

- src：要计算的原始数据。
- typ：哈希算法类型。

**示例**

```
select dbms_crypto.hash('57E647BDA301C9FA'::blob, 2);
               hash               
----------------------------------
 0625EE8F90EE27BEA4AD2EC9017E5A2E
(1 row)

select dbms_crypto.hash('中文测试'::clob, 2);
               hash               
----------------------------------
 089B4943EA034ACFA445D050C7913E55
(1 row)
```

#### MAC函数<a id="MAC"></a>

**语法格式**

```
DBMS_CRYPTO.MAC (
   src IN RAW,
   typ IN PLS_INTEGER,
   key IN RAW)
 RETURN RAW;

DBMS_CRYPTO.MAC (
   src IN BLOB,
   typ IN PLS_INTEGER
   key IN RAW)
 RETURN RAW;

DBMS_CRYPTO.MAC (
   src IN CLOB CHARACTER SET ANY_CS,
   typ IN PLS_INTEGER
   key IN RAW)
 RETURN RAW;
```

**参数说明**

- src：要计算的原始数据。
- typ：MAC算法类型。
- MAC：MAC算法的key值。

**示例**

```
select dbms_crypto.mac('57E647BDA301C9FA'::blob, 1, '123456ABC'::raw);
              mac                
----------------------------------
 6AB6390193F2DCA79E2CDC22047B2EA8
(1 row)

select dbms_crypto.mac('中文测试'::clob, 1, '123456ABC'::raw);
              mac                
----------------------------------
 2CDC70BD0B266731AEE027C185E77D68
(1 row)
```

#### RANDOM_BYTES函数<a id="RANDOMBYTES"></a>

**语法格式**

```
DBMS_CRYPTO.RANDOM_BYTES(
   number_bytes IN POSITIVE)
 RETURN RAW;
```

**参数说明**

number_bytes：要生成的随机字节数。

**示例**

```
select dbms_crypto.RANDOM_BYTES(10) from dual;

  RANDOM_BYTES     
----------------------
 073B14CADD7E284F2417
(1 row)

```

####  RANDOM_INTEGER函数<a id="RANDOMINTEGER"></a>

**语法格式**

```
DBMS_CRYPTO.RANDOM_INTEGER
 RETURN BINARY_INTEGER;
```

**示例**

```
select dbms_crypto.random_integer() from dual;

 random_integer 
---------------
    -909240370
(1 row)
```

####  RANDOM_NUMBER函数<a id="RANDOMNUMBER"></a>

**语法格式**

```
DBMS_CRYPTO.RANDOM_NUMBER
 RETURN NUMBER;
```

**示例**

```
select dbms_crypto.random_number() from dual;

         random_number          
-------------------------------
 11351894157074763785441053451
(1 row)
```


### DBMS_LOCK

**功能描述**
DBMS_LOCK包可以对数据库锁进行管理和控制。

比如某些开发程序，在高并发的情况下，必须控制好并发请求的运行时间和次序，
来保证处理数据的正确性和完整性。对于这种业务需求，可以使用内置包DBMS_LOCK，把需要做并发控制的参数加上锁，实现并发控制。
dbms_lock包提供了多种锁模式，各个模式都有自己的冲突列表，各个锁模式的含义及取值如下表：

<table>
<tr>
<th>名字</th>
<th>描述</th>
<th>值</th>
</tr>
<tr>
<td>nl_mode</td>
<td>NULL</td>
<td>1</td>
</tr>
<tr>
<td>ss_mode</td>
<td>Sub Shared，表示在一个对象的子部分获取共享锁</td>
<td>2</td>
</tr>
<tr>
<td>sx_mode</td>
<td>Sub Exclusive，表示在一个对象的子部分获取独占锁</td>
<td>3</td>
</tr>
<tr>
<td>s_mode</td>
<td>Shared，表示对整个对象获取共享锁</td>
<td>4</td>
<tr>
<td>ssx_mode</td>
<td>Shared Sub Exclusive，表示整个对象已有共享锁，但是还要对某些子部分获取独占锁</td>
<td>5</td>
<tr>
<td>x_mode</td>
<td>Exclusive，表示对整个对象获取独占锁</td>
<td>6</td>
</tr>
</table>


当要获取一个对象的锁时，如果这个对象的锁正被其他会话所持有，那么需要根据该对象的锁正被持有的模式以及当前要获取的锁的模式来判断本次是否能够成功获取，这就是不同锁模式的冲突。不同锁模式的冲突列表如下：

<table>
<tr>
<th>HELD MODE</th>
<th>GET NL</th>
<th>GET SS</th>
<th>GET SX</th>
<th>GET S</th>
<th>GET SSX</th>
<th>GET X</th>
</tr>
<tr>
<td>NL</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
</tr>
<tr>
<td>SS</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Failed</td>
</tr>
<tr>
<td>SX</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Success</td>
<td>Failed</td>
<td>Failed</td>
</tr>
<tr>
<td>S</td>
<td>Success</td>
<td>Success</td>
<td>Failed</td>
<td>Success</td>
<td>Failed</td>
<td>Failed</td>
</tr>
<tr>
<td>SSX</td>
<td>Success</td>
<td>Success</td>
<td>Failed</td>
<td>Failed</td>
<td>Failed</td>
<td>Failed</td>
</tr>
<tr>
<td>X</td>
<td>Success</td>
<td>Failed</td>
<td>Failed</td>
<td>Failed</td>
<td>Failed</td>
<td>Failed</td>
</tr>
</table>

该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
 <td><a href="#ALLOCATE_UNIQUE">ALLOCATE_UNIQUE</a></td>
<td>为指定的锁名分配一个唯一的锁id。</td>
</tr>
<tr>
<td><a href="#CONVERT">CONVERT</a></td>
<td>锁模式的转换。</td>
</tr>
<tr>
<td><a href="#REQUEST">REQUEST</a></td>
<td>请求一个指定模式的锁。</td>
</tr>
<tr>
<td><a href="#RELEASE">RELEASE</a></td>
<td>用来显示释放由REQUEST函数占有的锁。</td>
</tr>
<tr>
<td><a href="#SLEEP">SLEEP</a></td>
<td>指定session睡眠时间。</td>
</tr>
</table>




**注意事项**

无。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有:ALLOCATE_UNIQUE_AUTONOMOUS

**示例**

1、创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE testoracle dbcompatibility='A';    
\c db_oracle
```

2、创建函数并发控制锁模式nl_mode与sx_mode。

```
create or replace function lock_test(lock_mode int ,lock_expired int ,release_on_commit boolean) returns int as $$ --lock_mode取1到6整数
declare
v_ret int;
v_name varchar(100) :='test';
v_handle varchar(100);
begin
dbms_output.enable();
dbms_output.serveroutput(true);
dbms_output.put_line('----- session start -----');
select dbms_lock.allocate_unique(v_name,lock_expired) into v_handle;
v_ret :=dbms_lock.request(v_handle , lock_mode , lock_expired , release_on_commit); 
if v_ret <> 0 then
--获取锁失败
dbms_output.put_line('---lock request lock failed ---');
return v_ret;
else
dbms_output.put_line('---now request lock success ---');
end if;
--获取锁成功，此处添加请求业务逻辑
dbms_lock.sleep(lock_expired+20);
--执行完成，应该要释放掉锁
if v_ret = 0 then
v_ret := dbms_lock.release(v_handle);
end if;
return v_ret;
end;
$$ language plpgsql;
```

3、会话1中执行 CALL lock_test(1,2,false)，切换至会话2同时执行CALL lock_test(3,20,false)。

```
 CALL lock_test(1,2,false);
 CALL  lock_test(3,20,false);
```

会话1和会话2可以同时获得锁，同时出现如下执行结果：

```
----- session start -----
---now request lock success ---
 lock_test
-----------
         0
(1 row)

```

4、会话1执行 CALL  lock_test(1,2,true),切换至会话2同时执行CALL lock_test(3,20,true);

```
CALL  lock_test(1,2,true);
CALL lock_test(3,20,true);
```

会话1和会话2可以同时获得锁，同时出现如下执行结果：

```
----- session start -----
---now request lock success ---
 lock_test
-----------
         0
(1 row)

```

#### ALLOCATE_UNIQUE<a id="ALLPCATE_UNIQUE"></a>

**语法格式**

```
dbms_lock.allocate_unique(
    lockname IN VARCHAR2,
    lockhandle OUT VARCHAR2,
    expiration_secs IN INTEGER DEFAULT 864000
) RETURN INTEGER;
```

**参数说明**

- lockname：产生唯一的LockID。大小不超过128B，大小写敏感。不能以'ORA$'开头，这是为oracle提供的产品保留的。
- lockhandle：返回值，request，convert，release调用。
- expiration_secs：执行'allocate_unique'后，Clean Up的时间间隔。

#### CONVERT<a id="CONVERT"></a>

**语法格式**

```
dbms_lock.convert(
    lockhandle IN VARCHAR2,
    lockmode IN INTEGER,
    timeout IN NUMBER DEFAULT maxwait
) RETURN INTEGER;
```

**参数说明**

- lockname：生成的唯一ID的锁的名称。
- lockhandle：
- expiration_secs：

#### RELEASE<a id="RELEASE"></a>

**语法格式**

```
dbms_lock.release(
    lockhandle IN VARCHAR2
) RETURN INTEGER;

dbms_lock.release(
    id         IN INTEGER
) RETURN INTEGER;
```

**参数说明**

lockhandle，id：用户分配的锁定标识符。


#### REQUEST<a id="REQUEST"></a>

**语法格式**

```
dbms_lock.request(
    lockhandle IN VARCHAR2,
    lockmode IN INTEGER DEFAULT x_mode,
    timeout IN INTEGER DEFAULT maxwait,
    release_on_commit IN BOOLEAN DEFAULT FALSE
) RETURN INTEGER;
```

**参数说明**

- lockhandle，id：用户分配的锁定标识符，allocate_unique取得的handle。
- lockmode：请求的锁的模式。
- timeout：继续尝试授予锁定的秒数，如果在此时间段内无法授予锁，则调用返回值 1 ( timeout)。
- release_on_commit：将此参数设置为TRUE以释放提交或回滚时的锁定。否则，锁会一直持有，直到它被显式释放或会话结束。默认为FALSE。

#### SLEEP<a id="SLEEP"></a>

**语法格式**

```
dbms_lock.sleep(
    seconds IN NUMBER
);
```

**参数说明**

seconds：睡眠时间。

### DBMS_OBFUSCATION_TOOLKIT

**功能描述**

DBMS_OBFUSCATION_TOOLKIT提供用于加密和解密存储的数据的接口，可以对数据进行DES、Triple DES或者MD5加密。该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td><a href="#TOOKDESENCRYPT">DESENCRYPT</a></td>
<td>
用于使用DES算法对输入数据进行加密，并生成加密格式的数据。
</td>
</tr>
<tr>
<td> <a href="#TOOKDESDECRYPT">DESDECRYPT</a></td>
<td>
用于对使用DES算法所生成的加密数据进行解密。
</td>
</tr>
<tr>
<td> <a href="#TOOKDESGETKEY"> DESGETKEY</a></td>
<td>
生成一个随机字符串，并对其使用DES算法生成一个加密密钥。
</td>
</tr>
<tr>
<td><a href="#TOOKDES3ENCRYPT"> DES3ENCRYPT</a></td>
<td>
用于使用DES3算法对输入数据进行加密，并生成加密格式的数据。
</td>
</tr>
<tr>
    <td><a href="#TOOKDES3DECRYPT">DES3DECRYPT</a></td>
<td>
用于对使用DES3算法所生成的加密数据进行解密。
</td>
</tr>
<tr>
    <td><a href="#TOOKDES3GETKEY"> DES3GETKEY</a></td>
<td>
生成一个随机字符串，并对其使用DES3算法生成一个加密密钥。
</td>
</tr>
<tr>
    <td><a href="#TOOKMD5">MD5</a></td>
<td>
用于使用md5算法生成密码校验码。
</td>
</tr>
</table>


**注意事项**

- 使用DBMS_OBFUSCATION_TOOLKIT内置包前，需要先加载pgcrypto插件。

```
CREATE EXTENSION pgcrypto;
```

-  该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

完全兼容。


#### DESENCRYPT<a id="TOOKDESENCRYPT"></a>

**语法格式**

```
DBMS_OBFUSCATION_TOOLKIT.DESEncrypt(
   input            IN    RAW,
   key              IN    RAW,
   encrypted_data   OUT   RAW);

DBMS_OBFUSCATION_TOOLKIT.DESEncrypt(
   input_string     IN    VARCHAR2,
   key_string       IN    VARCHAR2,
   encrypted_string OUT   VARCHAR2);

DBMS_OBFUSCATION_TOOLKIT.DESEncrypt(
   input         IN  RAW,
   key           IN  RAW)
  RETURN RAW;

DBMS_OBFUSCATION_TOOLKIT.DESEncrypt(
   input_string  IN  VARCHAR2,
   key_string    IN  VARCHAR2)
  RETURN VARCHAR2;
```

**参数说明**

- input：要加密的数据。
- key：加密密钥。
- encrypted_data：加密数据。
- input_string：要加密的字符串。
- key_string：加密密钥字符串。
- encrypted_string：加密字符串。

**示例**

- 对raw类型进行加密。

```
select dbms_obfuscation_toolkit.desencrypt('ABCDEFEF'::raw,'12345678'::raw);
```

返回结果为：

```
    desencrypt        
--------------------------
5837505A4D3578332F44383D
(1 row)
```

- 对text类型进行加密。

```
select dbms_obfuscation_toolkit.desencrypt('ABCDEFGH'::text,'12345678'::text);
```

返回结果为：

```
    desencrypt        
--------------------------
lt5gPq7WJW/hywLARpfLNA==
(1 row)
```

- 对中文进行加密。

```
select dbms_obfuscation_toolkit.desencrypt('中文中文中文中文'::text,'测试'::text);
```

返回结果为：

```
              desencrypt                  
----------------------------------------------
uJ0LFYdRFGzJdmhYnaG9XXKrM4wcJMz6ncu4SV204yM=
(1 row)
```

#### DESDECRYPT<a id="TOOKDESDECRYPT"></a>

**语法格式**

```
DBMS_OBFUSCATION_TOOLKIT.DESDecrypt(
   input             IN   RAW,
   key               IN   RAW,
   decrypted_data    OUT  RAW);

DBMS_OBFUSCATION_TOOLKIT.DESDecrypt(
   input_string      IN   VARCHAR2,
   key_string        IN   VARCHAR2,
   decrypted_string  OUT  VARCHAR2);

DBMS_OBFUSCATION_TOOLKIT.DESDecrypt(
   input            IN  RAW,
   key              IN  RAW)
  RETURN RAW;

DBMS_OBFUSCATION_TOOLKIT.DESDecrypt(
   input_string     IN  VARCHAR2,
   key_string       IN  VARCHAR2)
  RETURN VARCHAR2;
```

**参数说明**

- input：要加密的数据。
- key：加密密钥。
- decrypted_data：加密数据。
- input_string：要加密的字符串。
- key_string：加密密钥字符串。
- decrypted_string：加密字符串。

**示例**

- 对raw类型进行解密

```
select dbms_obfuscation_toolkit.desdecrypt(dbms_obfuscation_toolkit.desencrypt('ABCDEFEF'::raw,'12345678'::raw),'12345678'::raw);
```

返回结果为：

```
desdecrypt 
------------
ABCDEFEF
(1 row)
```

- 对text类型进行解密

```
select dbms_obfuscation_toolkit.desdecrypt(dbms_obfuscation_toolkit.desencrypt('ABCDEFGH'::text,'12345678'::text) ,'12345678'::text);
```

返回结果为：

```
desdecrypt 
------------
ABCDEFGH
(1 row)
```

#### DESGETKEY<a id="TOOKDESGETKEY"></a>

**语法格式**

```
DBMS_OBFUSCATION_TOOLKIT.DESGetKey(
   seed         IN   RAW,
   key          OUT  RAW);

DBMS_OBFUSCATION_TOOLKIT.DESGetKey(
   seed_string  IN   VARCHAR2,
   key          OUT  VARCHAR2);

DBMS_OBFUSCATION_TOOLKIT.DESGetKey(
   seed IN RAW)
 RETURN RAW;

DBMS_OBFUSCATION_TOOLKIT.DESGetKey(
   seed_string IN VARCHAR2)
 RETURN VARCHAR2;
```

**参数说明**

- seed：长度至少未80个字符的值。
- key：加密密钥。
- key_string：加密密钥字符串。

**示例**

- 用des算法随机生成加密密钥。

```
select dbms_obfuscation_toolkit.desgetkey('sucesss');
```

返回结果为：

```
desgetkey 
-----------
yxvntnex
(1 row)
```

- 用des算法随机生成text类型的加密密钥。

```
select dbms_obfuscation_toolkit.desgetkey('sucesss'::text);
```

返回结果为：

```
desgetkey 
-----------
zmuewwki
(1 row)
```

- 用des算法随机生成raw类型的加密密钥。

```
select dbms_obfuscation_toolkit.desgetkey('ABCDEFEF'::raw);
```

返回结果为：

```
desgetkey     
------------------
6F746E7073696F71
(1 row)
```

#### DES3ENCRYPT<a id="TOOKDES3ENCRYPT"></a>

**语法格式**

```
DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(
   input           IN     RAW,
   key             IN     RAW,
   encrypted_data  OUT    RAW,
   which           IN     PLS_INTEGER  DEFAULT TwoKeyMode
   iv              IN     RAW          DEFAULT NULL);

DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(
   input_string      IN     VARCHAR2,
   key_string        IN     VARCHAR2,
   encrypted_string  OUT    VARCHAR2,
   which             IN     PLS_INTEGER  DEFAULT TwoKeyMode
   iv_string         IN     VARCHAR2     DEFAULT NULL);

DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(
   input        IN RAW,
   key          IN RAW,
   which        IN PLS_INTEGER DEFAULT TwoKeyMode
   iv           IN RAW         DEFAULT NULL)
  RETURN RAW;

DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(
   input_string  IN VARCHAR2,
   key_string    IN VARCHAR2,
   which         IN PLS_INTEGER DEFAULT TwoKeyMode
   iv_string     IN VARCHAR2    DEFAULT NULL)
  RETURN VARCHAR2;
```

**参数说明**

- input：要加密的数据。
- key：加密密钥。
- encrypted_data：加密数据。
- which：如果 = 0，（默认），则TwoKeyMode使用。如果 = 1，则ThreeKeyMode使用。
- iv：初始化向量。
- input_string：要加密的字符串。
- key_string：加密密钥字符串。
- encrypted_string：加密字符串。
- iv_string：初始化向量。

**示例**

- 对text类型数据加密，密钥长度大于等于16。

```
select dbms_obfuscation_toolkit.des3encrypt('ABCDEFEF'::text,'ABCABCABCABCABCA'::text);
```

返回结果为：

```
       des3encrypt
--------------------------
 K9pRtTB3V7mVThiNt+zYmg==
(1 row)
```

#### DES3GETKEY<a id="TOOKDES3GETKEY"></a>

**语法格式**

```
DBMS_OBFUSCATION_TOOLKIT.DES3GetKey(
   which        IN   PLS_INTEGER DEFAULT TwoKeyMode,
   seed         IN   RAW,
   key          OUT  RAW);

DBMS_OBFUSCATION_TOOLKIT.DES3GetKey(
   which        IN   PLS_INTEGER DEFAULT TwoKeyMode,
   seed_string  IN   VARCHAR2,
   key          OUT  VARCHAR2);

DBMS_OBFUSCATION_TOOLKIT.DES3GetKey(
   which  IN  PLS_INTEGER DEFAULT TwoKeyMode,
   seed   IN  RAW)
 RETURN RAW;

DBMS_OBFUSCATION_TOOLKIT.DES3GetKey(
   which        IN  PLS_INTEGER DEFAULT TwoKeyMode,
   seed_string  IN  VARCHAR2)
 RETURN VARCHAR2;
```

**参数说明**

- which：如果 = 0，（默认），则TwoKeyMode使用。如果 = 1，则ThreeKeyMode使用。
- seed：长度至少为80个字符的值。
- key：加密密钥。
- seed_string：长度至少为80个字符的字符串。

**示例**

- 对text类型数据加密，加密数据字符长度大于等于80个。

```
select dbms_obfuscation_toolkit.des3getkey(0,'ABCDEFEFABCDEFEFABCDEFEFABCDEFEFABCDEFEFABCDEFEFABCDEFEFABCDEFEFABCDEFEFABCDEFFF'::text);
```

返回结果为：

```
    des3getkey
------------------
 soQKaLCAvdTZXPxJ
(1 row)
```

- 对raw类型数据加密，加密数据字符长度小于80个

```
select dbms_obfuscation_toolkit.des3getkey('ABCDEFEF'::raw);
```

返回结果为：

```
            des3getkey
----------------------------------
 69736F6E6662706D7661716768796374
(1 row)
```

#### MD5<a id="TOOKMD5"></a>

**语法格式**

```
DBMS_OBFUSCATION_TOOLKIT.MD5(
   input            IN   RAW,
   checksum         OUT  raw_checksum);

DBMS_OBFUSCATION_TOOLKIT.MD5(
   input_string     IN   VARCHAR2,
   checksum_string  OUT  varchar2_checksum);

DBMS_OBFUSCATION_TOOLKIT.MD5(
   input         IN  RAW)
  RETURN raw_checksum;

DBMS_OBFUSCATION_TOOLKIT.MD5(
   input_string  IN  VARCHAR2)
  RETURN varchar2_checksum;
```

**参数说明**

- input：要生成校验码的数据。
- checksum：128位加密信息摘要。
- input_string：要生成校验码的字符串。
- checksum_string：128位加密信息摘要。

**示例**

- 用md5算法随机生成raw类型密码校验码。

```
select dbms_obfuscation_toolkit.md5('ABCDEFEF'::raw);
```

返回结果为：

```
            md5                
----------------------------------
42BE4B48002C72898ADEDCBA9C6370F6
(1 row)
```

- 用md5算法随机生成text类型密码校验码。

```
select dbms_obfuscation_toolkit.md5('ABCDEFEF'::text);
```

返回结果为：

```
  md5      
---------------
\x18Mr_\x10s"
(1 row)
```


### UTL_RAW

**功能描述**

UTL_RAW包提供了一系列对raw类型数据进行处理的函数。

**函数说明**

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td>cast_to_raw</td>
<td>
将输入的varchar2类型的数据转换成raw类型的数据，在此过程中数据并未以任何方式修改，仅仅只是修改了数据类型。
</td>
</tr>
<tr>
<td>cast_to_varchar2</td>
<td>
将输入的raw类型数据转换回varchar2类型。
</td>
</tr>
</table>




**注意事项**

cast_to_varchar2函数的输入字符须为十六进制表示形式的16个字符，否则会返回识别错误。

**示例**

- **cast_to_raw函数**

示例一：

```
select utl_raw.cast_to_raw('test') from dual;
```

返回结果为'test'字符串每个字符的ASCII码的十六进制表示形式拼接而成，结果如下：

```
cast_to_raw
-----------
74657374
(1 row)
```

示例二：

```
select utl_raw.cast_to_raw('测试') from dual;
```

 返回结果为'测试'在utf8编码下中文转换成十六进制的表现形式，如下所示：

```
cast_to_raw
-----------
E6B58BE8AF95
(1 row)
```


- **cast_to_varchar2函数**

示例一：

```
select utl_raw.cast_to_varchar2('74657374') from dual;
```

返回结果为:

```
cast_to_varchar2
----------------
test
(1 row)
```

示例二：

```
select utl_raw.cast_to_varchar2('E6B58BE8AF95') from dual;
```

返回结果为:

```
cast_to_varchar2
----------------
测试
(1 row)
```

注意：cast_to_varchar2函数的输入字符须为十六进制表示形式的16个字符，否则会返回识别错误。

```
select utl_raw.cast_to_varchar2('test') from dual;
ERROR: invalid hexadecimal digit: "t"
LINE 1: select utl_raw.cast_to_varchar2('test') from dual;
∧
CONTEXT: 	referenced column: cast_to_varchar2
```

### DBMS_UTILITY

**功能描述**

DBMS_UTILITY包提供了很多不同的子程序工具。该内置包包含以下函数：

<table >
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
    <td><a href="#UTLCOMMA_TO_TABLE">COMMA_TO_TABLE</a> </td>
<td>用于将逗号间隔的字符串转化成数组类型。</td>
</tr>
<tr>
    <td><a href="#UTLTABLE_TO_COMMA">TABLE_TO_COMMA</a> </td>
<td>用于将数组类型转换成逗号间隔的字符串。</td>
</tr>
<tr>
    <td><a href="#UTLEXEC_DDL_STATEMENT">EXEC_DDL_STATEMENT</a></td>
<td>用于执行DDL语句。</td>
</tr>
<tr>
<td><a href="#UTLFORMAT_CALL_STACK">FORMAT_CALL_STACK</a></td>
<td>用于格式化调用堆栈。该内置函数返回一个格式化的字符串，它显示了执行调用堆栈直至当前函数调用处的所有过程或者函数的调用顺序。该函数可在存储过程、函数或包中调用，并且以可读格式返回当前调用堆栈。</td>
</tr>
<tr>
    <td><a href="#UTLGET_HASH_VALUE">GET_HASH_VALUE</a>  </td>
<td>用于获得在该范围内字符串的hash值。</td>
</tr>
<tr>
    <td><a href="#UTLGET_TIME">GET_TIME</a> </td>
<td>用于记录当前时刻的时间（单位是百分之一秒）。</td>
</tr>
</table>

**注意事项**

LNAME_ARRAY、UNCL_ARRAY、NAME_ARRAY类型用于配合函数comma_to_table、table_to_comma的出入参。它们对应的类型分别为：

- LANAME_ARRY：由bigint作为索引的varchar（4000）[]或者varchar2（4000）[]的数组。
- NAME_ARRY：由bigint作为索引的varchar（30）[]或者varchar2（30）[]的数组。
- UNCL_ARRY：由bigint作为索引的varchar（227）[]或者varchar2（227）[]的数组。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：CANONICALIZE、COMPILE_SCHEMA、CREATE_ALTER_TYPE_ERROR_TABLE、CURRENT_INSTANCE Function、DATA_BLOCK_ADDRESS_BLOCK、DATA_BLOCK_ADDRESS_FILE、DB_VERSION、EXPAND_SQL_TEXT、FORMAT_ERROR_BACKTRACE、FORMAT_ERROR_STACK、GET_CPU_TIME、GET_DEPENDENCY、GET_ENDIANNESS、GET_DEPENDENCY、GET_PARAMETER_VALUE、GET_SQL_HASH、GET_TZ_TRANSITIONS、INVALIDATE、IS_BIT_SET、IS_CLUSTER_DATABASE、MAKE_DATA_BLOCK_ADDRESS、NAME_RESOLVE、NAME_TOKENIZE、OLD_CURRENT_SCHEMA、OLD_CURRENT_USER、PORT_STRING、SQLID_TO_SQLHASH、VALIDATE、WAIT_ON_PENDING_DML。

**示例**

- 创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE testoracle dbcompatibility='A';    
\c db_oracle
```

- format_call_stack函数exec_ddl_statement函数

```
CREATE OR REPLACE FUNCTION checkHexCallStack() returns text 
as $$
DECLARE
stack text;
BEGIN
select * INTO stack from dbms_utility.format_call_stack('o');
return stack;
END;
$$ LANGUAGE plpgsql;
begin
Dbms_utility.exec_ddl_statement('create table test_eds(col int);');
end;
/
```

查询test_eds表，返回结果如下，则表示函数调用成功：

```
\dti test_eds
                                       List of relations
 Schema |   Name   | Type  |  Owner   | Table |                    Storage
--------+----------+-------+----------+-------+------------------------------------------------
 public | test_eds | table | vastbase |       | {orientation=row,compression=no,fillfactor=80}
(1 row)


```

- table_to_comma函数和comma_to_table函数
- 设置serveroutput为true。

```
select dbms_output.serveroutput(true);
```

- 使用存储过程调用函数。

```
declare
t_vararray dbms_utility.lname_array;
vc_stringlist varchar2(4000);
n_idx binary_integer;
begin
vc_stringlist := 'lname,ARRAY';
dbms_utility.comma_to_table(vc_stringlist, n_idx, t_vararray);
dbms_output.put_line('Total Num : '||to_char(n_idx));
for i in 1..n_idx loop
dbms_output.put_line(t_vararray[i]);
t_vararray(i) := '['||t_vararray[i]||']';
dbms_output.put_line('<<'||t_vararray[i]);
end loop;
n_idx := n_idx - 1;
dbms_utility.table_to_comma(t_vararray, n_idx, vc_stringlist);
dbms_output.put_line('>>>>>');
dbms_output.put_line(''||vc_stringlist);
end;
/
```

返回结果如下，则表示函数调用成功：

```
Total Num : 2
lname
<<[lname]
ARRAY
<<[ARRAY]
>>>>>
[lname],[ARRAY]

```

- get_time函数

```
CREATE OR REPLACE FUNCTION get_runtime() returns number as $$
DECLARE
  start_time   NUMBER;
  finish_time  NUMBER;
  elapsed_time NUMBER;
BEGIN
  start_time := DBMS_UTILITY.get_time();
  perform pg_sleep(2);
  finish_time := DBMS_UTILITY.get_time();
  elapsed_time := finish_time  - start_time;
  return elapsed_time;
END
$$ language plpgsql;
```

调用get_runtime函数，返回结果如下，则表示调用成功：

```
call get_runtime();
 get_runtime
-------------
         200
(1 row)
```

- get_hash_value函数

```
select dbms_utility.get_hash_value('1242',0,1000);
```

返回结果如下，则表示函数调用成功：

```
 get_hash_value
----------------
            984
(1 row)
```

#### COMMA_TO_TABLE函数<a id="UTLCOMMA_TO_TABLE"></a>

**语法格式**

```
DBMS_UTILITY.COMMA_TO_TABLE(
list in VARCHAR|VARCHAR2,
tablen OUT BIGINT,
tab  OUT varchar[]);
```

**参数说明**

- list：逗号间隔的字符串。
- Tablen：数组类型的数量。
- Tab：数组类型的数值。

**注意事项**

- list必须是费控的逗号间隔符类型。字符串里面双引号中的逗号不极端在内。
- 逗号分割列表中的条目不能包含多字节字符，例如连字符（-）。
- tab里的值应为原始列表中剪裁出来的值，不能做任何转换。


#### TABLE_TO_COMMA函数<a id="UTLTABLE_TO_COMMA"></a>

**语法格式**

```
DBMS_UTILITY.TABLE_TO_COMMA(
tab in varchar[],
tablen OUT BIGINT,
list  OUT VARCHAR|VARCHAR2);
```

**参数说明**

- list：逗号间隔的字符串。
- Tablen：数组类型的数量。
- Tab：数组类型的数值。


#### GET_TIME函数<a id="UTLGET_TIME"></a>

**语法格式**

```
DBMS_UTILITY.GET_TIME
return number;
```

**注意事项**

- 如果需要换算为秒，需要除以100。
- 该函数没有传入参数，返回值为number类型。


#### GET_HASH_VALUE函数<a id="UTLGET_HASH_VALUE"></a>


**语法格式**

```
dbms_utility.get_hash_value(
hash_name varchar,
hash_base integer,
hash_size integer);
```

**参数说明**

- hash_name：需要被转化为hash值的字符串。
- hash_base：hash起始位置。
- hash_size：hash大小，不能为0，若为正值表示从hash起始位置到加上hash
  大小的范围，为负值表示从integer范围排除从hash起始位置减去hash大小绝对值的范围。


####  EXEC_DDL_STATEMENT  函数<a id="UTLEXEC_DDL_STATEMENT"></a>

**语法格式**

```
DBMS_UTILITY.EXEC_DDL_STATEMENT (
   parse_string IN VARCHAR2);
```

**参数说明**

- parse_string：要被执行的DDL语句。

#### FORMAT_CALL_STACK函数<a id="UTLFORMAT_CALL_STACK"></a>

**语法格式**

```
DBMS_UTILITY.FORMAT_CALL_STACK 
  RETURN VARCHAR2;
```

### DBMS_SQL

**功能描述**

DBMS_SQL主要功能是提供用于执行动态SQL(DML和DDL)的方法。该内置包包含以下函数：

<table >
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td><a href="#OPEN_CURSOR">OPEN_CURSOR</a></td>
<td>打开一个cursor，并返回该cursor的id。</td>
</tr>
<tr>
<td><a href="#CLOSE_CURSOR">CLOSE_CURSOR</a> </td>
<td>用于关闭一个cursor。</td>
</tr>
<tr>
<td ><a href="#COLUMN_VALUE">COLUMN_VALUE</a> </td>
<td>用于将fetch结果中的指定列保存到返回参数中。</td>
</tr>
<tr>
<td><a href="#DEFINE_COLUMN">DEFINE_COLUMN</a> </td>
<td>用于定义返回的结果中的列结构。</td>
</tr>
<tr>
<td><a href="#EXECUTE">EXECUTE</a></td>
<td>用于执行PARSE函数处理的SQL语句。</td>
</tr>
<tr>
<td><a href="#FETCH_ROWS">FETCH_ROWS</a> </td>
<td>用于载入结果集中的一行结果。</td>
</tr>
<tr>
<td><a href="#PARSE">PARSE</a></td>
<td>解析当前语句的语法。</td>
</tr>
<tr>
<td><a href="#RETURN_RESULT">RETURN_RESULT</a></td>
<td>用于将已执行语句的结果返回到客户端应用程序。</td>
</tr>
</table>

**注意事项**

无。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：BIND_ARRAY、BIND_VARIABLE、BIND_VARIABLE_PKG、COLUMN_VALUE_LONG、DEFINE_ARRAY 、DEFINE_COLUMN_CHAR、DEFINE_COLUMN_LONG、DEFINE_COLUMN_RAW、DEFINE_COLUMN_ROWID、DESCRIBE_COLUMNS、DESCRIBE_COLUMNS2、DESCRIBE_COLUMNS3、EXECUTE_AND_FETCH、GET_NEXT_RESULT、IS_OPEN、LAST_ERROR_POSITION、LAST_ROW_ID、LAST_SQL_FUNCTION_CODE、TO_CURSOR_NUMBER 、TO_REFCURSOR、VARIABLE_VALUE、VARIABLE_VALUE_PKG。

**示例**

1、创建测试表并插入数据。

```
create table dbms_t1(id number,con varchar(20));
insert into dbms_t1 values(1.5,'aaa'),(2.0,'bbb'),(3,'ccc');
```

2、创建存储过程调用函数。

```
CREATE OR REPLACE function dbms_demo1() return text AS
    cursor_name INT;
    rows_processed INT;
            ret INT;
            rec text;
BEGIN
    cursor_name := DBMS_SQL.open_cursor();
            DBMS_SQL.PARSE(cursor_name,'select con from public.dbms_t1;',0);
            ret := DBMS_SQL.EXECUTE(cursor_name);
            loop
            if DBMS_SQL.FETCH_ROWS(cursor_name) > 0 then
                    select DBMS_SQL.COLUMN_VALUE(cursor_name,1,rec) into rec;
            else
                    exit;
            end if;
            end loop;
            DBMS_SQL.CLOSE_CURSOR(cursor_name);
            return rec;
END;
/
```

3、调用存储过程dbms_demo1()。

```
 select dbms_demo1();
```

当结果显示如下，则表示函数调用成功：

```
 dbms_demo1
------------
 ccc
(1 row)

```

4、创建测试表re_t1，re_t2并插入数据。

```
create table re_t1(c1 int,c2 varchar(32));
insert into re_t1 values(1,'111');
insert into re_t1 values(2,'222');
create table re_t2(c1 varchar(32),c2 int);
insert into re_t2 values('111',1);
insert into re_t2 values('222',2);
```

5、使用sys_refcursor类型作为输入。

```
create or replace procedure re_proc() as
rc1 sys_refcursor;
rc2 sys_refcursor;
begin
open rc1 for select * from re_t1;
dbms_sql.return_result(rc1);
open rc2 for select * from re_t2;
dbms_sql.return_result(rc2);
end;
/
```

6、调用存储过程re_proc()。

```
call re_proc();
```

当返回结果如下，则表示函数调用成功：

```
ResultSet #1

 c1 | c2
----+-----
  1 | 111
  2 | 222
(2 rows)

ResultSet #2

 c1  | c2
-----+----
 111 |  1
 222 |  2
(2 rows)

 re_proc
---------

(1 row)

```

7、使用integer类型作为输入参数。

```
create or replace procedure re_proc_int() as
id number;
id1 number:=dbms_sql.open_cursor();
id2 number:=dbms_sql.open_cursor();
begin
dbms_sql.parse(id1,'select * from public.re_t1',0);
id:=dbms_sql.execute(id1);
dbms_sql.return_result(id1);
dbms_sql.parse(id2,'select * from public.re_t2',0);
id:=dbms_sql.execute(id2);
dbms_sql.return_result(id2);
end;
/
```

8、调用存储过程re_proc_int()。

```
call re_proc_int();
```

当结果返回如下，则表示调用成功：

```
ResultSet #1

 c1 | c2
----+-----
  1 | 111
  2 | 222
(2 rows)

ResultSet #2

 c1  | c2
-----+----
 111 |  1
 222 |  2
(2 rows)

 re_proc_int
-------------

(1 row)

```

#### OPEN_CURSOR<a id="OPEN_CURSOR"></a>

**语法格式** 

```
DBMS_SQL.OPEN_CURSOR (
   c    IN OUT INTEGER);
```

**参数说明**
c：需要打开的游标ID号。

#### CLOSE_CURSOR<a id="CLOSE_CURSOR"></a>

**语法格式**

```
DBMS_SQL.CLOSE_CURSOR (
   c    IN OUT INTEGER);

```

**参数说明**

c：需要关闭的游标ID数。

#### COLUMN_VALUE<a id="COLUMN_VALUE"></a>

**语法格式**

```
DBMS_SQL.COLUMN_VALUE (
   c                 IN  INTEGER,
   position          IN  INTEGER,
   value             OUT <datatype> 
 [,column_error      OUT NUMBER] 
 [,actual_length     OUT INTEGER]);

```

**参数说明**

- c：游标ID号。
- position：光标中列的相对位置、语句中的第一列位置为1。
- value：返回指定列的值。
- column_error：返回指定列值的任何错误代码。
- actual_length：指定列的值在截断之前的实际长度

#### DEFINE_COLUMN<a id="DEFINE_COLUMN"></a>

**语法格式**

```
DBMS_SQL.DEFINE_COLUMN (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN <datatype>);


DBMS_SQL.DEFINE_COLUMN (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN VARCHAR2 CHARACTER SET ANY_CS,
   column_size    IN INTEGER);
```

**参数说明**

- c：游标ID号。
- position：正在定义的行中列的相对位置，语句中第一列的位置为1。
- colum：列的值
- column_size：列值的最大预期大小（以字节为单位）。

#### EXECUTE<a id="EXECUTE"></a>

**语法格式**

```
DBMS_SQL.EXECUTE (
   c   IN INTEGER)
  RETURN INTEGER;

```

**参数说明**

c：游标ID号。

#### FETCH_ROWS<a id="FETCH_ROWS"></a>

**语法格式**

```
DBMS_SQL.FETCH_ROWS (
   c              IN INTEGER)
  RETURN INTEGER;

```

**参数说明**

c：ID号。

#### PARSE<a id="PARSE"></a>

**语法格式**

```
DBMS_SQL.PARSE (
   c                           IN   INTEGER, 
   statement                   IN   VARCHAR2A,
   lb                          IN   INTEGER, 
   ub                          IN   INTEGER,
   lfflg                       IN   BOOLEAN, 
   language_flag               IN   INTEGER[
 [,edition                     IN   VARCHAR2 DEFAULT NULL],
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE]
 [,schema                      IN   VARCHAR2 DEFAULT NULL]
 [,container                   IN   VARCHAR2)];

DBMS_SQL.PARSE (
   c                           IN   INTEGER, 
   statement                   IN   VARCHAR2s,
   lb                          IN   INTEGER, 
   ub                          IN   INTEGER,
   lfflg                       IN   BOOLEAN, 
   language_flag               IN   INTEGER[
 [,edition                     IN   VARCHAR2 DEFAULT NULL],
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE]
 [,schema                      IN   VARCHAR2 DEFAULT NULL]
 [,container                   IN   VARCHAR2)];

```

**参数说明**

- c：要解析的语句的游标ID号。

- statement：要解析的SQL语句。

- lb：语句元素的下限。

- ub：语句中元素的上限。

- lfflg：如果设置为TRUN，则在连接的每个元素之后插入换行符。

- language_flag：指定 SQL 语句的行为。

- edition：指定在以下条件下运行语句的版本：

  - 如果是NULL该语句将在当前版本中运行。

  - 如果指定了有效容器，则通过NULL表示该语句将在目标容器的默认版本中运行。

  - 给定用户和执行语句的版本，用户必须USE对该版本具有特权。

    以下一般条件适用。字符串的内容作为 SQL 标识符处理；如果版本的实际名称中存在特殊字符或小写字符，则必须用双引号将字符串的其余部分括起来，如果不使用双引号，则内容将大写。

- apply_crossedition_trigger：指定要应用于指定 SQL 的正向交叉版本触发器的非限定名称。

- fire_apply_trigger：指示apply_crossedition_trigger的内容本身是要执行的，还是只能作为用于选择其他触发器的指南。

- schema：指定解析不合格对象名称的架构。如果NULL，则当前架构是有效用户的架构。

- container：要在其中运行的目标容器的名称。


#### RETURN_RESULT<a id="RETURN_RESULT"></a>

**语法格式**

```
DBMS_SQL.RETURN_RESULT(
   rc           IN OUT      SYS_REFCURSOR, 
   to_client    IN          BOOLEAN           DEFAULT TRUE);

DBMS_SQL.RETURN_RESULT(
   rc           IN OUT      INTEGER, 
   to_client    IN          BOOLEAN           DEFAULT TRUE);

```

**参数说明**

- rc：语句游标或引用游标。
- to_client：将语句结果返回（或不返回）给客户端。如果是FALSE，则将其返回给直接调用者。

### DBMS_JOB

**功能描述**

DBMS_JOB包用于安排和管理作业队列，通过使用作业，可以使数据库定期执行特定的任务。该内置包中包含以下函数：

<table >
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
 <td><a href="#SUBMIT">SUBMIT</a></td>
<td>打开一个cursor，并返回该cursor的id。</td>
</tr>
<tr>
<td><a href="#RUN">RUN</a></td>
<td>运行一次指定的任务。</td>
</tr>
<tr>
<td> <a href="#REMOVE">REMOVE</a></td>
<td>移除一个定时任务。</td>
</tr>
<tr>
<td><a href="#BROKEN">BROKEN</a></td>
<td>停止或启动一个定时任务。</td>
</tr>
</table>


**注意事项**

无。

**兼容性**


Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：CHANGE、INSTANCE、INTERVAL、NEXT_DATE、USER_EXPORT、WHAT。

**示例**

1、设置 enable_prevent_job_task_startup参数为off（即job线程不能启动）。

```
ALTER SYSTEM SET enable_prevent_job_task_startup TO off;
```

2、创建测试表并插入数据。

```
drop table if exists t_sub;
create table t_sub(insert_date timestamp);
```

3、创建插入数据的定时任务。

```
select dbms_job.submit(1,'insert into t_sub values(sysdate);',sysdate,'''1min''::interval');
select * from t_sub;
```

返回结果为：

```
     insert_date
---------------------
 2022-07-06 09:14:39
(1 row)

```

4、等待1分钟之后，查询t_sub。

```
select * from t_sub;
```

返回结果如下，则表示定时任务创建成功：

```
     insert_date
---------------------
 2022-07-06 09:14:39
 2022-07-06 09:15:39
(2 rows)


```

5、运行正在运行的任务。

```
select dbms_job.run(1);
```

6、移除正在运行的任务：

```
select dbms_job.remove(1);
```

#### SUBMIT函数<a id="SUBMIT"></a>

**语法格式**

```
DBMS JOB.SUBMIT (
job      OUT BINARY_INTEGER. 
what     IN VARCHAR2, 
next_date IN DATE DEFAULT sysdate
interval IN VARCHAR2 DEFAULT 'null'
no_parse IN BOOLEAN DEFAULT FALSE,
instance IN BINARY INTEGER DEFAULT any_instance,
force IN BOOLEAN DEFAULT FALSE); 
```

**参数说明**

- job：输出参数，输出正在运行的作业编号。
- what：指定需要运行的存储过程。
- next_date：下一次job 运行的时间，默认为sysdate。
- interval：时间间隔，默认为 null。
- no_parse：标记参数。设置为 true 表示数据库会在首次运行该作业时解析与该作业相关联的过程，默认为 false 。
- instance：提交作业后，指定可以运行该作业的实例(支持该参数传入，但不校验并忽略该参数)。
- force：该参数设置为true 时表示任何正整数都可被接受为作业实例，默认为false则指定实例必须是运行着的(支持该参数传入，但不校验并忽略该参数)。


####  RUN函数<a id="RUN"></a>


**语法格式**

```
DBMS JOB.RUN (
job      IN BINARY_INTEGER. 
force IN BOOLEAN DEFAULT FALSE); 
```

**参数说明**

- job：需要运行的作业编号。
- force：该参数设置为true 时表示任何实例环境与在进程中与运行的作业无关，如果设置为false，则只能在指定实例中运行作业(支持该参数传入，但不校验并忽略该参数)。


####  REMOVE函数<a id="REMOVE"></a>

**语法格式**

```
DBMS JOB.RUN (
job     IN BINARY_INTEGER;
```

**参数说明**

job：需要删除的作业编号。

#### BROKEN函数<a id="BROKEN"></a>


**语法格式**

```
DBMS JOB.RUN (
job     IN BINARY_INTEGER,
Broken  IN BOOLEAN,
next_date IN DATE DEFAULT sysdate);
```

**参数说明**

- job：作业编号。
- broken：boolean类型，设置为true表示停止或者禁用作业任务，false则表示不中断（broken）作业任务。
- next_date：任务作业运行的下一个日期。


### DBMS_STATS

**功能描述**

DBMS_STATS包用于查看和修改收集的所有数据库对象的统计信息，以便能估量统计数据（尤其是针对较大的分区表），从而制定出速度更快的SQL执行计划。该内置包中包含以下函数：

- GATHER_SCHEMA_STATS函数：收集模式中所有对象的统计信息。

**注意事项**

无。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，仅支持GATHER_SCHEMA_STATS函数。

#### GATHER_SCHEMA_STATS函数

**功能描述**

该函数用于收集指定模式下的所有对象的统计信息。

**语法格式**

- 第一种：

```
DBMS_STATS.GATHER_SCHEMA_STATS(
ownname		VARCHAR2，
estimate_percent NUMBER   DEFAULT 100,
block_sample BOOLEAN DEFAULT FALSE,
method_opt		VARCHAR2 default 'FOR ALL COLUMNS SIZE AUTO',
degree 			NUMBER DEFAULT NULL,
granularity 		VARCHAR2 DEFAULT 'GLOBAL'
cascade			 BOOLEAN DEFAULT FALSE,
stattab 			VARCHAR2 DEFAULT NULL,
statid 			VARCHAR2 DEFAULT NULL,
options 			VARCHAR2 DEFAULT 'GATHER',
objlist 		OUT ObjectTab, 
statown 		VARCHAR2 DEFAULT NULL,
no_invalidate 	BOOLEAN DEFAULT FALSE,
force 		BOOLEAN DEFAULT FALSE, 
obj_filter list ( ObjectTab DEFAULT NULL);
```

- 第二种：

```
DBMS_STATS.GATHER_SCHEMA_STATS(
ownname		VARCHAR2，
estimate_percent NUMBER   DEFAULT 100,
block_sample BOOLEAN DEFAULT FALSE,
method_opt		VARCHAR2 default 'FOR ALL COLUMNS SIZE AUTO',
degree 			NUMBER DEFAULT NULL,
granularity 		VARCHAR2 DEFAULT 'GLOBAL'
cascade			 BOOLEAN DEFAULT FALSE,
stattab 			VARCHAR2 DEFAULT NULL,
statid 			VARCHAR2 DEFAULT NULL,
options 			VARCHAR2 DEFAULT 'GATHER',
statown 		VARCHAR2 DEFAULT NULL,
no_invalidate 	BOOLEAN DEFAULT FALSE,
force 		BOOLEAN DEFAULT FALSE, 
obj_filter list ( ObjectTab DEFAULT NULL);
```

**参数说明**

- ownname：要分析的schema（NULL表示当前schema）。
- estimate_percent: 确定要采样的行的百分比，有效范围在0.000001~100。
- block_sample：表示是否使用随机块采样代替随机行采样，默认为false。注意：Vastbase 目前无需支持，可忽略该参数。
- method_opt：默认值为：FOR ALL COLUMNS SIZE AUTO（仅支持该选项，其
  他选项不支持）。该选项可接受的语法为：

```
FOR ALL [INDEXED|HIDDEN] COLUMNS [size clause]
```

- size clause := SIZE {integer| REPEAT| AUTO |SKEWONLY}
- Integer：直方图数。必须在1~2048范围内。
- REPEAT：仅在已经具有直方名的列上收集直方名。
- AUTO：数据库根据数据分布和列的工作量确定要收集直方图的列。
- SKEWONLY：数据库根据列的数据分布来确定要收集直方图的列。
- degree：并行度，默认degree值为 NULL，也可以使用常量 AUTO DEGREE设
  置自动并行度（Vastbase 仅支持 NULL，其他选项不支持）。
- granularity：要收集的统计信息的粒度(仅在表已分区时才适用)。取值可以是：'GLOBAL'，'GLOBAL AND PARTITION’，'PARTITION'
- 'GLOBAL'：收集全局统计数据。
- 'GLOBAL AND PARTITION’：收集全局和分区级别的统计数据。
- 'PARTITION'：收集分区级别的统计信息。
- cascade：收集有关索引的统计信息。除了收集表和列统计信息之外，使用此选项
  等效于在模式中的每个索引上运行 GATHER_INDEX_STATS 过程，使用该常量 DBMS_STATS.AUTO_CASCADE 让数据库确定是否要收集索引统计信息。这是默认值（支持该参数传入，但不校验并忽略该参数）。
- stattab：用户统计信息表标识符，用于描述将当前统计信息保存在何处。
- statid：标识符。支持该参数传入，但不校验并忽略该参数。
- options：指定需要收集统计信息的对象。有效值如下：Vastbase 仅支持默认值 GATHER（收集 schema 中所有对象的统计信息），其他选项不支持。
- objlist：过旧或空的对象列表（支持该参数传入，但不校验并忽略该参数）。
- statown： 包含的 schema（支持该参数传入，但不校验并忽略该参数）。
- no_invalidate：是否使相关游标无效，设置为 false 表示使得相关游标无效:设置为 true 则相反（支持该参数传入，但不校验并忽略该参数）。
- force：收集有关对象的统计信息，被锁定的对象也会被统计（支持该参数传入，但不校验并忽略该参数）。
- obj_filter list：设置对象过滤器列表（支持该参数传入，但不校验并忽略该参数）。

**兼容性**

1、granularity参数只兼容部分选项，暂不支持的选项如下（与oracle的差异）：

- 'ALL'：收集所有(子分区，分区和全局)统计信息。
- 'AUTO'：根据分区类型确定粒度，这是默认值。
- 'DEFAULT'：收集全局和分区级别的统计信息。已过时，为向下兼容保留。
- 'SUBPARTITION'：收集子分区级别的统计信息。

2、GATHER参数目前Vastbase G100 Build 9暂不支持的选项如下（与oracle的差异）：

- GATHER AUTO ：自动收集所有必要的统计信息。
- GATHER STALE：通过查询*TAB MODIFICATIONS 视图来收集陈旧对象的统计信息。同样，数据库返回发现已过时的对象的列表。
- GATHER EMPTV：收集有关当前没有统计信息的对象的统计信息。同样。数据库返回发现没有统计信息的对象列表。
- LIST AUTO：返回要使用处理的对象的列表 GATHER AUTO。
- LIST STALE：返回通过查看* TAB MODIFICATIONS 视名确定的陈旧对象的列表。
- LIST EMPTY：返回当前没有统计信息的对象列表。

**示例**

1、创建模式。

```
create schema zmm;
```

2、创建分区表。

```
create table zmm.customer_address
(
    ca_address_sk       integer                  not null   ,
    ca_address_id       character(16) 
)
partition by range (ca_address_sk)
(
        partition p1 values less than(500),
        partition p2 values less than(1000),
        partition p3 values less than(1500),
        partition p4 values less than(2000),
        partition p5 values less than(2500),
        partition p6 values less than(3000),
        partition p7 values less than(4000),
        partition p8 values less than(maxvalue) 
)
enable row movement;
```

3、插入数据。

```
insert into zmm.customer_address(ca_address_sk) values(generate_series(1,5000));
```

4、调用dbms_stats.gather_schema_stats函数收集统计信息。

```
exec dbms_stats.gather_schema_stats(ownname=>'zmm',estimate_percent=>100,block_sample=>false,method_opt=>'for all columns size auto',degree=>DBMS_STATS.AUTO_DEGREE,granularity=>'GLOBAL',cascade=>DBMS_STATS.AUTO_CASCADE,stattab=>'',statid=>'',options=>'GATHER AUTO',no_invalidate=>DBMS_STATS.AUTO_INVALIDATE,force=>false,statown=>'');
```

返回结果如下，则表示函数调用成功：

```
NOTICE:  PL/SQL procedure successfully completed.
 gather_schema_stats
---------------------

(1 row)
```

### DBMS_DEBUG

**功能描述**

DBMS_DEBUG内置包用于实现服务器端调试器，提供了一种调试服务器端PL/SQL程序单元的方法，调试时分为目标会话（the target session）和调试会话（the debug session），通过两个会话配合完成PL/SQL调试工作。

目标会话用来以调试模式运行代码，调试会话用来监督目标会话。在调试会话中通过使用初始化生成的会话id，结合执行响应的调试api接口与目标会话进行通信对PL/SQL程序单元进行调试。该内置包包含以下函数:

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
    <td><a href="#INITIALIZE">INITIALIZE</a></td>
<td>初始化目标会话以进行调试。</td>
</tr>
<tr>
<td><a href="#DEBUG_ON">DEBUG_ON</a></td>
<td>使所有PL/SQL都在调试模式下运行。</td>
</tr>
<tr>
<td><a href="#DEBUG_OFF">DEBUG_OFF</a></td>
<td>通知目标会话不应再进行调试。</td>
</tr>
<tr>
<td><a href="#DEBUGEXECUTE">EXECUTE</a></td>
<td>在目标会话中执行一段SQL或PL/SQL。</td>
</tr>
</table>


**注意事项**

- 只有在INITIALIZE操作之后才能进行DEBUG_ON操作，然后才能进行PL/SQL操作。
- 在目标会话中如果有DBMS_DEBUG.DEBUG_ON已生效，再次执行时会提示已开启调试模式。
- 在目标会话中如果有DBMS_DEBUG.DEBUG_OFF已生效，不会进入阻塞状态。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，支持的函数有：EXECUTE、INITIALIZE、DEBUG_ON、DEBUG_OFF,其他函数暂不支持。

**示例**

1、创建插件。

```
create extension pldbgapi;
```

2、调用debug_on函数。

```
exec dbms_debug.debug_on();
```

返回结果如下：

```
NOTICE:  Debugger is started successfully, you are SERVER now.
CONTEXT:  SQL statement "CALL dbms_debug.debug_on_inner($1,$2)"
PL/pgSQL function dbms_debug.debug_on(boolean,boolean) line 3 at PERFORM
 debug_on
----------

(1 row)
```

> <div align="left"><img src="image/image1.png" style="zoom:25%")</div>
>
> 该函数没有返回值，执行成功时会有Debugger is started successfully, you are Server now.的提示，没有procedure successfully completed的提示，Oracle的procedure successfully completed为执行过程执行成功时的的统一输出结果，这里与Oracle有差异。

3、调用execute函数。

```
select dbms_debug.execute('select * from pg_proc',-1,-1,'sds','sdsad');
```

返回结果为：

```
WARNING:  bind_results Only 0 or 1 is supported
CONTEXT:  referenced column: execute_inner
SQL statement "select dbms_debug.execute_inner($1, $2, $3, $4, $5)"
PL/pgSQL function dbms_debug.execute(varchar,integer,integer,dbms_debug_vc2coll,varchar) line 5 at SQL statement
referenced column: execute
 execute
---------
 t
(1 row)
```

4、调用dbms_debug.debug_off函数。

```
exec dbms_debug.debug_off();
```

####  INITIALIZE函数<a id="INITIALIZE"></a>


**语法格式**

```
DBMS DEBUG.INITIALIZE (
debug_session_id 	IN VARCHAR2    := NULL, 
diagnostics	 IN  BINARY_INTEGER := 0) 
RETURN VARCHAR2;
```

**参数说明**

- debug_session_id：会话ID的名称，如果为 NULL，则生成一个唯一的ID。
- diagnostics：指示是否将诊断信息输出，其中0为默认值，表示不诊断输出：1 为打印诊断信息。

#### DEBUG_ON函数<a id="DEBUG_ON"></a>


**语法格式**

```
DBMS DEBUG.DEBUG_ON (
no_client_side_plsql_engine  BOOLEAN := TRUE.
immediate BOOLEAN := FALSE); 
```

**参数说明**

- no_client_side_plsql_engine：默认值为true，除非从客户端PL/SQL引擎进行调试会话，否则应将其保留为默认值，
- immediate：如果值为TRUE，则解释器将立即将其自身切换到调试模式，而不是在调用期间以常规模式继续运行。


####  DEBUG_OFF函数<a id="DEBUG_OFF"></a>


**语法格式**

```
DBMS DEBUG.DEBUG_OFF;
```

#### EXECUTE函数<a id="DEBUGEXECUTE"></a>

**语法格式**

```
DBMS DEBUG.EXECUTE (
what			 IN VARCHAR2, 
frame# 		IN BINARY_INTEGER, 
bind_results IN BINARY_INTEGER,
results 		IN OUT NOCOPY dbms_debug_vc2coll,
errm 		IN OUT NOCOPY VARCHAR2); 
```

**参数说明**

- what：要执行的sql或pl/sgl 源。
- frame#：执行代码的上下文。目前仅支持-1(全局上下文)。
- bind_results：源是否要绑定到results以便从目标会话返回值：0=否;1=是。
- results：放置结果的集合(如果bind results不为0)，dbms_debug_vc2coll为集合类型，也写为sys.dbms_debug_vc2coll。
- errm：如果发生错误，显示错误信息，否则为null。


### UTL_URL

**功能描述**

UTL_URL内置包用于对URL进行转义。

通常URL中会包含英文字母、数字和标点符号，这些字符称为非保留字符。URL中的任何其他字符，包括多字节字符和二进制八位字节码，都必须进行转义才能被web服务器或web浏览器准确处理。一些标点符号，例如美元符号 ( $)、问号 (？)、冒号 (:)和等号 ( =)) 被保留为 URL 中的分隔符，它们被称为保留字符，需要从字面上来处理这些字符，而不是将他们视为分隔符，因此这些字符必须进行转义。

- 非保留字符有：
  - A_Z, a_z,0_9
  - 连字符 ( -)、下划线 ( _)、句号 ( .)、感叹号 ( !)、波浪号 ( ~)、星号 ( *)、重音 ( ')、左括号 ( ()、右括号 ( ))

- 保留字符有：分号 ( ;) 斜线 ( /)、问号 ( ?)、冒号 ( :)、at 号 ( @)、和号 ( &)、等号 ( =)、加号 ( +)、美元符号 ( $)、百分号 ( %) 和逗号 ( ) ,)

该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td><a href="#URLESCAPE">ESCAPE</a></td>
<td>对URL进行转义。</td>
</tr>
<tr>
<td><a href="#URLUNESCAPE">UNESCAPE</a></td>
<td>对已转义的URL进行反转义。</td>
</tr>
</table>


**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。
- 目前支持的字符集有gbk，gb2312，utf-8。
- 功能基于python3及插件plpython3u，需要有python3环境（目前测试通过的python版本是python3.7和python3.8），python3 编译时指定--enable-shared。
- 若需要启用tls安全认证，需要安装openssl及openssl-devel，且python3编译时指定。--with-ssl-default-suites=openssl，如安装完在python3命令行执行import ssl成功，则说明安装ssl模块成功。
  例如：./configure --prefix=/usr/local/python3.8 --enable-shared --with-ssl-default-suites=openssl

**示例**

1、安装python3。

2、添加环境变量。

- PYTHONHOME：python3安装路径
- LD_LIBRARY_PATH：增加python3安装路径下的lib目录
- PATH：增加python3安装路径bin目录

3、创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';    
\c db_oracle
```

4、创建plpython3u扩展。

```
create extension plpython3u;
```

5、调用utl_url.escape函数对URL进行转义。

```
select utl_url.escape('https://www.baidu.com/参数/=+/',false,'gb2312');
```

6、调用utl_url.unescape函数对URL进行反转义。

```
select utl_url.unescape('https://www.baidu.com/%B2%CE%CA%FD/=+/','gb2312');
```

#### ESCAPE函数<a id="URLESCAPE"></a>

**语法格式**

```
UTL_URL.ESCAPE (
   url                   IN VARCHAR2 CHARACTER SET ANY_CS,
   escape_reserved_chars IN BOOLEAN  DEFAULT  FALSE,
   url_charset           IN VARCHAR2 DEFAULT  utl_http.body_charset)
 RETURN VARCHAR2;
```

**参数说明**

- url：原始URL。
- escape_reserved_chars：是否转义保留字符，true为转义，默认为false。
- url_charset：定需转换的字符设置为目标字符集。默认值是UTL_HTTP包的当前正文字符集，默认ISO-8859-1。


#### UNESCAPE函数<a id="URLUNESCAPE"></a>

**语法格式**

```
UTL_URL.UNESCAPE (
   url            IN VARCHAR2 CHARACTER SET ANY_CS,
   url_charset    IN VARCHAR2 DEFAULT utl_http.body_charset)
 RETURN VARCHAR2;
```

**参数说明**

- url：需要反转义的URL。
- url_charset：定需转换的字符设置为目标字符集。


### UTL_FILE

**功能描述**

UTL_FILE包是用于提供在存储过程或函数中对系统文件进行读写的功能。该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td>fopen</td>
<td>打开一个文件用于输入或输出。</td>
</tr>
<tr>
<td>is_open</td>
<td>检查一个文件句柄是否指向一个打开的文件。</td>
</tr>
<tr>
<td>get_line</td>
<td>从一个打开的文件中读取指定的一行文本。</td>
</tr>
<tr>
<td>get_nextline</td>
<td>获得下一行。</td>
</tr>
<tr>
<td>put</td>
<td>将一个字符串写入到文件。</td>
</tr>
<tr>
<td>put_line</td>
<td>在文件中写入一行，在行的末尾写入一个行终结符。
</td>
</tr>
<tr>
<td>new_line</td>
<td>在文件末尾写入一个行终结符。</td>
</tr>
<tr>
<td>putf</td>
<td>格式化输出过程。</td>
</tr>
<tr>
<td>fflush</td>
<td>将文件缓存刷到物理写入。</td>
</tr>
<tr>
<td>fclose</td>
<td>关闭一个文件。
</td>
</tr>
<tr>
<td>fclose_all</td>
<td>关闭所有打开的文件。</td>
</tr>
<tr>
<td>fremove</td>
<td>删除磁盘上的文件。</td>
</tr>
<tr>
<td>frename</td>
<td>重命名一个已经存在的文件。</td>
</tr>
<tr>
<td>fremove</td>
<td>删除磁盘上的文件。</td>
</tr>
<tr>
<td>fcopy</td>
<td>将一个文件中的内容拷贝到另一个文件中。</td>
</tr>
<tr>
<td>fgetattr</td>
<td>获取文件属性。</td>
</tr>
<tr>
<td>tmpdir</td>
<td>获得临时目录路径。</td>
</tr>
</table>


**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，不支持的函数有：FGETPOS、FOPEN_NCHAR、FSEEK、GET_LINE_NCHAR、GET_ROW、PUT_NCHAR、PUT_LINE_NCHAR、PUT_row。

**示例**

1、创建主备文件，在操作系统中执行如下命令。

```
echo "111aaa
222bbb
333ccc
444ddd
555eee
666fff
777ggg
888hhh
999iii
101010jjj
111111kkk"  > /tmp/test.txt
```

2、连接数据库，创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';    
\c db_oracle
```

3、在数据库下执行。

```
insert into utl_file.utl_file_dir values ('/tmp');
```

4、在数据库下执行文件复制（utl_file.fcopy是Oracle中的一个“静态参数”，可以设置一个或多个路径。）。

```
select utl_file.fcopy('/tmp', 'test.txt', '/tmp', 'test_cp.txt',3,6);

```

5、查看复制的文件,在shell下执行。

```
cat test_cp.txt
```

返回结果如下，则表示文件复制成功：

```
333ccc
444ddd
555eee
666fff
```

7、连接db_oracle数据库，fgetattr查看文件属性。

```
do language plpgsql $$
declare
ex boolean;
flen int;
bsize int;
begin
-- utl_file.fgetattr('/tmp'::text, 'test.txt'::text, ex, flen, bsize);
select * from utl_file.fgetattr('/tmp'::text, 'test.txt'::text) into ex,flen,bsize;
IF ex THEN
raise notice 'File Exists';
ELSE
raise notice 'File Does Not Exist' ;
END IF;
raise notice 'FileLength: %' , flen;
raise notice 'BlockSize: %',bsize;
end;
$$;
```

返回结果为：

```
NOTICE:  File Exists
NOTICE:  FileLength: 0
NOTICE:  BlockSize: 4096
ANONYMOUS BLOCK EXECUTE

```

8、调用存储过程对文件进行读写。

```
do language plpgsql $$
declare
vInHandle utl_file.file_type;
vOutHandle utl_file.file_type;
vNewLine VARCHAR2(250);
begin
vInHandle := utl_file.fopen('/tmp', 'test.txt','R');
LOOP
BEGIN
select * from utl_file.get_line(vInHandle)into vNewLine ;
raise notice '%', vNewLine;
EXCEPTION
WHEN OTHERS THEN
EXIT;
END;
END LOOP;
vOutHandle := utl_file.fopen('/tmp', 'test_cp.txt', 'w');
perform utl_file.put_line(vOutHandle, 'hello lsxy');
utl_file.fflush(vOutHandle);
utl_file.fclose_all();
end;
$$;
```

9、在shell执行如下命令，查看文件内容。

```
cat /tmp/test_cp.txt
```

返回结果为：

```
hello lsxy
```

### DBMS_ALERT

**功能说明**

DBMS_ALERT用于生成并传递数据库警报信息，是一种在数据库内部和应用程序间通信的一种方式。

DBMS_ALERT产生的警报是基于事务的，这意味着如果产生警报的事务未被提交，则等待该警报的session会话将不会收到该警报。一个正在等待警报的session将在数据库中被阻塞。该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
 <td><a href="#ALTERREGISTER">REGISTER</a></td>
<td>注册当前会话接受指定的警报。</td>
</tr>
<tr>
<td><a href="#ALTERREMOVE">REMOVE</a></td>
<td>去除对指定警报的注册。</td>
</tr>
<tr>
<td><a href="#ALTERREMOVEALL">REMOVEALL</a></td>
<td>去除对所有警报的注册。</td>
</tr>
<tr>
<td><a href="#ALTERSIGNAL">SIGNAL</a></td>
<td>为指定警报发出信号。</td>
</tr>
<tr>
<td><a href="#ALTERWAITANY">WAITANY</a></td>
<td>等待任何已注册的警报出现。</td>
</tr>
<tr>
<td><a href="#ALTERWAITONE">WAITONE</a></td>
<td>等待指定的警报出现。</td>
</tr>
</table>


**注意事项**

无。

**兼容性**

完全兼容。

**示例**

1、去除alert1警报的注册。

```
select DBMS_ALERT.REMOVE('alert1');
```

2、会话1:接受进程(客户端接收)。

```
select DBMS_ALERT.REGISTER('alert1');
```

3、切换至会话2，发送进程（服务器端发出）。

```
BEGIN;
select DBMS_ALERT.SIGNAL('alert1', 'hello,this is sending process!');
commit;
```

4、切换至会话1:接受进程(客户端接收)。

```
select DBMS_ALERT.WAITONE('alert1',100);
```

返回结果为:

```
"hello,this is sending process!",0
```

#### REGISTER<a id="ALTERREGISTER"></a>

**语法格式**

```
DBMS_ALERT.REGISTER (
   name      IN  VARCHAR2);
```

**参数说明**

name：text类型，指定的警报的名字。

#### REMOVE<a id="ALTERREGISTER"></a>

**语法格式**

```
DBMS_ALERT.REMOVE (
   name  IN  VARCHAR2);
```

**参数说明**

name：text类型，将要被移除的警报的名字（大小写不敏感）。

#### REMOVEALL<a id="ALTERREMOVEALL"></a>

**语法格式**

```
DBMS_ALERT.REMOVEALL;
```

#### SIGNAL<a id="ALTERSIGNAL"></a>

**语法格式**

```
DBMS_ALERT.SIGNAL (
   name     IN  VARCHAR2,
   message  IN  VARCHAR2);
```

**参数说明**

- name：text类型，指定的警报的名字。
- message：text类型，本次警报携带的消息字符串，将被传递给执行wait的会话。

#### WAITANY<a id="ALTERWAITANY"></a>

**语法格式**

```
DBMS_ALERT.WAITANY (
   name      OUT  VARCHAR2,
   message   OUT  VARCHAR2,
   status    OUT  INTEGER,
   timeout   IN   NUMBER DEFAULT MAXWAIT);
```

**参数说明**

- name：text类型，等待的警报的名字。
- message：text类型，收到的警报携带的消息字符串。如果收到的警报在WAITANY之前被SIGNAL产生了多次，那么收到的message消息字符串是最近的一次SIGNAL产生的，之前的SIGNAL产生的message消息将被忽略。。
- status：integer类型，0表示由收到警报返回，1表示由于超时返回。
- timeout：警报等待的最长时间。缺省默认值为86400000（1000天）。

#### WAITONE<a id="ALTERWAITONE"></a>

**语法格式**

```
DBMS_ALERT.WAITONE (
   name      IN   VARCHAR2,
   message   OUT  VARCHAR2,
   status    OUT  INTEGER,
   timeout   IN   NUMBER DEFAULT MAXWAIT);
```

**参数说明**

- name：text类型，等待的指定的警报的名字。
- message：text类型，收到的警报携带的消息字符串。如果收到的警报在WAITANY之前被SIGNAL产生了多次，那么收到的message消息字符串是最近的一次SIGNAL产生的，之前的SIGNAL产生的message消息将被忽略。。
- status：integer类型，，0表示由收到警报返回，1表示由于超时返回。
- timeout：警报等待的最长时间。缺省默认值为86400000（1000天）。


###  UTL_HTTP

**功能描述**

使用UTL_HTTP包可通过SQL和过程语言调用超文本传输协议HTTP，允许通过HTTP访问internet上的数据。该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
    <td><a href="#HTTPSET_TRANSFER_TIMEOUT">SET_TRANSFER_TIMEOUT</a></td>
<td>设置UTL_HTTP从WEB服务器或代理服务器读取HTTP响应的超时值。</td>
</tr>
<tr>
<td><a href="#HTTPREQUEST">REQUEST</a></td>
<td>从指定的URL请求检索数据。可直接用于SQL查询。</td>
</tr>
<tr>
    <td><a href="#HTTPBEGIN_REQUEST">BEGIN_REQUEST</a></td>
<td>开始一个新的HTTP请求。</td>
</tr>
<tr>
    <td><a href="#HTTPSET_HEADER">SET_HEADER</a></td>
<td>用于设置http请求头。</td>
</tr>
<tr>
<td><a href="#HTTPGET_RESPONSE">GET_RESPONSE</a></td>
<td>用于读取http响应。</td>
</tr>
<tr>
<td><a href="#HTTPSET_BODY_CHATSET">SET_BODY_CHATSET</a></td>
<td> Content-Type标头中未指定字符集时，设置请求体的字符集。</td>
</tr>
<tr>
<td><a href="#HTTPWRITE_TEXT">WRITE_TEXT</a></td>
<td>在HTTP请求体中写入一些文本数据。</td>
</tr>
<tr>
<td><a href="#HTTPREAD_LINE">READ_LINE</a></td>
<td>以文本形式读取http响应正文，直到到达尾行。</td>
</tr>
<tr>
<td><a href="#HTTPEND_RESPONSE">END_RESPONSE</a></td>
<td>结束HTTP响应，完成HTTP请求和响应。</td>
</tr>
<tr>
    <td><a href="#HTTPEND_REQUEST">END_REQUEST</a></td>
<td>结束HTTP请求。</td>
</tr>
<tr>
<td><a href="#HTTPGET_DETAILED_SQLERRM">GET_DETAILED_SQLERRM</a></td>
<td>检索最后引发的异常的详细SQLERRM。</td>
</tr>
</table>


**类型说明**

**req类型**

**功能描述**

req用于接受http的request请求。

**语法格式**

```
TYPE req RECORD(
url  VARCHAR2(32767),
method  VARCHAR2(64),
http_version   VARCHAR2(64),
);
```

**参数说明**

- url：http请求的URL，在BEGIN_REQUEST进行设置。

- method：请求url的方法，在BEGIN_REQUEST进行设置。

- http_version：发送请求的http协议版本。


**resq类型**

**功能描述**

使用resq的记录表示http的响应。

**语法格式**

```
TYPE resq RECORD(
status_code  PLS_INTEGER,
reason_phrase  VARCHAR2(256),
http_version   VARCHAR2(64),
);
```

**参数说明**

- url：http请求的URL，在BEGIN_REQUEST进行设置。
- method：请求url的方法，在BEGIN_REQUEST进行设置。
- http_version：发送请求的http协议版本。

**使用流程**

1. 定义http.rep和http.resp变量。
2. 设置http超时时间。
3. 进行url编码，设置header，设置body字符集。
4. 获取request请求。
5. 获取response。
6. 异常处理。

**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。
- 使用该功能需要创建plpython3u插件。

**兼容性**

Vastbase G100 V2.2版本与Oracle 11g R2版本相比，仅支持本文档介绍的函数，该内置包的其他函数暂不支持。

**示例**

1、系统已经安装python3环境。 

2、创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';    
\c db_oracle
```

3、创建plpython3u插件。

```
create extension plpython3u;
```

4、使用UTL_HTTP包创建函数。

```
CREATE OR REPLACE FUNCTION FN_HTTP_GET (v_url VARCHAR2)
RETURN VARCHAR2
AS
BEGIN
DECLARE
req UTL_HTTP.REQ;
resp UTL_HTTP.RESP;
res record;
value varchar2;
v_text text;
BEGIN
v_text := '';
BEGIN
req := UTL_HTTP.BEGIN_REQUEST( url => v_url, method => 'GET' );
UTL_HTTP.SET_BODY_CHARSET(req, 'UTF-8');
UTL_HTTP.SET_HEADER(req, 'Content-Type', 'text/html');
resp := UTL_HTTP.GET_RESPONSE( req );
LOOP
UTL_HTTP.READ_LINE( resp, value, TRUE );
--value:=res.data;
v_text := v_text || value;
END LOOP;
UTL_HTTP.END_RESPONSE( resp );
EXCEPTION
WHEN "utl_http.end_of_body" THEN
UTL_HTTP.END_RESPONSE( resp );
WHEN OTHERS THEN
RAISE EXCEPTION '(%)', SQLERRM;
UTL_HTTP.END_RESPONSE(resp);
END;
return v_text;
END;
END;
```

5、删除插件。

```
drop extension plpython3u;
```

6、调用函数。

```
select FN_HTTP_GET('http://172.16.19.135/reviewboard/r/ ');
```

7、重新创建拓展。

```
create extension plpython3u;
```

8、调用函数。

```
select FN_HTTP_GET('http://172.16.19.135/reviewboard/r/ ');
```

#### SET_TRANSFER_TIMEOUT<a id="HTTPSET_TRANSFER_TIMEOUT"></a>

**语法格式**

```
UTL_HTTP.SET_TRANSFER_TIMEOUT(timeout);
```

**参数说明**

timeout：网络传输超时值（以秒为单位）。

#### REQUEST<a id="HTTPREQUEST"></a>

**语法格式**

```
UTL_HTTP.REQUEST(url);
```

**参数说明**

url：请求的url地址。

#### BEGIN_REQUEST<a id="HTTPBEGIN_REQUEST"></a>

**语法格式**

```
UTL_HTTP.BEGIN_REQUEST(r);
```

**参数说明**

r：http请求的URL。

#### SET_HEADER<a id="HTTPSET_HEADER"></a>

**语法格式**

```
UTL_HTTP.SET_HEADER(r,name,value);
```

**参数说明**

- r：http请求。
- name：http的header名称。
- value：http的header值。

#### GET_RESPONSE<a id="HTTPGET_RESPONSE"></a>

**语法格式**

```
UTL_HTTP.GET_RESPONSE(r);
```

**参数说明**

r：http响应。

#### SET_BODY_CHATSET<a id="HTTPSET_BODY_CHATSET"></a>

**语法格式**

```
UTL_HTTP.SET_BODY_CHATSET(r,charset);
```

**参数说明**

- r：http响应。

- charset：正文的字符集。

#### WRITE_TEXT<a id="HTTPWRITE_TEXT"></a>

**语法格式**

```
UTL_HTTP.WRITE_TEXT(r,date);
```

**参数说明**

- r：http请求。
- date：需要在HTTP请求body正文中发送的文本数据。。

#### READ_LINE<a id="HTTPREAD_LINE"></a>

**语法格式**

```
UTL_HTTP.READ_LINE(r,date,crlf);
```

**参数说明**

- r：http响应。
- date：http的body文本。
- crlf：是否删除换行符。

#### END_RESPONSE<a id="HTTPEND_RESPONSE"></a>

**语法格式**

```
UTL_HTTP.END_RESPONSE(r);
```

**参数说明**

r：http响应。

#### END_REQUEST<a id="HTTPEND_REQUEST"></a>

**语法格式**

```
UTL_HTTP.END_REQUEST(r);
```

**参数说明**

r：http请求。

#### GET_DETAILED_SQLERRM<a id="HTTPGET_DETAILED_SQLERRM"></a>

**语法格式**

```
UTL_HTTP.GET_DETAILED_SQLERRM 
RETURN VARCHAR2;
```

###  DBMS_PIPE

**功能描述**

dbms_pipe包用于在同一个实例中，通过一个管道来实现会话内或会话之间的消息传递。该内置包包含以下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
    <td> <a href="#PIPECREATE_PIPE">CREATE_PIPE</a></td>
<td>使用指定的名称显示地创建了一个公有或私有的管道。</td>
</tr>
<tr>
<td> <a href="#PIPENEXT_ITEM_TYPE">NEXT_ITEM_TYPE</a></td>
<td>返回消息缓存中下一个数据成员的数据类型。</td>
</tr>
<tr>
<td><a href="#PIPEPACK_MESSAGE">PACK_MESSAGE</a></td>
<td>在本地缓存中构建消息。</td>
</tr>
<tr>
<td> <a href="#PIPEPURGE">PURGE</a></td>
<td>清除指定的管道中的消息。</td>
</tr>
<tr>
<td>  <a href="#PIPERECEIVE_MESSAGE">RECEIVE_MESSAGE</a></td>
<td>删除指定的管道。</td>
</tr>
<tr>
    <td><a href="#PIPEREMOVE_PIPE">REMOVE_PIPE</a></td>
<td>在本地缓存中构建消息。</td>
</tr>
<tr>
<td><a href="#PIPERESET_BUFFER">RESET_BUFFER</a></td>
<td>清除本地缓存中的内容。</td>
</tr>
<tr>
<td><a href="#PIPESEND_MESSAGE">SEND_MESSAGE</a></td>
<td>从会话的本地消息缓冲区中将一条消息发送到指定的管道中。</td>
</tr>
<tr>
<td><a href="#PIPEUNIQUE_SESSION_NAME">UNIQUE_SESSION_NAME</a></td>
<td>返回当前会话的一个唯一名称。</td>
</tr>
<tr>
<td><a href="#PIPEUNPACK_MESSAGE">UNPACK_MESSAGE</a></td>
<td>从本地缓存中获取消息。</td>
</tr>
<tr>
<td><a href="#PIPELIST_PIPES">LIST_PIPES</a></td>
<td>列出所有管道。</td>
</tr>
<tr>
<td>视图DB_PIPES</td>
<td>用于查询数据库中所有的管道。</td>
</tr>
</table>


**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**兼容性**

完全兼容。

**示例**

- **CREATE_PIPE**

创建公有管道

```
CREATE FUNCTION test_create_pipe() RETURNS VOID AS
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('message');
END;
$$
LANGUAGE plpgsql;
```

创建私有管道

```
CREATE FUNCTION test_create_pipe() RETURNS VOID AS
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('message', 32, true);
END;
$$
LANGUAGE plpgsql;
```

- **NEXT_ITEM_TYPE**

```
--会话1
CREATE FUNCTION test_next_item_type() RETURNS VOID AS
$$
DECLARE
    v_number NUMBER :=123;
    v_varchar TEXT:= 'Character data';
    status INTEGER;
BEGIN
    dbms_pipe.pack_message(v_number);
    dbms_pipe.pack_message(v_varchar);
    status := dbms_pipe.send_message('datatypes');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
--会话2
CREATE FUNCTION test_next_item_type() RETURNS VOID AS
$$
DECLARE
    v_number NUMBER;
    v_varchar TEXT;
    status INTEGER;
BEGIN
    status := dbms_pipe.receive_message('datatypes');
    dbms_output.put_line('receive_message status:' || status);
    --number item
    status := dbms_pipe.next_item_type();
    dbms_output.put_line('next_item_type:' || status);
    v_number := dbms_pipe.unpack_message_number();
    dbms_output.put_line('number item:' || v_number);
    --varchar item
    status := dbms_pipe.next_item_type();
    dbms_output.put_line('next_item_type:' || status);
    v_varchar := dbms_pipe.unpack_message_text();
    dbms_output.put_line('varchar item:' || v_varchar);
    --no data
    status := dbms_pipe.next_item_type();
    dbms_output.put_line('next_item_type:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **PACK_MESSAGE**

```
CREATE FUNCTION test_pack_message() RETURNS VOID AS
$$
DECLARE
    v_number NUMBER :=123;
    v_varchar TEXT:= 'Character data';
    status INTEGER;
BEGIN
    dbms_pipe.pack_message(v_number);
    dbms_pipe.pack_message(v_varchar);
    status := dbms_pipe.send_message('datatypes');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **PURGE**

```
--会话1
CREATE FUNCTION test_purge() RETURNS VOID AS
$$
DECLARE
    status INTEGER;
BEGIN
    dbms_pipe.pack_message('message 1');
    status := dbms_pipe.send_message('pipe');
    dbms_output.put_line('send_message status:' || status);

    dbms_pipe.pack_message('message 2');
    status := dbms_pipe.send_message('pipe');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
--会话2
CREATE FUNCTION test_purge() RETURNS VOID AS
$$
DECLARE
    v_item TEXT;
    status INTEGER;
BEGIN
    status := dbms_pipe.receive_message('pipe', 1);
    dbms_output.put_line('receive_message status:' || status);
    v_item := dbms_pipe.unpack_message_text();
    dbms_output.put_line('Item:' || status);
END;
$$
LANGUAGE plpgsql;
--删除管道中的剩余的message 2
SELECT dbms_pipe.purge('pipe');
```

- **RECEIVE_MESSAGE**

```
--会话1
CREATE FUNCTION test_receive_message() RETURNS VOID AS
$$
DECLARE
    status INTEGER;
BEGIN
    dbms_pipe.pack_message('message');
    status := dbms_pipe.send_message('pipe');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
--会话2
CREATE FUNCTION test_receive_message() RETURNS VOID AS
$$
DECLARE
    v_item TEXT;
    status INTEGER;
BEGIN
    status := dbms_pipe.receive_message('pipe', 1);
    dbms_output.put_line('receive_message status:' || status);
    v_item := dbms_pipe.unpack_message_text();
    dbms_output.put_line('Item:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **REMOVE_PIPE**

```
--会话1
CREATE FUNCTION test_remove_pipe() RETURNS VOID AS
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('pipe');

    dbms_pipe.pack_message('message 1');
    status := dbms_pipe.send_message('pipe');
dbms_output.put_line('send_message status:' || status);

    dbms_pipe.pack_message('message 2');
    status := dbms_pipe.send_message('pipe');
dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
--会话2
CREATE FUNCTION test_remove_pipe() RETURNS VOID AS
$$
DECLARE
    v_item TEXT;
    status INTEGER;
BEGIN
    status := dbms_pipe.receive_message('pipe', 1);
    dbms_output.put_line('receive_message status:' || status);
    v_item := dbms_pipe.unpack_message_text();
    dbms_output.put_line('Item:' || status);
$$
LANGUAGE plpgsql;
--删除管道，包括剩余的message 2
SELECT dbms_pipe.remove_pipe('pipe');
```

- **RESET_BUFFER**

```
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('pipe');

    dbms_pipe.reset_buffer();

    dbms_pipe.pack_message('message');
    status := dbms_pipe.send_message('pipe');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **SEND_MESSAGE**

```
CREATE FUNCTION test_send_message() RETURNS VOID AS
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('pipe');

    dbms_pipe.pack_message('message');
    status := dbms_pipe.send_message('pipe');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **UNIQUE_SESSION_NAME**

```
CREATE FUNCTION test_unique_session_name() RETURNS VOID AS
$$
DECLARE
    v_session TEXT;
BEGIN
    v_session := dbms_pipe.unique_session_name();
    dbms_output.put_line('unique_session_name:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **UNPACK_MESSAGE**

```
--会话1
CREATE FUNCTION test_unpack_message() RETURNS VOID AS
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('pipe');

    dbms_pipe.pack_message('message');
    status := dbms_pipe.send_message('pipe');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;
--会话2
CREATE FUNCTION test_unpack_message() RETURNS VOID AS
$$
DECLARE
    v_item TEXT;
    status INTEGER;
BEGIN
    status := dbms_pipe.receive_message('pipe', 1);
    dbms_output.put_line('receive_message status:' || status);
    v_item := dbms_pipe.unpack_message_text();
    dbms_output.put_line('Item:' || status);
END;
$$
LANGUAGE plpgsql;
```

- **LIST_PIPES**

```
CREATE FUNCTION test_list_pipes() RETURNS VOID AS
$$
BEGIN
    PERFORM dbms_pipe.create_pipe('pipe1');

    dbms_pipe.pack_message('message');
    status := dbms_pipe.send_message('pipe2');
    dbms_output.put_line('send_message status:' || status);
END;
$$
LANGUAGE plpgsql;

--查询所有管道信息
SELECT name, items, "limit", private, owner 
FROM dbms_pipe.list_pipes() 
AS (name varchar, items integer, size integer, "limit" integer, private bool, owner varchar);
```

- **视图DB_PIPES**

```
select * from dbms_pipe.db_pipes;
```

#### CREATE_PIPE<a id="PIPECREATE_PIPE"></a>

**语法格式**

```
DBMS_PIPE.CREATE_PIPE (
   pipename     IN VARCHAR2,
   maxpipesize  IN INTEGER DEFAULT 8192,
   private      IN BOOLEAN DEFAULT TRUE)
RETURN INTEGER;
```

**参数说明**

- pipename： 你创建的管道名称。
- maxpipesize：   管道允许的最大大小，以字节为单位。
- private ：使用默认值TRUE创建私有管道。调用时可以隐式创建公共管道SEND_MESSAGE。

#### NEXT_ITEM_TYPE<a id="PIPENEXT_ITEM_TYPE"></a>

**语法格式**

```
DBMS_PIPE.NEXT_ITEM_TYPE 
  RETURN INTEGER;
```

#### PACK_MESSAGE<a id="PIPEPACK_MESSAGE"></a>

**语法格式**

```
DBMS_PIPE.PACK_MESSAGE (
item  IN  VARCHAR2|NCHAR|
NUMBER|DATE|RAW|ROWID);
```

**参数说明**

item：要打包到本地消息缓冲区的项目。

#### PURGE<a id="PIPEPURGE"></a>

**语法格式**

```
DBMS_PIPE.PURGE (
   pipename  IN  VARCHAR2);
```

**参数说明**

pipename： 要删除消息的管道名称。

#### RECEIVE_MESSAGE<a id="PIPERECEIVE_MESSAGE"></a>

**语法格式**

```
DBMS_PIPE.RECEIVE_MESSAGE (
   pipename     IN VARCHAR2,
   timeout      IN INTEGER      DEFAULT maxwait)
RETURN INTEGER;
```

**参数说明**

- pipename： 接收消息的管道名称。
- timeout：等待消息的时间，以秒为单位。

#### UNIQUE_SESSION_NAME<a id="PIPEUNIQUE_SESSION_NAME"></a>

**语法格式**

```
DBMS_PIPE.UNIQUE_SESSION_NAME 
  RETURN VARCHAR2;
```

#### UNPACK_MESSAGE<a id="PIPEUNPACK_MESSAGE"></a>

**语法格式**

```
DBMS_PIPE.UNPACK_MESSAGE (
item  OUT  VARCHAR2|NCHAR|NUMBER|DATE|RAW|ROWID);
```

**参数说明**

item：从本地消息缓冲区接收下一个解包项目的参数

#### LIST_PIPES<a id="PIPELIST_PIPES"></a>

**语法格式**

```
DBMS_PIPE.LIST_PIPES() ;
```

### DBMS_LOB

**功能描述**

DBMS_LOB用于提供一组对blob（二进制数据类型）、clob（字符数据类型）和bfile数据类型（存储数据库外的大型对象，指向操作系统物理文件）操作的函数或过程。该内置包支持一下函数：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
 <td><a href="#LOBGETLENGTH">GETLENGTH</a></td>
<td>获取blob、clob和bfile数据类型的长度。</td>
</tr>
<tr>
<td><a href="#LOBFILEOPEN">FILEOPEN</a></td>
<td>打开一个bfile文件。</td>
</tr>
<tr>
<td><a href="#LOBREAD">READ</a></td>
<td>从一个bfile文件中读取指定长度的内容。</td>
</tr>
<tr>
<td><a href="#LOBFILECLOSE">FILECLOSE</a></td>
<td>关闭一个bfile文件。</td>
</tr>
</table>


**注意事项**

无。

**示例**

1、操作系统环境下创建文件，并输入数据。

```
 vi /home/vastbase/bfile.data
 cat /home/vastbase/bfile.data
```

文件内容为：

```
张三
李四
```

2、在数据库中执行如下命令创建目录和表。

```
drop directory d_bfile;
drop table t_bfile;
create directory d_bfile as '/home/vastbase';
create table testbfile1(id number,bfile_name bfile);
```

3、调用bfilename函数构造bfile数据并插入到表中。

```
insert into testbfile1 values(1,bfilename('d_bfile', 'bfile.data'));
set serveroutput on;
```

创建函数：

```
create or replace function f_read_bfile() returns void as $$
declare
buff raw;
amount int := 0 ;
offset int :=0;
lob_loc bfile;
filesize int;
begin
select bfile_name into lob_loc from testbfile1 where id=1;
--打开BFILE文件
dbms_lob.fileopen(lob_loc,0);
--获取文件大小
filesize := dbms_lob.getlength(lob_loc);
raise notice 'amount:%',amount;
--读取文件全部内容
amount = filesize;
dbms_lob.read(lob_loc,amount,0,buff);
dbms_output.put_line('file data:');
dbms_output.put_line(utl_raw.cast_to_varchar2(buff));
--关闭bfile文件
dbms_lob.fileclose(lob_loc);
return;
end;
$$ language plpgsql;
```

4、调用函数。

```
select f_read_bfile();
```

返回结果为：

```
file data:
张三
李四

 f_read_bfile
--------------

(1 row)
```

#### GETLENGTH<a id="LOBGETLENGTH"></a>

**语法格式**

BLOB对象类型：由于存储的内容即为二进制数据，直接返回二进制内容的字节数即可，函数原型为：

```
DBMS_LOB.GETLENGTH (
   lob_loc    IN  BLOB) 
  RETURN INTEGER;
```

CLOB对象类型：该对象存储的数据格式为字符数据，返回值为字符数。函数原型为：

```
DBMS_LOB.GETLENGTH (
lob_loc    IN  CLOB) 
RETURN INTEGER; 
```

BFILE对象类型：函数返回bfile数据指向的操作系统物理文件的长度，以字节为单位，bfile文件的长度包含了文件结尾符（eof）。函数原型为：

```
DBMS_LOB.GETLENGTH (
 file_loc   IN  BFILE) 
 RETURN INT8;
```

**参数说明**

file_loc：将要返回其长度的文件位置。

**示例**

示例一：

1、创建测试表并插入数据。

```
create table testclob (data clob);
insert into testclob values('中文测试');
```

2、查询数据长度。

```
select dbms_lob. getlength (data) from testclob;
```

返回结果为：

```
 getlength
-----------
         4
(1 row)
```

示例二：

1、创建测试表并插入数据。

```
create table testblob (data blob);
insert into testblob values(utl_raw.cast_to_raw('中文测试'));
```

2、查询数据长度。

```
select dbms_lob. getlength (data) from testblob;
```

返回结果为：

```
 getlength
-----------
        12
(1 row)
```




#### FILEOPEN<a id="LOBFILEOPEN"></a>

**语法格式**

```
DBMS_LOB.FILEOPEN (
file_loc   IN OUT BFILE, 
open_mode  IN   BINARY_INTEGER ); 
```

**参数说明**

- file_loc：要打开的文件定位。

- open_mode：文件访问模式。

#### READ<a id="LOBREAD"></a>

**语法格式**

```
DBMS_LOB.READ (
   file_loc   IN             BFILE,
   amount    IN OUT   INTEGER,
   offset    IN              INTEGER,
   buffer    OUT             RAW);
```

**参数说明**

- file_loc：lob要检查的文件。
- amount：读取文件的长度。为了防止打开的文件过大，单次读取的内容超过机器缓冲区导致系统崩溃，规定单次读取的字节数不能大于32767字节，即amount为大于0小于等于32767的正整数。
- offset：用于多次读取文件时设置读取的起始位置，如果offset参数指向bfile文件结尾或超出文件结尾，则将amount参数设置为0，并抛出异常。
- buffer：读取操作的输出缓冲区。

#### FILECLOSE<a id="FILECLOSE"></a>

**语法格式**

```
DBMS_LOB.FILECLOSE (
    file_loc IN OUT BFILE); 
```

**参数说明**

file_loc：要关闭的文件。

### DBMS_XMLDOM

**功能描述**

dbms_xmldom包用于访问xmltype对象，并实现文档对象模型（DOM）,是用于xml和HTML文档的应用程序编程接口（API）。

DOM把xml文档当成树结构来查看，通过DOM树能访问、修改、删除文档中所有元素以及创建新的元素并插入树中，这些元素、文本以及它们的属性都被认为是节点，这些节点之间是一个继承层次结构。继承层次结构如下图所示：

<div ><img src="image/DOM继承层次结构.png" style="zoom:150%" )</div>

**节点类型**

- DOMNode类型：即Node节点。代表xml文档树中一个单独的节点，可以是其他任何一种节点。

- DOMAttr类型：即Attr节点。表示Element节点中的属性。

- DOMElement类型：即Element节点，代表xml文档中的一个元素。元素可以包含属性，其他元素或文本。

- DOMText类型：即Text节点。表示元素或属性的文本内容。

- DOMCDATASection类型：即CDATASection节点。表示xml文档中的CDATA区段，CDATA区段时一段不会被解析器解析的文本。

- DOMComment类型：即Comment节点。表示xml文档中注释节点的内容。

- DOMEntity类型：即Entity节点。在xml文档中频繁使用某一条数据时，可以预定义一个这条数据的“别名”，即一个Entity，然后在文档中需要的地方进行调用。

- DOMDocument类型：即Documnet节点。代表整个xml文档，是文档树的根，并提供了对文档数据访问的顶层入口。

- DOMDocumentFragment类型：即DocumentFragment节点。文档中的一部分，表示一个或多个邻接的Document节点和它们的所有子孙节点。DocumentFragment节点不属于文档树。

- DOMNotation类型：即Notation元素。Notation元素描述xml文档中非xml数据的格式。

- DOMDocumentType类型：即DocumentType节点。每个xml文档均有一个DOCTYPE属性，此属性的值可谓空，也可以是一个DocumentType对象。DocumentType对象为xml定义的实体提供接口。

- DOMProcessingInstruction类型：即ProcessingInstruction节点。表示xml文档中的一个处理指令。

- DOMText类型：即DOMText节点。XML文档中的文本。

该内置包包含以下函数：

| 函数                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [dbms_xmldom.makeNode](#DOMmakeNode)                         | 将其他节点类型转换成DOMNode类型，以便调用DOMNode的方法。     |
| [dbms_xmldom.isNull](#DOMisNull)                             | 检查输入的对象是否为空，为空则返回true，否则返回false。      |
| [dbms_xmldom.freeNode](#DOMfreeNode)                         | 释放与DOMNode关联的所有资源。                                |
| [dbms_xmldom.freeNodeList](#DOMfreeNodeList)                 | 释放与节点列表关联的所有资源。                               |
| [dbms_xmldom.freeDocument](#DOMfreeDocument)                 | 释放一个DOMDocument对象的所有资源。                          |
| [dbms_xmldom.getFirstChild](#DOMgetFirstChild)               | 返回此节点的第一个子节点，如果没有则返回NULL。               |
| [dbms_xmldom.getLocalName](#DOMgetLocalName)                 | 返回节点名称的本地部分。                                     |
| [dbms_xmldom.getNodeType](#DOMgetNodeType)                   | 返回节点类型。                                               |
| [dbms_xmldom.writeToClob](#DOMwriteToClob)                   | 使用数据库字符集将xml节点或xml文档写入指定的clob。           |
| [dbms_xmldom.writeToBuffer](#DOMwriteToBuffer)               | 使用数据库字符集将xml节点或xml文档写入指定的缓冲区。         |
| [dbms_xmldom.getChildNodes](#DOMgetChildNodes)               | 返回当前节点的所有子节点。                                   |
| [dbms_xmldom.getLength](#DOMgetLength)                       | 返回当前对象的长度。                                         |
| [dbms_xmldom.item](#DOMitem)                                 | 返回节点列表或DOMNamedNodeMap无序列表中index参数对应的项。如果index大于或等于列表中的节点数，则返回空。 |
| [dbms_xmldom.makeElement](#DOMmakeElement)                   | 将DOMNode节点转换成DOMElement节点类型。该函数主要用于将DOMElement节点转换成的DOMNode转换回DOMElement，因此除了节点类型为ELEMENT_NODE的节点，其他节点类型不能调用该函数。 |
| [dbms_xmldom.getElementsByTagName](#DOMgetElementsByTagName) | 返回包含指定名称的所有DOMElement的DOMNodeList。              |
| [dbms_xmldom.cloneNode](#DOMcloneNode)                       | 返回此节点的副本，并用作节点的通用复制构造函数。拷贝的节点没有父节点，父节点为空。 |
| [dbms_xmldom.getNodeName](#DOMgetNodeName)                   | 返回节点的节点名称。                                         |
| [dbms_xmldom.createDocument](#DOMcreateDocument)             | 通过制定的命名空间URI、根元素名和doctype创建一个xml文档。    |
| [dbms_xmldom.createElement](#DOMcreateElement)               | 用于创建一个DOMElement节点。                                 |
| [dbms_xmldom.createDocumentFragment](#DOMcreateDocumentFragment) | 用于创建一个DOMDocumentFragment节点。                        |
| [dbms_xmldom.createTextNode](#DOMcreateTextNode)             | 用于创建一个DOMText节点。                                    |
| [dbms_xmldom.createComment](#DOMcreateComment)               | 用于创建一个DOMComment节点。                                 |
| [dbms_xmldom.createCDATASection](#DOMcreateCDATASection)     | 用于创建一个DOMCDATASection节点。                            |
| [dbms_xmldom.createProcessingInstruction](#DOMcreateProcessingInstruction) | 用于创建一个DOMProcessingInstruction节点。                   |
| [dbms_xmldom.createAttribute](#DOMcreateAttribute)           | 用于创建一个DOMAttr节点。                                    |
| [dbms_xmldom.appendChild](#DOMappendChild)                   | 用于将节点newchild添加到该节点的子节点列表的末尾，并返回新添加的节点。如果newchild已经在树中，则先删除。 |
| [dbms_xmldom.getDocumentElement](#DOMgetDocumentElement)     | 用于返回xml文档的根元素节点。                                |
| [dbms_xmldom.setAttribute](#DOMsetAttribute)                 | 用于通过名称设置DOMElement属性的值。                         |
| [dbms_xmldom.setAttributeNode](#DOMsetAttributeNode)         | 用于向DOMElement添加一个新的属性节点。                       |
| [dbms_xmldom.getAttributes](#DOMgetAttributes)               | 用于检索包含此节点属性的NamedNodeMap，只有DOMElement包含该属性，其他节点则返回空。 |
| [dbms_xmldom.getNodeValue](#DOMgetNodeValue)                 | 根据节点的类型获取该节点的值。                               |
| [dbms_xmldom.getNodeValueAsClob](#DOMgetNodeValueAsClob)     | 根据节点的类型获取该节点的值并写入clob中。                   |
| [dbms_xmldom.getChildrenByTagName](#DOMgetChildrenByTagName) | 用于根据指定的名称返回DOMELement的子节点。                   |
| [dbms_xmldom.getOwnerDocument](#DOMgetOwnerDocument)         | 用于检索与此节点关联的Document对象。                         |
| [dbms_xmldom.newDOMDocument](#DOMnewDOMDocument)             | 返回一个新DOMDocument实例。                                  |
| [dbms_xmldom.hasChildNodes](#DOMhasChildNodes)               | 数返回该节点是否有子节点。                                   |
| [dbms_xmldom.insertBefore](#DOMinsertBefore)                 | 用于将节点newchild插入到现有的子节点refchild之前。           |
| [dbms_xmldom.setVersion](#DOMsetVersion)                     | 用于设置xml文档的版本号。                                    |

**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

- 系统已经安装python3。

- 创建plpython3u插件，需设置环境变量PYTHONHOME，包括以下内容（重启数据库生效）：

  - PYTHONHOME：python3安装路径。

  - LD_LIBRARY_PATH：增加python3安装路径下的lib目录。

  - PATH：增加python3安装路径bin目录。

#### dbms_xmldom.makeNode<a id="DOMmakeNode"></a>

**语法格式**

```
makeNode(t dbms_xmldom.DOMText)
makeNode(com dbms_xmldom.DOMComment)
makeNode(cds dbms_xmldom.DOMCDATASection)
makeNode(dt dbms_xmldom.DOMDocumentType)
makeNode(n dbms_xmldom.DOMNotation)
makeNode(ent dbms_xmldom.DOMEntity)
makeNode(pi dbms_xmldom.DOMProcessingInstruction)
makeNode(df dbms_xmldom.DOMDocumentFragment)
makeNode(doc dbms_xmldom.DOMDocument)
makeNode(elem dbms_xmldom.DOMElement)
```

**参数说明**

- t：待转换的DOMText对象

- com：待转换的DOMComment对象

- cds：待转换的DOMCDATASection对象

- dt：待转换的DOMDocumentType对象
- n：待转换的DOMNotation对象
- ent：待转换的DOMEntity对象
- pi：待转换的DOMProcessingInstruction对象
- df：待转换的DOMDocumentFragment对象
- doc：待转换的DOMDocument对象
- elem：待转换的DOMElement

#### dbms_xmldom.isNull<a id="DOMisNull"></a>

**语法格式**

```
isNull(n dbms_xmldom.DOMNode)
isNull(di dbms_xmldom.DOMImplementation)
isNull(nl dbms_xmldom.DOMNodeList)
isNull(nnm dbms_xmldom.DOMNamedNodeMap)
isNull(cd dbms_xmldom.DOMCharacterData)
isNull(a dbms_xmldom.DOMAttr)
isNull(elem dbms_xmldom.DOMElement)
isNull(t dbms_xmldom.DOMText)
isNull(com dbms_xmldom.DOMComment)
isNull(cds dbms_xmldom.DOMCDATASection)
isNull(dt dbms_xmldom.DOMDocumentType)
isNull(n dbms_xmldom.DOMNotation)
isNull(ent dbms_xmldom.DOMEntity)
isNull(pi dbms_xmldom.DOMProcessingInstruction)
isNull(df dbms_xmldom.DOMDocumentFragment)
isNull(doc dbms_xmldom.DOMDocument)
```

#### dbms_xmldom.freeNode<a id="DOMfreeNode"></a>

**语法格式**

```
freeNode(n dbms_xmldom.DOMnode)
```

**参数说明**

nl：待释放的节点列表。

#### dbms_xmldom.freeDocument<a id="DOMfreeDocument"></a>

**语法格式**

```
freeDocument(doc dbms_xmldom.DOMDocument)
```

**参数说明**

doc：待释放的DOMDocument节点

#### dbms_xmldom.getFirstChild<a id="DOMgetFirstChild"></a>

**语法格式**

```
getFirstChild(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode对象

#### dbms_xmldom.getLocalName<a id="DOMgetLocalName"></a>

**语法格式**

```
getLocalName(a dbms_xmldom.DOMAttr)
getLocalName(elem dbms_xmldom.DOMElement)
getLocalName(n dbms_xmldom.DOMnode, data OUT VARCHAR2)
```

**参数说明**

- a：DOMAtrr对象

- elem：DOMElement对象

- n：DOMNode对象

#### dbms_xmldom.getNodeType<a id="DOMgetNodeType"></a>

**语法格式**

```
getNodeType(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode对象

#### dbms_xmldom.writeToClob<a id="DOMwriteToClob"></a>

**语法格式**

```
writeToClob(n dbms_xmldom.DOMNode, cl IN OUT CLOB)
writeToClob(n dbms_xmldom.DOMNode, cl IN OUT CLOB, pflag IN NUMBER, indent IN NUMBER)
writeToClob(doc dbms_xmldom.DOMDocument, cl IN OUT CLOB)
writeToClob(doc dbms_xmldom.DOMDocument, cl IN OUT CLOB, pflag IN NUMBER, indent IN NUMBER)
```

**参数说明**

- n：DOMNode对象
- cl：指定的clob
- pflag：换行标识。该参数Oracle官方文档无明确说明，经过测试得知取值范围为0-72的整数，所有低三位为4或5的值则表示不换行，其他值则换行。
- indent：缩进长度。该参数Oracle官方文档无明确说明，经过测试得知取值范围为0-12的整数，数值大小表示缩进的空格个数。缩进长度只在pflag为换行时生效。
- doc：xml文档

#### dbms_xmldom.writeToBuffer<a id="DOMwriteToBuffer"></a>

**语法格式**

```
writeToBuffer(n dbms_xmldom.DOMNode, buffer IN OUT VARCHAR2)
writeToBuffer(doc dbms_xmldom.DOMDocument, buffer IN OUT VARCHAR2)
writeToBuffer(df dbms_xmldom.DOMDocumentFragment, buffer IN OUT VARCHAR2)
```

**参数说明**

- n：DOMNode节点对象
- doc：xml文档对象
- df：DOMDocumentFragment对象
- buffer：指定的缓冲区

#### dbms_xmldom.getChildNodes<a id="DOMgetChildNodes"></a>

**语法格式**

```
getChildNodes(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode节点对象

#### dbms_xmldom.getLength<a id="DOMgetLength"></a>

**语法格式**

```
getLength(nl dbms_xmldom.DOMNodeList)
getLength(nnm dbms_xmldom.DOMNamedNodeMap)
getLength(cd dbms_xmldom.DOMCharacterData)
```

**参数说明**

- nl：DOMNodeList对象

- nnm：DOMNamedNodeMap对象

- cd：DOMCharacterData对象

#### dbms_xmldom.item<a id="DOMitem"></a>

**语法格式**

```
item(nl dbms_xmldom.DOMNodeList, idx IN PLS_INTEGER)
item(nnm dbms_xmldom.DOMNamedNodeMap, idx IN PLS_INTEGER)
```

**参数说明**

- nl：节点列表
- nnm：DOMNamedNodeMap无序列表
- idx：在列表中要检索的索引值

#### dbms_xmldom.makeElement<a id="DOMmakeElement"></a>

**语法格式**

```
makeElement(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode对象

#### dbms_xmldom.getElementsByTagName<a id="DOMgetElementsByTagName"></a>

**语法格式**

```
getElementsByTagName(elem dbms_xmldom.DOMElement, name IN VARCHAR2)
getElementsByTagName(elem dbms_xmldom.DOMElement, name IN VARCHAR2, ns varchar2)
getElementsByTagName(doc dbms_xmldom.DOMDocument, tagname IN VARCHAR2)
```

**参数说明**

- elem：DOMElement对象
- name：指定名称
- ns：指定的命名空间
- doc：DOMDocument对象

#### dbms_xmldom.cloneNode<a id="DOMcloneNode"></a>

**语法格式**

```
cloneNode(n dbms_xmldom.DOMNode, deep boolean)
```

**参数说明**

- n：DOMNode对象

- deep：是否拷贝子节点

#### dbms_xmldom.getNodeName<a id="DOMgetNodeName"></a>

**语法格式**

```
getNodeName(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode对象

#### dbms_xmldom.createDocument<a id="DOMcreateDocument"></a>

**语法格式**

```
createDocument(
    namespaceuri IN VARCHAR2, 
    qualifiedname IN VARCHAR2, 
    doctype IN dbms_xmldom.DOMType:= NULL)
```

**语法格式**

- namespaceuri ：命名空间URI
- qualifiedname ：根元素名
- doctype：documentType对象

#### dbms_xmldom.createElement<a id="DOMcreateElement"></a>

**语法格式**

```
createElement(doc dbms_xmldom.DOMDocument, tagname IN VARCHAR2)
createElement(doc dbms_xmldom.DOMDocument, tagname IN VARCHAR2, ns IN VARCHAR2)
```

**参数说明**

- doc：xml文档
- tagname：DOMElement节点的名称
- ns：命名空间URI

#### dbms_xmldom.createDocumentFragment<a id="DOMcreateDocumentFragment"></a>

**语法格式**

```
createDocumentFragment(doc dbms_xmldom.DOMDocument)
```

**参数说明**

doc：xml文档

#### dbms_xmldom.createTextNode<a id="DOMcreateTextNode"></a>

**语法格式**

```
createTextNode(doc dbms_xmldom.DOMDocument, data IN VARCHAR2)
```

**参数说明**

- doc：xml文档

- data：DOMText节点的内容

#### dbms_xmldom.createComment<a id="DOMcreateComment"></a>

**语法格式**

```
createComment(doc dbms_xmldom.DOMDocument, data IN VARCHAR2)
```

**参数说明**

- doc：xml文档
- data：DOMComment节点的内容

#### dbms_xmldom.createCDATASection<a id="DOMcreateCDATASection"></a>

**语法格式**

```
createCDATASection(doc dbms_xmldom.DOMDocument, data IN VARCHAR2)
```

**参数说明**

- doc：xml文档
- data：DOMCDATASection节点的内容

#### dbms_xmldom.createProcessingInstruction<a id="DOMcreateProcessingInstruction"></a>

**语法格式**

```
createProcessingInstruction(doc dbms_xmldom.DOMDocument, target IN VARCHAR2, data IN VARCHAR2)
```

**参数说明**

- doc：xml文档
- target：处理指令的目标
- data：处理指令的内容文本

#### dbms_xmldom.createAttribute<a id="DOMcreateAttribute"></a>

**语法格式**

```
createAttribute(doc dbms_xmldom.DOMDocument, name IN VARCHAR2)
createAttribute(doc dbms_xmldom.DOMDocument, name IN VARCHAR2, ns IN VARCHAR2)
```

**参数说明**

- doc：xml文档

- name：属性的名称
- ns：命名空间URI

#### dbms_xmldom.appendChild<a id="DOMappendChild"></a>

**语法格式**

```
appendChild(n dbms_xmldom.DOMNode, newchild IN dbms_xmldom.DOMNode)
```

**参数说明**

- n：DOMNode节点
- newchild ：待添加的子节点

#### dbms_xmldom.getDocumentElement<a id="DOMgetDocumentElement"></a>

**语法格式**

```
getDocumentElement(doc dbms_xmldom.DOMDocument)
```

**参数说明**

doc：xml文档

#### dbms_xmldom.setAttribute<a id="DOMsetAttribute"></a>

**语法格式**

```
setAttribute(elem dbms_xmldom.DOMElement, name IN VARCHAR2, newvalue IN VARCHAR2)
setAttribute(elem dbms_xmldom.DOMElement, name IN VARCHAR2, newvalue IN VARCHAR2, ns IN VARCHAR2)
```

**参数说明**

- elem：DOMElement节点
- name：属性名
- newvalue：待设置的值
- ns：命名空间URI

#### dbms_xmldom.setAttributeNode<a id="DOMsetAttributeNode"></a>

**语法格式**

```
setAttributeNode(elem dbms_xmldom.DOMElement, newattr IN dbms_xmldom.DOMAttr)
setAttributeNode(elem dbms_xmldom.DOMElement, newattr IN dbms_xmldom.DOMAttr, ns IN VARCHAR2)
```

**参数说明**

- elem：DOMElement节点
- newattr：新的属性节点
- ns：命名空间URI

#### dbms_xmldom.getAttributes<a id="DOMgetAttributes"></a>

**语法格式**

```
getAttributes(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode节点

#### dbms_xmldom.getNodeValueAsClob<a id="DOMgetNodeValueAsClob"></a>

**语法格式**

```
getNodeValueAsClob(n dbms_xmldom.domnode)
```

**参数说明**

n：DOMNode节点

#### dbms_xmldom.getChildrenByTagName<a id="DOMgetChildrenByTagName"></a>

**语法格式**

```
getChildrenByTagName(elem dbms_xmldom.DOMElement, name varchar2)
getChildrenByTagName(elem dbms_xmldom.DOMElement, name varchar2, ns varchar2)
```

**参数说明**

- elem：DOMELement节点
- name：指定的名称

#### dbms_xmldom.getOwnerDocument<a id="DOMgetOwnerDocument"></a>

**语法格式**

```
getOwnerDocument(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode节点

#### dbms_xmldom.newDOMDocument<a id="DOMnewDOMDocument"></a>

**语法格式**

```
newDOMDocument()
newDOMDocument(xmldoc IN xmltype)
newDOMDocument(cl IN clob)
```

**参数说明**

- xmldoc ：DOMDocument的xmltype的源数据
- cl：DOMDocument的clob的源数据

#### dbms_xmldom.hasChildNodes<a id="DOMhasChildNodes"></a>

**语法格式**

```
hasChildNodes(n dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode节点

#### dbms_xmldom.insertBefore<a id="DOMinsertBefore"></a>

**语法格式**

```
insertBefore(
    n dbms_xmldom.DOMNode, 
    newchild IN dbms_xmldom.DOMNode, 
    refchild IN dbms_xmldom.DOMNode)
```

**参数说明**

n：DOMNode节点

newchild ：待插入的新节点

refchild ：现有的子节点

#### dbms_xmldom.setVersion<a id="DOMsetVersion"></a>

**语法格式**

```
setVersion(doc dbms_xmldom.DOMDocument, version VARCHAR2)
```

**参数说明**

- doc：xml文档
- version：待设置的版本号

### DBMS_XMLPARSER

**功能描述**

dbms_xmlparser包用于构造一个解析xml文档的解析器，并提供一系列接口对解析树的结构和内容进行操作和访问。dbms_xmlparser构造的解析树可以被DOM API访问。该内置包包含以下模块：

<table>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
<tr>
<td><a href="#XMLNEWPARSER">NEWPARSER</a></td>
<td>创建解析器。</td>
</tr>
<tr>
<td><a href="#XMLGETDOCUMENT">GETDOCUMENT</a></td>
<td>获取DOM文档。</td>
</tr>
<tr>
<td><a href="#XMLPARSEBUFFER">PARSEBUFFER</a></td>
<td>解析存储在给定缓冲区中的 DTD</td>
</tr>
<tr>
<td><a href="#XMLPARSECLOB">PARSECLOB</a></td>
<td>等待任何已注册的警报出现。</td>
</table>


**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

- 系统已经安装python3。

- 创建plpython3u插件，需设置环境变量PYTHONHOME，包括以下内容（重启数据库生效）：

  - PYTHONHOME：python3安装路径。

  - LD_LIBRARY_PATH：增加python3安装路径下的lib目录。

  - PATH：增加python3安装路径bin目录。

**示例**

1、创建plpython3u插件（需设置环境变量PYTHONHOME）。

```
create extension plpython3u;
```

2、用解析器把XML解析到指定的CLOB对象之中。

```
SET SERVEROUTPUT ON;
DECLARE
var clob;
parser DBMS_XMLPARSER.parser;
BEGIN
var := '<?xml version="1.0"?>
<EMPSET>
<!--comment-->
<![CDATA[cdata]]>
<test>testtext</test>
<EMP num1="1" num2="2">
<EMP_NO>7782</EMP_NO>
<ENAME>CLARK</ENAME> 
</EMP>
<EMP num="2"> 
<EMP_NO>7839</EMP_NO>
<ENAME>KING</ENAME>
</EMP>
<EMP num="3"> 
<EMP_NO>7934</EMP_NO>
<ENAME>MILLER</ENAME>
</EMP>
</EMPSET>';
parser := DBMS_XMLPARSER.newParser;
DBMS_XMLPARSER.parseClob(parser,var);
END;
/
```

#### NEWPARSER<a id="XMLNEWPARSER"></a>

**语法格式**

```
FUNCTION newParser 
RETURN Parser; 
```

#### GETDOCUMENT<a id="XMLGETDOCUMENT"></a>

**语法格式**

```
FUNCTION GETDOCUMENT(
  p Parser)
RETURN DOMDocument; 
```

**参数说明**

- p：解析器实例。

#### PARSEBUFFER<a id="XMLPARSEBUFFER"></a>

**语法格式**

```
PROCEDURE PARSEBUFFER(
  p   Parser,
doc VARCHAR2); 
```

**参数说明**

- p：解析器实例。

- doc：要解析的XML文档缓冲区。

#### PARSECLOB<a id="XMLPARSECLOB"></a>

**语法格式**

```
PROCEDURE PARSECLOB(
  p   Parser,
doc CLOB);  
```

**参数说明**

- p：解析器实例。

- doc：要解析的XML文档缓冲区。

##  oracle视图

关于对应视图的描述如下：

- ALL_视图：显示当前用户可访问的信息。
- DBA_视图：显示整个数据库中所有的信息。
- USER_：当前用户所拥有的信息。

### 静态数据字典视图

#### ALL_ALL_TABLES

ALL_ALL_TABLES视图提供有关当前用户可访问的表的信息。

| 列名                      | 类型                        | 描述                                                         |
| ------------------------- | --------------------------- | ------------------------------------------------------------ |
| owner                     | name                        | 表的所有者                                                   |
| table_name                | name                        | 表名                                                         |
| tablespace_name           | name                        | 表所在的表空间                                               |
| cluster_name              | varchar(128)                | 表所属的集群名称（如果有）                                   |
| iot_name                  | varchar(128)                | 溢出或映射表条目所属的索引组织表的名称（如果有）             |
| status                    | varchar(8)                  | 表示表的状态是可用（VALID）还是不可以用(UNUSABLE)            |
| pct_free                  | numeric                     | 块中可用空间的最小百分比；分区表为 NULL                      |
| pct_used                  | numeric                     | 块中已用空间的最小百分比；分区表为 NULL                      |
| ini_trans                 | numeric                     | 初始交易数量；分区表为 NULL                                  |
| max_trans                 | numeric                     | 最大交易数量；分区表为 NULL                                  |
| initial_extent            | numeric                     | 初始范围的大小（以字节为单位）；分区表为 NULL                |
| next_extent               | numeric                     | 辅助范围的大小（以字节为单位）；分区表为 NULL                |
| min_extents               | numeric                     | 段中允许的最小范围数；分区表为 NULL                          |
| max_extents               | numeric                     | 段中允许的最大范围数；分区表为 NULL                          |
| pct_increase              | numeric                     | 范围大小的百分比增加；分区表为 NULL                          |
| freelists                 | numeric                     | 分配给段的进程空闲列表数；分区表为 NULL                      |
| freelist_groups           | numeric                     | 分配给段的空闲列表组数                                       |
| logging                   | varchar(7)                  | 是否记录对表的更改                                           |
| backed_up                 | varchar(1)                  | 自上次修改后表是否已备份 ( Y) 或未 ( N)                      |
| num_rows                  | numeric                     | 表中的行数                                                   |
| blocks                    | doubleprecision             | 表中使用的块数                                               |
| empty_blocks              | numeric                     | 表中的空（从未使用）块数                                     |
| avg_space                 | numeric                     | 表中的平均可用空间                                           |
| chain_cnt                 | numeric                     | 表中从一个数据块链接到另一个数据块或已迁移到新块的行数，需要一个链接来保留旧的 rowid。此列仅在您分析表后更新。 |
| avg_row_len               | numeric                     | 平均行长度，包括行开销                                       |
| avg_space_freelist_blocks | numeric                     | freelist 上所有块的平均可用空间                              |
| num_freelist_blocks       | numeric                     | freelist 上的块数                                            |
| degree                    | numeric                     | 每个实例用于扫描表的线程数                                   |
| instances                 | numeric                     | 要扫描表的实例数                                             |
| cache                     | varchar(5)                  | 表是否要缓存在缓冲区缓存中 ( Y) 或不 ( N)                    |
| table_lock                | varchar(8)                  | 指示表锁定是启用 ( ENABLED) 还是禁用 ( DISABLED)             |
| sample_size               | numeric                     | 用于分析表格的样本量                                         |
| last_analyzed             | timestamp without time zone | 用于分析表格的样本量                                         |
| partitioned               | character(3)                | 指示表是否已分区 ( YES) 或未分区 ( NO)                       |
| iot_type                  | varchar(12)                 | 如果表是索引组织表，IOT_TYPE则为IOT、IOT_OVERFLOW或IOT_MAPPING。如果表不是索引组织表，IOT_TYPE则为 NULL。 |
| object_id_type            | varchar(16)                 | USER-DEFINED`指示对象 ID ( OID) 是`SYSTEM GENERATED          |
| table_type_owner          | varchar(128)                | 如果是对象表，则创建表的类型的所有者                         |
| table_type                | varchar(128)                | 如果是对象表，则表的类型                                     |
| temporary                 | text                        | 是否为临时表，(Y）是，(N)否                                  |
| secondary                 | character(1)                | 指示表是否是由`ODCIIndexCreate`Oracle Data Cartridge 的方法创建的包含域索引内容的辅助对象 ( `Y`) 或不是 ( `N`) |
| nested                    | varchar(7)                  | 指示表是否为嵌套表 (YES) 或不是 ( NO)                        |
| buffer_pool               | varchar(7)                  | 用于表块的缓冲池                                             |
| flash_cache               | varchar(7)                  | 用于表块的数据库智能闪存缓存提示(仅限 Solaris 和 Oracle Linux 功能。) |
| cell_flash_cache          | varchar(7)                  | 用于表块的单元闪存缓存提示                                   |
| row_movement              | varchar(8)                  | 果是分区表，则指示行移动是启用 ( `ENABLED`) 还是禁用 ( `DISABLED`) |
| global_stats              | varchar(3)                  | 统计信息被收集或增量维护，将是`YES`，否则它将是NO            |
| user_stats                | varchar(3)                  | 统计信息是否由用户直接输入 (YES) 或不是 ( NO)                |
| duration                  | varchar(15)                 | 临时表的持续时间                                             |
| skip_corrupt              | varchar(8)                  | Oracle 数据库在表和索引扫描期间是否忽略标记为损坏的块 ( `ENABLED`) 或引发错误 ( `DISABLED`)。要启用此功能，请运行该`DBMS_REPAIR.skip_corrupt_blocks`过程。 |
| monitoring                | varchar(3)                  | 表是否具有`MONITORING`属性集 (YES) 或没有 ( NO)              |
| cluster_owner             | varchar(128                 | 表所属集群的所有者（如果有）                                 |
| dependencies              | varchar(8)                  | 行级依赖性跟踪是启用 ( `ENABLED`) 还是禁用 ( `DISABLED`)     |
| compression               | varchar(8)                  | 否启用表压缩 ( `ENABLED`) 或不 ( `DISABLED`)；分区表为 NULL  |
| compress_for              | varchar(30)                 |                                                              |
| dropped                   | varchar                     | 是否已被删除并在回收站中（`YES`）或不在（NO）；分区表为 NULL。此视图不返回已删除的表的名称。 |
| segment_created           | varchar(3)                  | 表段是否已创建 (YES) 或未创建 ( NO)                          |
| inmemory                  | varchar(8)                  | 此表的内存中列存储（IM 列存储）是启用 ( `ENABLED`) 还是禁用 ( `DISABLED`) |
| inmemory_priority         | varchar(8)                  | 将此表填充到内存中列存储（IM 列存储）中的优先级              |
| inmemory_distribute       | varchar(15)                 | 表示表将如何分布在 Oracle Real Application Clusters (Oracle RAC) 环境中的 IM 列存储中 |
| inmemory_compression      | varchar(17)                 | 内存存储的压缩级别                                           |
| inmemory_duplicate        | varchar(13)                 | Oracle RAC 环境中 In-Memory Column Store（IM 列存储）的重复设置 |
| external                  | varchar(3)                  | 表是否为外部表 (YES) 或不是 ( NO)                            |
| cellmemory                | varchar(24)                 | 存储单元闪存缓存中的列压缩值                                 |
| inmemory_service          | varchar(12)                 | 如何在各种实例上填充 IM 列存储                               |
| inmemory_service_name     | varchar(1000)               | 应在其上填充 IM 列存储的服务的服务名称                       |

#### ALL_CONS_COLUMNS

ALL_CONS_COLUMNS视图提供有关当前用户可访问的表上约束指定列的信息。

| 列名            | 类型        | 描述               |
| --------------- | ----------- | ------------------ |
| owner           | text        | 约束列的所有者     |
| schema_name     | varchar(64) | 约束所属的模式名   |
| constraint_name | varchar(64) | 约束名称           |
| table_name      | varchar(64) | 定义约束的表名     |
| column_name     | varchar(64) | 定义约束的字段名   |
| position        | smallint    | 列在表中定义的位置 |
| constraint_def  | text        | 约束定义           |

#### ALL_CONSTRAINTS

ALL_CONSTRAINTS视图提供当前用户可访问表上的约束信息。

| 列名                | 类型          | 描述                                                         |
| ------------------- | ------------- | ------------------------------------------------------------ |
| owner               | text          | 约束定义的所有者                                             |
| constraint_name     | varchar(64)   | 约束名字                                                     |
| constraint_type     | text          | c = 检查约束， f = 外键约束， p = 主键约束， u = 唯一约束， t = 约束触发器， x = 排他约束 |
| table_name          | varchar(64)   | 表的名字                                                     |
| search_condition    | text          | 检查约束条件                                                 |
| search_condition_vc | varchar(4000) | 检查约束的搜索条件文本。此列可能会截断搜索条件。             |
| r_owner             | text          | 约束中引用表的所有者                                         |
| r_constraint_name   | text          | 被引用表的唯一约束定义的名称                                 |
| status              | varchar(8)    | 约束的执行状态：ENABLED或者DISABLED                          |
| delete_rule         | text          | 外键删除动作代码： a = 无动作， r = 限制， c = 级联， n = 置空， d = 置为默认值 |
| deferrable          | boolean       | 该约束是否能被延迟                                           |
| deferred            | boolean       | 该约束是否默认被延迟                                         |
| validated           | varchar(13)   | 仅为支持兼容性。                                             |
| generated           | varchar(14)   | 约束的名称是用户生成的 (  USER NAME ) 还是系统生成的 (  GENERATED NAME ) |
| bad                 | varchar(3)    | 此约束是否以不明确的方式 ( ) 指定世纪 BAD (NULL)。           |
| rely                | varchar(4)    | 当 VALIDATED  =  NOT  VALIDATED 时,此列指示是否要在查询重写时考虑约束，当 VALIDATED  =  VALIDATED ，此列没有意义 |
| last_change         | data          | 上次启用或禁用约束的时间                                     |
| index_owner         | varchar(64)   | 索引的所有者                                                 |
| index_name          | varchar(64)   | 索引的名字                                                   |
| invalid             | varchar(7)    | 指示约束是否无效 (  INVALID ) 或无效 (NULL)                  |
| view_related        | varchar(14)   | 指示约束是否依赖于视图 (  DEPEND ON VIEW ) 或不 (NULL)       |
| orgin_con_id        | varcahr(256)  | 数据来源的容器的 ID                                          |

#### ALL_IND_COLUMNS

ALL_IND_COLUMNS视图提供当前用户可访问索引中包含的列信息。

| 列名               | 类型         | 描述                                                         |
| ------------------ | ------------ | ------------------------------------------------------------ |
| index_owner        | varchar(64)  | 索引列的所有者                                               |
| index_name         | varchar(64)  | 索引名称                                                     |
| table_owner        | varchar(64)  | 表的所有者                                                   |
| table_name         | varchar(64)  | 表名                                                         |
| column_name        | name         | 列名                                                         |
| column_position    | smallint     | 列的编号。一般列从1开始向上编号。系统列则拥有（任意）赋值编号 |
| column_length      | smallint     | 对于一个固定尺寸的类型，typlen是该类型内部表示的字节数。对于一个变长类型，typlen为负值。-1表示一个“varlena”类型（具有长度字），-2表示一个以空值结尾的C字符串 |
| char_length        | numeric      | 列的数据类型如果为char，表示字节数。否则为0                  |
| descend            | character(1) | 默认DESC。指示列是按降序（DESC）还是按升序（ASC）排序        |
| collated_column_id | numeric      | 此列为其提供语言排序的列的内部序列号                         |

#### ALL_INDEXES

ALL_INDEXES视图提供当前用户可访问表上的索引信息。

| 列名                    | 类型          | 描述                                                         |
| ----------------------- | ------------- | ------------------------------------------------------------ |
| owner                   | varchar(64)   | 索引的所有者                                                 |
| index_name              | varchar(64)   | 索引名字                                                     |
| index_type              | varchar(27)   | 索引类型，如btree类型                                        |
| table_owner             | text          | 索引对象的所有者                                             |
| table_name              | varchar(64)   | 索引对象的表名                                               |
| table_type              | varchar(11)   | 表的类型                                                     |
| uniqueness              | text          | 索引是唯一的（UNIQUE）还是非唯一的（NONUNIQUE）              |
| compression             | character(1)  | 是否启用索引压缩                                             |
| prefix_length           | numeric       | /                                                            |
| tablespace_name         | text          | 索引所属的表空间名字                                         |
| ini_trans               | numeric       | 初始交易数量                                                 |
| max_trans               | numeric       | 最大交易数                                                   |
| initial_extent          | numeric       | 初始范围的大小                                               |
| next_extent             | numeric       | 次要扩展区的大小                                             |
| min_extents             | numeric       | 段中允许的最小范围数                                         |
| max_extents             | numeric       | 段中允许的最大范围数                                         |
| pct_increase            | numeric       | 扩展区大小增加的百分比                                       |
| pct_threshold           | numeric       | 每个索引条目允许的块空间的阈值百分比                         |
| include_column          | numeric       | 要包含在索引组织表主键（非溢出）索引中的最后一列的列 ID。此列映射到视图 的`COLUMN_ID`列。`*_TAB_COLUMNS` |
| freelists               | numeric       | 分配给该段的进程空闲列表数                                   |
| freelist_groups         | numeric       | 分配给该段的空闲列表组数                                     |
| pct_free                | numeric       | 块中可用空间的最小百分比                                     |
| logging                 | text          | 索引日志是否记录                                             |
| blevel                  | numeric       | B*-树级别（从根块到叶块的索引深度）。深度`0`表示根块和叶块相同。 |
| leaf_blocks             | numeric       | 索引中的叶块数                                               |
| distinct_keys           | numeric       | 不同索引值的数量。对于强制`UNIQUE`和`PRIMARY KEY`约束的索引，此值与表中的行数相同 ( `*_TABLES.NUM_ROWS`) |
| avg_leaf_blocks_per_key | numeric       | 索引中每个不同值出现的平均叶块数，四舍五入到最接近的整数。对于强制`UNIQUE`和`PRIMARY KEY`约束的索引，此值始终为`1`。 |
| avg_data_blocks_per_key | numeric       | 表中由索引中的不同值指向的数据块的平均数，舍入到最接近的整数。此统计数据是包含包含索引列的给定值的行的数据块的平均数量。 |
| clustering_factor       | numeric       | 基于索引值的表中行的顺序量。                                 |
| status                  | text          | 索引是否有效                                                 |
| num_rows                | numeric       | 索引中的行数。                                               |
| sample_size             | numeric       | 用于分析指数的样本大小                                       |
| last_analyzed           | date          | 最近分析该指数的日期                                         |
| degree                  | varchar(40)   | 每个实例用于扫描索引的线程数                                 |
| instances               | varchar(40)   | 要扫描的索引的实例数                                         |
| partitioned             | character(3)  | 索引是否已分区                                               |
| temporary               | character(1)  | 索引是否在临时表上                                           |
| generated               | varchar(1)    | 索引的名称是系统生成的 ( `Y`) 还是不是 ( `N`)                |
| secondary               | character(1)  | 仅为支持兼容性。该值始终为N                                  |
| buffer_pool             | varchar(7)    | 用于索引块的缓冲池                                           |
| flash_cache             | varchar(7)    | 用于索引块的数据库智能闪存缓存提示                           |
| cell_flash_cache        | varchar(7)    | 用于索引块的单元闪存缓存提示                                 |
| user_stats              | varchar(3)    | 指示统计信息是否由用户直接输入 (YES) 或不是 ( NO)            |
| duration                | varchar(15)   | 指示临时表的持续时间                                         |
| pct_direct_access       | numeric       | 对于索引组织表上的二级索引，`VALID`猜测 行的百分比           |
| ityp_owner              | varchar(128)  | 对于域索引，索引类型的所有者                                 |
| ityp_name               | varchar(128)  | 对于域索引，索引类型的名称                                   |
| parameters              | varchar(1000) | 对于域索引，参数字符串                                       |
| global_stats            | varchar(3)    | GLOBAL_STATS`如果统计信息被收集或增量维护，将`YES`是，否则它将是`NO |
| domidx_status           | varchar(12)   | 域索引的状态：                                               |
| domidx_opstatus         | varchar(6)    | 对域索引的操作状态                                           |
| funcidx_status          | varchar(8)    | 基于函数的索引的状态                                         |
| join_index              | character(3)  | 仅为支持兼容性。该值始终为NO                                 |
| iot_redundant_pkey_elim | character(3)  | 是否从索引组织表的二级索引中消除冗余主键列 (YES) 或不 ( NO)  |
| dropped                 | character(3)  | 仅为支持兼容性。该值始终为NO                                 |
| visibility              | varchar(9)    | 索引是优化器`VISIBLE`还是`INVISIBLE`优化器                   |
| domidx_management       | varchar(14)   | 如果这是域索引，则指示域索引是系统管理的 ( `SYSTEM_MANAGED`) 还是用户管理的 ( `USER_MANAGED`) |
| segment_created         | varchar(3)    | 指示索引段是否已创建 (YES) 或未 ( NO)                        |
| orphaned_entries        | varchar(3)    | 指示全局索引是否由于在 DROP/TRUNCATE PARTITION 或 MODIFY PARTITION INDEXING OFF 操作期间延迟索引维护而包含陈旧条目 |
| indexing                | varchar(7)    | 指示全局索引是否与基础表分离。                               |

#### ALL_OBJECTS

ALL_OBJECTS视图提供当前用户可访问数据库中所有对象的信息。

| 列名              | 类型                     | 描述                                                         |
| ----------------- | ------------------------ | ------------------------------------------------------------ |
| owner             | name                     | 对象的所有者                                                 |
| object_name       | name                     | 对象名称                                                     |
| subobject_name    | varchar(128)             | 子对象的名称（例如，分区）                                   |
| object_id         | oid                      | 对象的字典对象编号                                           |
| data_object_id    | numeric                  | 包含对象的段的字典对象编号。                                 |
| object_type       | name                     | 对象的类型（例如INDEX，FUNCTION，PROCEDURE，TABLE，INDEX）   |
| created           | timestamp with time zone | 创建对象的时间戳                                             |
| last_ddl_time     | timestamp with time zone | 由 DDL 语句产生的对象和依赖对象的最后修改的时间戳（包括授权和撤销） |
| timestamp         | varchar(19)              | 对象规范的时间戳（字符数据）                                 |
| status            | varchar(7)               | 仅为支持兼容性，对象的状态始终VALID                          |
| temporary         | varchar(1)               | 指示对象是否是临时对象（当前会话只能看到其自身放置在该对象中的数据）（Y）或（N） |
| generated         | varchar(1)               | 指示此对象的名称是否是系统生成的 ( `Y`) 或不是 ( `N`)        |
| secondary         | varchar(1)               | 指示这是否是由`ODCIIndexCreate`Oracle Data Cartridge         |
| namespace         | oid                      | 对象的命名空间                                               |
| edition_name      | varchar(128)             | 所在的版本名称                                               |
| sharing           | varchar(13)              | 该字段的值可以是：</br>DATA LINK：对象是数据链接的或数据链接到根中的对象</br>METADATA LINK：对象是元数据链接或元数据链接到根中的对象</br>EXTENED DATA LINK：对象是扩展数据链接或扩展数据链接到根中的对象</br>NONE：以上均不适用 |
| editionable       | varchar(1)               | 该字段的值可以是：</br>Y：标记为 EDITIONABLE 的对象</br>N：标记为NONEEDITIONABLE 的对象</br>NULL：在数据库中不可编辑的对象 |
| oracle_maintained | varchar(1)               | 表示对象是否由 Oracle 提供的脚本（例如 catalog.sql 或 catproc.sql）创建和维护。 |
| application       | varchar(1)               | 对象是否为应用程序公共对象 ( `Y`) 或不是 ( `N`)              |
| default_collation | varchar(100)             | 对象的默认排序规则                                           |
| duplicated        | varchar(1)               | 此对象是否在此分片上重复 ( `Y`) 或不 ( `N`)                  |
| sharded           | varchar(1)               | 此对象是否已分片 ( `Y`) 或不 ( `N`)                          |
| created_appid     | numeric                  | 创建对象的应用程序 ID                                        |
| created_vsnid     | numeric                  | 创建对象的应用程序版本的 ID                                  |
| modified_appid    | numeric                  | 上次修改对象的应用程序 ID                                    |
| modified_vsnid    | numeric                  | 上次修改对象的应用程序 ID                                    |

#### ALL_PART_KEY_COLUMNS

ALL_PART_KEY_COLUMNS视图提供当前用户可访问数据库中的分区表的分区键列的信息。

| 列名            | 类型         | 描述                            |
| --------------- | ------------ | ------------------------------- |
| owner           | text         | 分区表的所有者                  |
| schema_name     | text         | 分区表所属的模式名              |
| name            | text         | 分区名称                        |
| object_type     | character(5) | 仅为支持兼容性。该值始终为table |
| column_name     | text         | 字段名                          |
| column_position | integer      | 分区键中列的位置                |

#### ALL_PART_INDEXES

ALL_PART_TABLES视图提供当前用户可访问数据库中的分区表上的索引信息。

| 列名                      | 类型          | 描述                                                         |
| ------------------------- | ------------- | ------------------------------------------------------------ |
| owner                     | varchar(128)  | 分区表索引的所有者                                           |
| index_name                | varchar(128)  | 分区表索引的名称                                             |
| table_name                | varchar(128)  | 分区表索引所属的分区表名称                                   |
| partitioning_type         | varchar(9)    | 分区表的分区策略                                             |
| subpartitioning_type      | varchar(9)    | 复合分区分区策略                                             |
| partition_count           | bigint        | 分区表索引的分区个数                                         |
| def_subpartition_count    | bigint        | 复合分区默认的子分区数量（如果指定的话）                     |
| partitioning_key_count    | integer       | 分区表的分区键个数                                           |
| subpartitioning_key_count | integer       | 对于复合分区索引，子分区键中的列数                           |
| locality                  | varchar(6)    | 指示分区索引是本地（LOCAL）还是全局（GLOBAL）                |
| alignment                 | varchar(12)   | 指示分区索引是带前缀 ( PREFIXED) 还是不带前缀 ( NON_PREFIXED) |
| def_tablespace_name       | name          | 分区表索引的表空间名称                                       |
| def_pct_free              | numeric       | 对于本地索引，`PCTFREE`添加表分区时使用的默认值              |
| def_ini_trans             | numeric       | 对于本地索引，`INITRANS`添加表分区时使用的默认值             |
| def_max_trans             | numeric       | 对于本地索引，`MAXTRANS`添加表分区时使用的默认值             |
| def_initial_extent        | varchar(40)   | 对于本地索引，添加表分区或未指定值时使用的默认值（ `INITIAL`在 Oracle 块中）DEFAULT`INITIAL` |
| def_next_extent           | varchar(40)   | 对于本地索引，添加表分区或未指定值时使用的默认值（ `NEXT`在 Oracle 块中）DEFAULTNEXT |
| def_min_extents           | varchar(40)   | 对于本地索引，MINEXTENTS添加表分区时使用的默认值，或者DEFAULT如果没有MINEXTENTS指定值 |
| def_max_extents           | varchar(40)   | 对于本地索引，`MAXEXTENTS`添加表分区时使用的默认值，或者DEFAULT如果没有`MAXEXTENTS`指定值 |
| def_max_size              | varchar(40)   | 对于本地索引，`MAXSIZE`添加表分区时使用的默认值，或者DEFAULT如果没有`MAXSIZE`指定值 |
| def_pct_increase          | varchar(40)   | 对于本地索引，`PCTINCREASE`添加表分区时使用的默认值，或者`DEFAULT`如果没有`PCTINCREASE`指定值 |
| def_freelists             | numeric       | 对于本地索引，`FREELISTS`添加表分区时使用的默认值            |
| def_freelist_groups       | numeric       | 对于本地索引，`FREELIST GROUPS`添加表分区时使用的默认值      |
| def_logging               | varchar(7)    | 对于本地索引，LOGGING添加表分区时要使用的默认属性            |
| def_buffer_pool           | varchar(7)    | 对于本地索引，添加表分区时要使用的默认缓冲池：DEFAULT,KEEP,RECYCLE,NULL |
| def_flash_cache           | varchar(7)    | 对于本地索引，添加表分区时要使用的默认数据库智能闪存缓存提示：DEFAULT,KEEP,NULL |
| def_cell_flash_cache      | varchar(7)    | 对于本地索引，添加表分区时要使用的默认单元闪存缓存提示：DEFAULT,KEEP,NULL |
| def_parameters            | varchar(1000) | 域索引的默认参数字符串                                       |
| INTERVAL                  | varchar(1000) | 区间值字符串                                                 |
| autolist                  | varchar(3)    | 指示本地索引是否通过自动列表分区 (YES)分区 ( NO)             |
| interval_subpartition     | varchar(1000) | 子分区间隔值的字符串                                         |
| autolist_subpartition     | varchar(3)    | 指示本地索引是否通过自动列表分区 (YES)进行子分区 ( NO)       |

#### ALL_PART_TABLES

ALL_PART_TABLES视图提供当前用户可访问数据库中的分区表信息。

| 列名                      | 类型          | 描述                                                         |
| ------------------------- | ------------- | ------------------------------------------------------------ |
| owner                     | text          | 分区表的所有者                                               |
| table_name                | text          | 分区表名                                                     |
| partitioning_type         | text          | 分区类型： range、list、hash                                 |
| subpartitioning_type      | text          | 子分区类型：range、list、hash                                |
| partition_count           | bigint        | 分区表中的分区数                                             |
| def_subpartition_count    | bigint        | 复合分区表中，子分区数                                       |
| partitioning_key_count    | integer       | 分区键的列数                                                 |
| subpartitioning_key_count | integer       | 复合分区表中，子分区中的列数                                 |
| status                    | varchar(8)    | 仅为支持兼容性。该值始终为VALID                              |
| def_tablespace_name       | varchar(30)   | 仅为支持兼容性。该值始终为NULL                               |
| def_pct_free              | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_pct_used              | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_ini_trans             | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_max_trans             | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_initial_extent        | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_next_extent           | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_min_extents           | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_max_extents           | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_max_size              | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_pct_increase          | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_freelists             | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_freelist_groups       | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_logging               | varchar(7)    | 仅为支持兼容性。该值始终为YES                                |
| def_compression           | varchar(8)    | 仅为支持兼容性。该值始终为None                               |
| def_compress_for          | varchar(30)   | 添加分区时使用哪种操作的默认压缩                             |
| def_buffer_pool           | varchar(7)    | 仅为支持兼容性。该值始终为DEFAULT                            |
| def_flash_cache           | varchar(7)    | 仅为支持兼容性。该值始终为NULL                               |
| def_cell_flash_cache      | varchar(7)    | 仅为支持兼容性。该值始终为NULL                               |
| ref_ptn_constraint_name   | varchar(30)   | 仅为支持兼容性。该值始终为NULL                               |
| interval                  | varchar(1000) | 区间值字符串                                                 |
| autolist                  | varchar(1000) | 指示表是否通过自动列表分区 ( `YES`)分区 ( `NO`)              |
| interval_subpartition     | varchar(1000) | 子分区间隔值的字符串                                         |
| autolist_subpartition     | varchar(1000) | 指示此子 分区是否使用 ( `YES`)自动列表分区 ( )`NO`           |
| is_nested                 | varchar(1000) | 指示分区表是否为嵌套表 ( `YES`) 或不是 ( `NO`)               |
| def_segment_creation      | varchar(1000) | 指定是否在表级别指定了段创建的默认值                         |
| def_indexing              | varchar(1000) | 指示为表指定的索引属性。                                     |
| def_inmemory              | varchar(1000) | 表示内存列存储是否默认启用（ENABLE）,禁用（DISABLED）,或者未指定 (NONE) 此表中的分区 |
| def_inmemory_priority     | varchar(1000) | 内存列存储填充的默认优先级                                   |
| def_inmemory_distribute   | varchar(1000) | Oracle RAC)环境中默认情况下如何为表的分区分配 内存列存储     |
| def_inmemory_compression  | varchar(1000) | 内存列存储的默认压缩级别                                     |
| def_inmemory_duplicate    | varchar(1000) | Oracle RAC 环境中内存列存储的默认重复设置                    |
| def_read_only             | varchar(1000) | 新分区的默认设置：YES(只读)，NO（读/写）                     |
| def_cellmemory            | varchar(1000) | 显示父表中的新分区将继承的属性的默认值，`CELLMEMORY`除非该行为被显式覆盖 |
| def_inmemory_service      | varchar(1000) | 默认情况下如何在各种实例上为表的分区填充内存列存储           |
| def_inmemory_service_name | varchar(1000) | 默认情况下应为表的分区填充内存列存储的服务的服务名称。       |

#### ALL_SEQUENCES

ALL_SEQUENCES视图提供当前用户可访问数据库用户定义的序列信息。

| 列名           | 类型         | 描述                                                         |
| -------------- | ------------ | ------------------------------------------------------------ |
| sequence_owner | name         | 序列的所有者                                                 |
| sequence_name  | name         | 序列名字                                                     |
| min_value      | int16        | 序列的最小值                                                 |
| max_value      | int16        | 序列的最大值                                                 |
| increment_by   | int16        | 序列递增值                                                   |
| cycle_flag     | character(1) | 序列达到最大值是否循环                                       |
| cache_size     | numeric      | 在内存中预分配的序列号数目                                   |
| last_number    | numeric      | 上次保存到磁盘的序列号的值                                   |
| scale_flag     | varchar(1)   | 指示这是否是可伸缩序列 ( Y) 或不是 ( N)                      |
| extend_flag    | varchar(1)   | 指示此可伸缩序列的生成值是否超出MAX_VALUE或MIN_VALUE( Y) 或不 ( N) |
| session_flag   | varchar(1)   | 指示序列值是会话私有 ( Y) 还是不是 ( N)                      |
| keep_value     | varchar(1)   | 指示在失败后重放期间是否保留序列值 ( Y) 或不 ( N)            |

#### ALL_SUBPART_KEY_COLUMNS

ALL_SUBPART_KEY_COLUMNS视图提供当前用户可访问数据库分区表的子分区的关键列的信息。

| 列名            | 类型         | 描述                            |
| --------------- | ------------ | ------------------------------- |
| owner           | text         | 分区表的所有者                  |
| schema_name     | text         | 分区表所属模式名                |
| name            | text         | 字段所在的表名                  |
| object_type     | character(5) | 仅为支持兼容性。该值始终为TABLE |
| column_name     | text         | 分区键的列名                    |
| column_position | integer      | 列所在分区键的位置              |

#### ALL_TAB_COLUMNS

ALL_TAB_COLUMNS视图提供当前用户可访问表和视图中所有列的信息。

| 列名                 | 类型                        | 描述                                                         |
| -------------------- | --------------------------- | ------------------------------------------------------------ |
| owner                | varchar(64)                 | 字段所在表或视图的所有者                                     |
| table_name           | varchar(64)                 | 表名                                                         |
| column_name          | varchar(64)                 | 列名                                                         |
| data_type            | varchar(128)                | 列的数据类型                                                 |
| data_type_mod        | varchar(3)                  | 列的数据类型修饰符                                           |
| data_type_owner      | varchar(64)                 | 列数据类型的所有者                                           |
| data_length          | integer                     | 列的长度（以字节为单位）                                     |
| data_precision       | integer                     | 数据类型的精度                                               |
| data_scale           | integer                     | 数字小数点右边精度                                           |
| nullable             | bpchar                      | 列值是否允许为空                                             |
| column_id            | integer                     | 列在表中的顺序编号                                           |
| default_length       | numeric                     | 列的默认值的长度                                             |
| data_default         | text                        | 列的默认值                                                   |
| num_distinct         | numeric                     | 列中不同值的数量。保留此列是为了与 Oracle7 向后兼容。此信息现在在 {TAB\|PART}_COL_STATISTICS 视图中。 |
| low_value            | raw                         | 列中的低值。保留此列是为了与 Oracle7 向后兼容。此信息现在在 {TAB\|PART}_COL_STATISTICS 视图中。 |
| high_value           | raw                         | 列中的高值。保留此列是为了与 Oracle7 向后兼容。此信息现在在 {TAB\|PART}_COL_STATISTICS 视图中。 |
| density              | numeric                     | /                                                            |
| num_nulls            | numeric                     | 列中的 NULL 数                                               |
| num_buckets          | numeric                     | 列的直方图中的桶数                                           |
| last_analyzed        | timestamp without time zone | 最近分析此列的日期                                           |
| sample_size          | numeric                     | 用于分析此列的样本量                                         |
| character_set_name   | varchar(44)                 | 字符集名称                                                   |
| char_col_decl_length | numeric                     | 字符类型列的声明长度                                         |
| global_stats         | varchar(3)                  | GLOBAL_STATS 如果统计信息被收集或增量维护，将 YES 是，否则它将是 NO |
| user_stats           | varchar(3)                  | 指示统计信息是否由用户直接输入 (  YES ) 或不是 (  NO )       |
| avg_col_len          | numeric                     | 列的平均长度（以字节为单位）                                 |
| char_length          | numeric                     | 以字符显示列的长度。                                         |
| char_used            | varchar(1)                  | 指示该列使用 BYTE 长度语义 (  B ) 或 CHAR 长度语义 (  C )，或者数据类型是否不是以下任何一种 (NULL)：CHAR,VARCHAR2,NCGAR,NVACHAR2 |
| v80_fmt_image        | varchar(3)                  | 指示列数据是否为 8.0 版图像格式 (  YES ) 或不是 (  NO )      |
| data_upgraded        | varchar(3)                  | 指示列数据是否已升级为最新类型版本格式（ YES ）或未升级（ NO ） |
| histogram            | varchar(15)                 | 直方图类型                                                   |
| default_on_null      | varchar(3)                  | 指示列是否具有 DEFAULT ON NULL 语义 (  YES ) 或没有 (  NO )  |
| identity_column      | varchar(3)                  | 指示这是否是标识列 (  YES ) 或不是 (  NO )                   |
| evaluation_edition   | varchar(128)                | 解析表达式列中引用的编辑对象的版本名称                       |
| unusable_before      | varchar(128)                | 列可用的最旧版本的名称                                       |
| unusable_beginning   | varchar(128)                | 列永久不可用的最旧版本的名称                                 |
| collation            | varchar(100)                | 列的排序规则。仅适用于具有字符数据类型的列。                 |

#### ALL_IND_PARTITIONS

ALL_IND_PARTITIONS视图提供当前用户可访问数据库中的索引分区的信息。

| 列名                    | 类型                        | 描述                                                         |
| ----------------------- | --------------------------- | ------------------------------------------------------------ |
| index_owner             | varchar(128)                | 索引分区所属分区表索引的所有者的名称                         |
| index_name              | varchar(128)                | 索引分区所属分区表索引的名称                                 |
| composite               | varchar(3)                  | 索引分区的名称                                               |
| partition_name          | varchar(128)                | 分区名称                                                     |
| subpartition_count      | bigint                      | 如果是复合分区表上的本地索引，则分区中的子分区数             |
| high_value              | text                        | 索引分区所对应分区的上边界                                   |
| high_value_length       | integer                     | 分区界限值表达式的长度                                       |
| partition_position      | numeric                     | 分区在索引中的位置                                           |
| status                  | varchar(8)                  | 指示索引分区是否可用 ( `USABLE`) 或不可用 ( `UNUSABLE`)      |
| tablespace_name         | name                        | 索引分区的表空间名称                                         |
| pct_free                | numeric                     | 块中可用空间的最小百分比                                     |
| ini_trans               | numeric                     | 初始交易数量                                                 |
| max_trans               | numeric                     | 最大交易数                                                   |
| initial_extent          | numeric                     | 初始范围的大小（以字节为单位）                               |
| next_extent             | numeric                     | 扩展区的大小（以字节为单位）                                 |
| min_extent              | numeric                     | 段中允许的最小范围数                                         |
| max_extent              | numeric                     | 段中允许的最大范围数                                         |
| max_size                | numeric                     | 段中允许的最大块数                                           |
| pct_increase            | numeric                     | 扩展区大小增加的百分比                                       |
| freelists               | numeric                     | 此段中分配的进程空闲列表数                                   |
| freelist_groups         | numeric                     | 段中分配的进程空闲列表组数                                   |
| logging                 | varchar(7)                  | 是否记录对索引的更改                                         |
| compression             | varchar(8)                  | 用于分区的压缩类型                                           |
| blevel                  | numeric                     | B*-树级别（从根块到叶块的索引深度）。深度`0`表示根块和叶块相同。 |
| leaf_blocks             | numeric                     | 索引分区中的叶块数                                           |
| distinct_keys           | numeric                     | 索引分区中不同键的数量                                       |
| avg_leaf_blocks_per_key | numeric                     | 索引中每个不同值出现的平均叶块数，四舍五入到最接近的整数。对于强制`UNIQUE`和`PRIMARY KEY`约束的索引，此值始终为`1`。 |
| avg_data_blocks_per_key | numeric                     | 表中由索引中的不同值指向的数据块的平均数，舍入到最接近的整数。此统计数据是包含包含索引列的给定值的行的数据块的平均数量。 |
| clustering_factor       | numeric                     | 基于索引值的表中行的顺序量                                   |
| num_rows                | numeric                     | 返回的行数                                                   |
| sample_size             | numeric                     | 用于分析此分区的样本大小                                     |
| last_analyzed           | timestamp without time zone | 最近分析此分区的日期                                         |
| buffer_pool             | varchar(7)                  | 分区的实际缓冲池                                             |
| flash_cache             | varchar(7)                  | 用于分区块的数据库智能闪存缓存提示                           |
| cell_flash_cache        | varchar(7)                  | 用于分区块的单元闪存缓存提示                                 |
| user_stats              | varchar(3)                  | 指示统计信息是否由用户直接输入 ( `YES`) 或不是 ( `NO`)       |
| pct_direct_access       | numeric                     | 如果索引组织表上的二级索引，则`VALID`猜测 行的百分比         |
| global_stats            | varchar(3)                  | `GLOBAL_STATS表示是否已收集统计信息，或者是否已从子分区汇总统计信息 或尚未收集统计信息 |
| domidx_opstatus         | varchar(6)                  | 索引的操作状态                                               |
| parameters              | varchar(1000)               | 对于域索引，参数字符串                                       |
| interval                | varchar(3)                  | 指示分区是否在区间分区表的区间部分 ( `YES`) 或分区是否在范围部分 ( `NO`) |
| segment_created         | varchar(3)                  | 指示索引分区段是否已创建（`YES`）或未创建（ `NO`）；`N/A`表示这个索引是子分区的，在分区级别不存在段 |
| orphaned_entries        | varchar(3)                  | 指示全局索引是否由于在 DROP/TRUNCATE PARTITION 或 MODIFY PARTITION INDEXING OFF 操作期间延迟索引维护而包含陈旧条目。 |

#### ALL_TAB_PARTITIONS

ALL_TAB_PARTITIONS视图提供当前用户可访问数据库中的所有分区的信息。

| 列名                   | 类型                        | 描述                                                         |
| ---------------------- | --------------------------- | ------------------------------------------------------------ |
| table_owner            | varchar(128)                | 分区表的所有者                                               |
| table_name             | varchar(128)                | 分区表的表名                                                 |
| composite              | text                        | 指示表是复合分区 ( `YES`) 还是不是 ( `NO`)                   |
| partition_name         | varchar(128)                | 分区名称                                                     |
| subpartition_count     | bigint                      | 如果是符合分区，分区中的子分区数量                           |
| high_value             | text                        | 对应分区范围最大值                                           |
| high_value_length      | integer                     | 对应分区范围最大值的字节长度                                 |
| partition_position     | numeric                     | 分区在表中的位置                                             |
| tablespace_name        | text                        | 分区所在表空间名                                             |
| pct_free               | numeric                     | 仅为支持兼容性                                               |
| pct_used               | numeric                     | 仅为支持兼容性                                               |
| ini_trans              | numeric                     | 仅为支持兼容性                                               |
| max_trans              | numeric                     | 仅为支持兼容性                                               |
| initial_extent         | numeric                     | 仅为支持兼容性                                               |
| next_extent            | numeric                     | 仅为支持兼容性                                               |
| min_extent             | numeric                     | 仅为支持兼容性                                               |
| max_extent             | numeric                     | 仅为支持兼容性                                               |
| max_size               | numeric                     | 仅为支持兼容性                                               |
| pct_increase           | numeric                     | 仅为支持兼容性                                               |
| freelists              | numeric                     | 仅为支持兼容性                                               |
| freelist_groups        | numeric                     | 仅为支持兼容性                                               |
| logging                | varchar(7)                  | 是否开启表的logging                                          |
| compression            | varchar(8)                  | 分区是否开启压缩                                             |
| compress_for           | varchar(30)                 | 默认压缩方式                                                 |
| num_rows               | numeric                     | 分区中的数据行数                                             |
| blocks                 | double precision            | 分区中数据块数                                               |
| empty_blocks           | numeric                     | 仅为支持兼容性                                               |
| avg_space              | numeric                     | 仅为支持兼容性                                               |
| chain_cnt              | numeric                     | 仅为支持兼容性                                               |
| avg_row_len            | numeric                     | 仅为支持兼容性                                               |
| sample_size            | numeric                     | 仅为支持兼容性                                               |
| last_analyzed          | timestamp without time zone | 仅为支持兼容性                                               |
| buffer_pool            | varchar(7)                  | 仅为支持兼容性                                               |
| flash_cache            | varchar(7)                  | 用于分区块的数据库智能闪存缓存提示                           |
| cell_flash_cache       | varchar(7)                  | 用于分区块的单元闪存缓存提示                                 |
| global_stats           | varchar(3)                  | 仅为支持兼容性                                               |
| user_stats             | varchar(3)                  | 仅为支持兼容性                                               |
| is_nested              | varchar(7)                  | 指示这是否是嵌套表分区 ( `YES`) 或不是 ( `NO`)               |
| parent_table_partition | varchar(7)                  | 父表对应的分区                                               |
| interval               | varchar(3)                  | 指示分区是否在区间分区表的区间部分 ( `YES`) 或分区是否在范围部分 ( `NO`) |
| segment_created        | varchar(4)                  | 指示简单分区表的分区的实际段创建属性，或复合分区表的子分区的默认值（如果指定），否则`NONE` |
| indexing               | varchar(4)                  | 简单分区表的分区的实际索引属性，或复合分区表的子分区的默认值（如果指定），否则为 NONE |
| read_only              | varchar(4)                  | 分区的默认设置：YES(只读)，NO(读/写)，NONE（没有指定默认设置） |
| inmemory               | varchar(4)                  | 是否为此分区启动内存列存储，ENABLED(启动)，DISABLED（未启动） |
| inmemory_priority      | varchar(4)                  | 内存列存储填充的优先级                                       |
| inmemory_distribute    | varchar(4)                  | 内存列存储在RAC环境中的分布方式                              |
| inmemory_compression   | varchar(4)                  | 内存列存储的压缩级别                                         |
| inmemory_duplicate     | varchar(4)                  | oracle RAC中的内存列存储的重复设置                           |
| cellmemory             | varchar(24)                 | 存储单元闪存缓存中的列压缩值                                 |
| inmemory_service       | varchar(12)                 | 如何在各种实例上填充内存列存储                               |
| inmemory_service_name  | varchar(100)                | 填充的内存列存储的服务名称                                   |

#### ALL_TAB_SUBPARTITIONS

ALL_TAB_SUBPARTITIONS视图提供当前用户可访问数据库中的所有子分区的信息。

| 列名                  | 类型                        | 描述                                                         |
| --------------------- | --------------------------- | ------------------------------------------------------------ |
| table_owner           | text                        | 子分区表的所有者                                             |
| table_name            | text                        | 表名                                                         |
| partition_name        | text                        | 分区名                                                       |
| subpartition_name     | text                        | 子分区名字                                                   |
| high_value            | text                        | 子分区范围最大值                                             |
| high_value_length     | integer                     | 子分区范围最大值的字节长度                                   |
| partition_position    | numeric                     | 分区在表中的位置                                             |
| subpartition_position | numeric                     | 子分区字段所在表中的位置                                     |
| tablespace_name       | text                        | 子分区所在表空间名                                           |
| pct_free              | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| pct_used              | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| ini_trans             | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| max_trans             | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| initial_extent        | numeric                     | 仅为支持兼容性，该值始终为null                               |
| next_extent           | numeric                     | 仅为支持兼容性，该值始终为null                               |
| min_extent            | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| max_extent            | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| max_size              | numeric                     | 段中允许的最大块数                                           |
| pct_increase          | numeric                     | 仅为支持兼容性，该值始终为0                                  |
| freelists             | numeric                     | 仅为支持兼容性，该值始终为null                               |
| freelist_groups       | numeric                     | 仅为支持兼容性，该值始终为null                               |
| logging               | varchar(7)                  | 仅为支持兼容性，该值始终为YES                                |
| compression           | varchar(8)                  | 仅为支持兼容性，该值始终为NONE                               |
| compress_for          | varchar(30)                 | 操作的默认压缩方式                                           |
| num_rows              | numeric                     | 子分区的数据量                                               |
| blocks                | double precision            | 子分区的数据块数                                             |
| empty_blocks          | numeric                     | 仅为支持兼容性，该值始终为null                               |
| avg_space             | numeric                     | 仅为支持兼容性，该值始终为null                               |
| chain_cnt             | numeric                     | 仅为支持兼容性，该值始终为null                               |
| avg_row_len           | numeric                     | 仅为支持兼容性，该值始终为null                               |
| sample_size           | numeric                     | 仅为支持兼容性，该值始终为null                               |
| last_analyzed         | timestamp without time zone | 仅为支持兼容性，该值始终为null                               |
| buffer_pool           | varchar(7)                  | 仅为支持兼容性，该值始终为null                               |
| flash_cache           | varchar(7)                  | 用于子分区块的数据库智能闪存缓存提示                         |
| cell_flash_cache      | varchar(7)                  | 用于子分区块的单元闪存缓存提示                               |
| global_stats          | varchar(3)                  | 仅为支持兼容性，该值始终为YES                                |
| user_stats            | varchar(3)                  | 仅为支持兼容性，该值始终为NO                                 |
| interval              | varchar(3)                  | 指示分区是否在区间分区表的区间部分 ( `YES`) 或分区是否在范围部分 ( `NO`) |
| segment_created       | varchar(4)                  | 指示表子分区段是否已创建（`YES`）或未创建（ `NO`）；`N/A`表示该表没有子分区 |
| indexing              | varchar(4)                  | 指示索引属性。ON(子分区索引开启)，OFF(子分区索引关闭)        |
| read_only             | varchar(4)                  | 指示子分区是只读的还是读/写的：YES(只读)，NO(读/写)          |
| inmemory              | varchar(4)                  | 是否为此子分区启动内存列存储，ENABLED(启动)，DISABLED（未启动） |
| inmemory_priority     | varchar(4)                  | 内存列存储填充的优先级                                       |
| inmemory_distribute   | varchar(4)                  | 内存列存储在oracle RAC中的分布方式                           |
| inmemory_compression  | varchar(4)                  | 内存列存储的压缩级别                                         |
| inmemory_duplicate    | varchar(4)                  | oracle RAC环境中的内存列存储的重复方式设置                   |
| inmemory_service      | varchar(12)                 | 如何在各种实例上填充内存列存储                               |
| inmemory_service_name | varchar(100)                | 内存列存储的服务名称                                         |
| cellmemory            | varchar(24)                 | 存储单元闪存缓存中的列压缩值                                 |

#### ALL_TABLES

ALL_TABLES视图提供当前用户可访问数据库用户定义表的信息。

| 列名                      | 类型                        | 描述                                                         |
| ------------------------- | --------------------------- | ------------------------------------------------------------ |
| owner                     | text                        | 表的所有者                                                   |
| table_name                | text                        | 表名                                                         |
| tablespace_name           | text                        | 表所在的表空间名称；分区表，临时表和索引组织表为NULL         |
| cluster_name              | varchar(128)                | 表所属的集群名称（如果有）                                   |
| iot_name                  | varchar(128)                | 溢出或映射表条目所属的索引组织表的名称（如果有）。如果IOT_TYPE列不为 NULL，则该列包含基表名称。 |
| status                    | varchar(5)                  | 如果之前DROP TABLE操作失败，则表示该表是不可用的（UNUSABLE）或者有效（VALID） |
| pct_free                  | numeric                     | 块中可用空间的最小百分比；分区表为 NULL                      |
| pct_used                  | numeric                     | 块中已用空间的最小百分比；分区表为 NULL                      |
| ini_trans                 | numeric                     | 初始交易数量；分区表为 NULL                                  |
| max_trans                 | numeric                     | 最大交易数量；分区表为 NULL                                  |
| initial_extent            | numeric                     | 初始范围的大小（以字节为单位）；分区表为 NULL                |
| next_extent               | numeric                     | 辅助范围的大小（以字节为单位）；分区表为 NULL                |
| min_extents               | numeric                     | 段中允许的最小范围数；分区表为 NULL                          |
| max_extents               | numeric                     | 段中允许的最大范围数；分区表为 NULL                          |
| pct_increase              | numeric                     | 范围大小的百分比增加；分区表为 NULL                          |
| freelists                 | numeric                     | 分配给段的进程空闲列表数；分区表为 NULL                      |
| freelist_groups           | numeric                     | 分配给段的空闲列表组数；分区表为 NULL                        |
| logging                   | varchar(7)                  | 是否记录对表的更改；分区表为 NULL：                          |
| backed_up                 | varchar(1)                  | 自上次修改后表是否已备份 ( Y) 或未 ( N)                      |
| num_rows                  | numeric                     | 表中的行数                                                   |
| blocks                    | double precision            | 表中使用的数据块数                                           |
| empty_blocks              | numeric                     | 表中空（从未使用过）数据块的数量。                           |
| avg_space                 | numeric                     | 分配给表的数据块中的平均可用空间量（以字节为单位）           |
| chain_cnt                 | numeric                     | 表中从一个数据块链接到另一个数据块或已迁移到新块的行数，需要链接以保留旧 ROWID |
| avg_row_len               | numeric                     | 表中行的平均长度（以字节为单位）                             |
| avg_space_freelist_blocks | numeric                     | freelist 上所有块的平均可用空间                              |
| num_freelist_blocks       | numeric                     | freelist 上的块数                                            |
| degree                    | numeric                     | 每个实例用于扫描表的线程数，或DEFAULT                        |
| instances                 | numeric                     | 要扫描表的实例数，或DEFAULT                                  |
| cache                     | varchar(5)                  | 是否要缓存在缓冲区缓存中 (  Y ) 或不 (  N )                  |
| table_lock                | varchar(8)                  | 表锁定是启用 (  ENABLED) 还是禁用 ( DISABLED)                |
| sample_size               | numeric                     | 用于分析表格的样本量                                         |
| last_analyzed             | timestamp without time zone | 最近分析表格的日期                                           |
| partitioned               | character(3)                | 指示表是否已分区 (  YES ) 或未分区 (  NO )                   |
| iot_type                  | varchar(12)                 | 如果表是索引组织表， IOT_TYPE 则为 IOT 、 IOT_OVERFLOW 或 IOT_MAPPING 。如果表不是索引组织表， IOT_TYPE 则为 NULL。 |
| temporary                 | character(1)                | 是否为临时表: 是(Y)、否(N)                                   |
| secondary                 | character(1)                | 该表是否是由  ODCIIndexCreate Oracle Data Cartridge (  Y ) 的方法创建的辅助对象 (  N ) |
| nested                    | varchar(3)                  | 表是否为嵌套表 (  YES ) 或不是 (  NO )                       |
| buffer_pool               | varchar(7)                  | 表的缓冲池                                                   |
| flash_cache               | varchar(7)                  | 表块的数据库智能闪存缓存提示（仅限 Solaris 和 Oracle Linux 功能。） |
| cell_flash_cache          | varchar(7)                  | 表块的单元闪存缓存提示                                       |
| row_movement              | varchar(8)                  | 分区行移动是启用 (  ENABLED ) 还是禁用 (  DISABLED )         |
| global_stats              | varchar(3)                  | GLOBAL_STATS 如果统计信息被收集或增量维护，将 YES 是，否则它将是 NO |
| user_stats                | varchar(3)                  | 统计信息是否由用户直接输入 (  YES ) 或不是 (  NO )           |
| duration                  | varchar(15)                 | 指示临时表的持续时间： SYS$SESSION - 在会话期间保留行  SYS$TRANSACTION - 行被删除后 COMMIT 。Null - 永久表 |
| skip_corrupt              | varchar(8)                  | 指示 Oracle 数据库在表和索引扫描期间是否忽略标记为损坏的块 (  ENABLED ) 或引发错误 (  DISABLED )。要启用此功能，请运行 DBMS_REPAIR .  SKIP_CORRUPT_BLOCKS 程序。 |
| monitoring                | varchar(3)                  | 此列已过时                                                   |
| cluster_owner             | varchar(128)                | 表所属集群的所有者（如果有）                                 |
| dependencies              | varchar(8)                  | 指示行级依赖性跟踪是启用 (  ENABLED ) 还是禁用 (  DISABLED ) |
| compression               | varchar(8)                  | 指示是否启用表压缩 (  ENABLED ) 或不 (  DISABLED )；分区表为 NULL |
| compress_for              | varchar(30)                 | 默认压缩方式                                                 |
| dropped                   | varchar                     | 指示表是否已被删除并在回收站中（ YES ）或不在（ NO ）；分区表为 NULL。此视图不返回已删除的表的名称。 |
| read_only                 | varchar(3)                  | 表段是否 READ-ONLY 存在。可能的值：YES(表段是READ_ONLY)；NO(表段不是READ_ONLY)；N/A(不适用。此值出现在分区表中，其中没有与逻辑表对象相关的段。)； |
| segment_created           | varchar(3)                  | 指示是否创建表段。可能的值：YES(表段已创建)；NO(表段未创建)；N/A(不适用。此值出现在分区表中，其中没有与逻辑表对象相关的段。)； |
| result_cache              | varchar(7)                  | 表的结果缓存模式注释                                         |
| clustering                | varchar(3)                  | 表是否有属性聚类子句（ YES ）或没有（ NO ）                  |
| activity_tracking         | varchar(23)                 | 是否在表上启用热图跟踪                                       |
| dml_timestamp             | varchar(25)                 | 自动数据优化的修改时间、创建时间或两者                       |
| has_identity              | varchar(3)                  | 表是否有标识列 (  YES ) 或没有 (  NO )                       |
| container_data            | varchar(3)                  | 表是否包含特定于容器的数据                                   |
| inmemory                  | varchar(8)                  | 是否为此子分区启动内存列存储，ENABLED(启动)，DISABLED（未启动 |
| inmemory_priority         | varchar(8)                  | 内存列存储填充的优先级                                       |
| inmemory_distribute       | varchar(15)                 | 内存列存储在oracle RAC中的分布方式                           |
| inmemory_compression      | varchar(17)                 | 内存列存储的压缩级别                                         |
| inmemory_duplicate        | varchar(13)                 | oracle RAC中的内存列存储的重复设置                           |
| default_collation         | varchar(100)                | 表的默认排序规则                                             |
| duplicated                | varchar(1)                  | 表是否在此分片上重复 (  Y ) 或不 (  N )                      |
| sharded                   | varchar(1)                  | 表是分片 (  Y ) 还是不分片 (  N )                            |
| external                  | varchar(3)                  | 表是否为外部表 (  YES ) 或不是 (  NO )                       |
| cellmemory                | varchar(24)                 | 存储单元闪存缓存中的列压缩值                                 |
| containers_default        | varchar(3)                  | 默认情况下是否启用表 CONTAINERS() (  YES ) 或不启用 (  NO )  |
| container_map             | varchar(3)                  | 指示是否启用表以与 container_map 数据库属性 (  YES ) 一起使用 (  NO ) |
| extended_data_link        | varchar(3)                  | 指示是否启用表以从根 (  YES ) 获取扩展数据链接 (  NO )       |
| extended_data_link_map    | varchar(3)                  | 仅为支持兼容性                                               |
| inmemory_service          | varchar(12)                 | 如何在各种实例上填充内存列存储                               |
| inmemory_service_name     | varchar(1000)               | 内存列存储的服务名称                                         |
| container_map_object      | varchar(3)                  | 指示是否将表用作 container_map 数据库属性的值 (  YES ) 或不 (  NO ) |

#### ALL_TRIGGERS

ALL_TRIGGERS视图提供当前用户可访问数据库表上的触发器信息。

| 列名              | 类型          | 描述                                                         |
| ----------------- | ------------- | ------------------------------------------------------------ |
| owner             | text          | 触发器的所有者                                               |
| trigger_name      | text          | 触发器名称                                                   |
| trigger_type      | text          | 触发类型:before/after                                        |
| triggering_event  | text          | 触发事件:insert/update/delete/truncate                       |
| table_owner       | text          | 表的所有者                                                   |
| base_object_type  | text          | 触发对象：表                                                 |
| table_name        | text          | 表名                                                         |
| column_name       | varchar(7)    | 嵌套表列的名称（如果是嵌套表触发器），否则为 NULL            |
| referencing_names | text          | 仅为支持兼容性                                               |
| when_clause       | varchar(4000) | 仅为支持兼容性                                               |
| status            | text          | 指示触发器是启用 (  ENABLED ) 还是禁用 (  DISABLED )；禁用的触发器不会触发 |
| description       | text          | 仅为支持兼容性                                               |
| action_type       | varchar(11)   | 触发体的动作类型：（CALL，PL/SQL）                           |
| trigger_body      | text          | 触发器定义                                                   |
| crossedition      | varchar(7)    | 跨版触发器类型（FORWARD,）                                   |
| before_statement  | varchar(3)    | 触发器是否有 BEFORE STATEMENT 部分 (  YES ) 或没有 (  NO )   |
| before_row        | varchar(3)    | 触发器是否有 BEFORE EACH ROW 部分 (  YES ) 或没有 (  NO )    |
| after_row         | varchar(3)    | 触发器是否有 AFTER EACH ROW 部分 (  YES ) 或没有 (  NO )     |
| after_statement   | varchar(3)    | 触发器是否有 AFTER STATEMENT 部分 (  YES ) 或没有 (  NO )    |
| instead_of_row    | varchar(3)    | 触发器是否有 INSTEAD OF 部分 (  YES ) 或没有 (  NO )         |
| fire_once         | varchar(3)    | 触发器是否仅对进行更改的用户进程触发 (  YES ) 或者触发器是否也将针对复制应用或 SQL 应用进程触发 (  NO ) |
| apply_server_only | varchar(3)    | 触发器是否仅针对复制应用或 SQL 应用进程 (  YES ) 或不 (  NO ) 触发。如果设置为 YES ，则 的设置 FIRE_ONCE 无关紧要。 |

#### ALL_TYPES

ALL_TYPES视图提供当前用户可访问数据库的对象类型信息。

| 列名             | 类型         | 描述                                            |
| ---------------- | ------------ | ----------------------------------------------- |
| owner            | text         | 类型的所有者                                    |
| type_name        | text         | 类型的名称                                      |
| type_oid         | oid          | 类型的编号                                      |
| typecode         | text         | 类型代码，可能值：object、collection、other     |
| attributes       | integer      | 类型中的属性数（如果有）                        |
| methods          | numeric      | 类型中的方法数（如果有）                        |
| predefined       | varchar(3)   | 类型是否为预定义类型 (  YES ) 或不是 (  NO )    |
| incomplete       | varchar(3)   | 类型是否为不完整类型 (  YES ) 或不是 (  NO )    |
| final            | varchar(3)   | 类型是否为最终类型 (  YES ) 或不是 (  NO )      |
| instantiable     | varchar(3)   | 类型是否为可实例化类型 (  YES ) 或不是 (  NO )  |
| supertype_owner  | varchar(128) | 超类型的所有者（如果类型不是子类型，则为 NULL） |
| supertype_name   | varchar(128) | 超类型的名称（如果类型不是子类型，则为 NULL）   |
| local_attributes | numeric      | 子类型中本地（非继承）属性（如果有）的数量      |
| local_methods    | numeric      | 子类型中本地（非继承）方法（如果有）的数量      |
| typeid           | raw          | 类型 ID 值                                      |

#### ALL_USERS

ALL_USERS视图提供当前用户可访问数据库的用户信息。

| 列名     | 类型 | 描述             |
| -------- | ---- | ---------------- |
| username | name | 用户名           |
| user_id  | oid  | 用户名所属的编号 |

#### ALL_VIEWS

ALL_VIEWS视图提供当前用户可访问数据库的视图信息。

| 列名                   | 类型          | 描述                                                         |
| ---------------------- | ------------- | ------------------------------------------------------------ |
| owner                  | name          | 视图所有者                                                   |
| view_name              | name          | 视图名称                                                     |
| text_length            | integer       | 视图文本的长度                                               |
| text                   | text          | 查看文本。仅当行源自当前容器时，此列才会返回正确的值。该 BEQUEATH 子句不会作为 TEXT 该视图中列的一部分出现。 |
| text_vc                | varchar(4000) | 查看文本。此列可能会截断视图文本。该 BEQUEATH 子句不会作为 TEXT_VC 该视图中列的一部分出现。 |
| type_text_length       | numeric       | 类型化视图的类型子句的长度                                   |
| type_text              | varchar(4000) | 类型化视图的类型子句                                         |
| oid_text_length        | numeric       | WITH OID 类型化视图的子句 长度                               |
| oid_text               | varchar(4000) | WITH OID 类型化视图的子句                                    |
| view_type_owner        | varchar(128)  | 如果视图是类型化视图，则视图类型的所有者                     |
| view_type              | varchar(128)  | 视图类型（如果视图是类型化视图）                             |
| superview_name         | varchar(128)  | 超级视图的名称                                               |
| editioning_view        | varchar(1)    | 留作将来使用                                                 |
| read_only              | varchar(1)    | 指示视图是否为只读 (  Y ) 或非 (  N )                        |
| container_data         | varchar(3)    | 指示视图是否包含特定于容器的数据                             |
| bequeath               | varchar(12)   | 可能的值： CURRENT_USER : 当视图是 BEQUEATH CURRENT_USER 视图 时  DEFINER : 当视图是 BEQUEATH DEFINER 视图 时 |
| origin_con_id          | varchar(256)  | 数据来源的容器的 ID                                          |
| default_collation      | varchar(100)  | 视图的默认排序规则                                           |
| containers_default     | varchar(3)    | CONTAINERS() 指示默认情况下是否启用视图(  YES ) 或不启用 (  NO ) |
| container_map          | varchar(3)    | 指示是否启用视图以与 container_map 数据库属性 (  YES ) 一起使用 (  NO ) |
| extended_data_link     | varchar(3)    | 指示是否启用视图以从根 (  YES ) 获取扩展数据链接 (  NO )     |
| extended_data_link_map | varchar(3)    | 仅为支持兼容性                                               |

#### ALL_TAB_COLS

ALL_TAB_COLS记录了用户所能访问的所有表字段相关的信息。

<table>
<tr>
<th>列名</th>
<th>类型</th>
<th>描述</th>
</tr>
<tr>
<td>owner</td>
<td>name</td>
<td>表、视图或者集群的所有者</td>
</tr>
<tr>
<td>table_name</td>
<td>name</td>
<td>表、视图或集群的名称</td>
</tr>
<tr>
<td>column_name</td>
<td>name</td>
<td>列名</td>
</tr>
<tr>
<td>data_type</td>
<td>text</td>
<td>列的数据类型</td>
</tr>
<tr>
<td> data_type_mod </td>
<td>text</td>
<td>列的数据类型修饰符</td>
</tr>
<tr>
<td> data_type_owner</td>
<td>name</td>
<td>列的数据类型所有者</td>
</tr>
<tr>
<td> data_length</td>
<td>integer</td>
<td>列长度（以字节为单位）</td>
</tr>
<tr>
<td> data_precision</td>
<td>integer</td>
<td>NUMBER数据类型的十进制精度</br>
FLOAT数据类型的二进制精度</br>
所有其他数据类型为NULL</td>
</tr>
<tr>
<td>data_scale</td>
<td>integer</td>
<td>数字中小数点右侧的数字</td>
</tr>
<tr>
<td>nullable</td>
<td>text</td>
<td>指示列是否允许NULL。值是指列上N是否存在NOT NULL约束，或者列是否为a PRIMARY KEY的一部分</td>
</tr>
<tr>
<td>column_id </td>
<td>smallint</td>
<td>创建列的序号</td>
</tr>
<tr>
<td>default_length</td>
<td>text</td>
<td>列的默认长度</td>
</tr>
<tr>
<td>data_default </td>
<td>text</td>
<td>列的默认值</td>
</tr>
<tr>
<td>num_distinct </td>
<td>real</td>
<td>列中的不同值的数量</td>
</tr>
<tr>
<td>low_value </td>
<td>text</td>
<td>列中低的值</td>
</tr>
<tr>
<td>high_value</td>
<td>text</td>
<td>列中高的值</td>
</tr>
<tr>
<td>density</td>
<td>double precision</td>
<td>如果柱状图在COLUMN_NAME上可用，则此列显示值的选择性，该值跨越柱状图中少于2个端点。它不代表跨越2个或多个端点的值的选择性。</td>
</tr>
<tr>
<td>num_nulls</td>
<td>text</td>
<td>列中NULL的数量</td>
</tr>
<tr>
<td>num_buckets</td>
<td>text</td>
<td>列的直方图中的桶的数量</td>
</tr>
<tr>
<td> last_analyzed </td>
<td>text</td>
<td>分析此列的最近的日期</td>
</tr>
<tr>
<td>SAMPLE_SIZE</td>
<td>text</td>
<td>用于分析此列的样本量</td>
</tr>
<tr>
<td>CHARACTER_SET_NAME</td>
<td>text</td>
<td>字符集的名称（CHAR_CS，NCHAR_CS）</td>
</tr>
<tr>
<td>char_col_decl_length</td>
<td>integer</td>
<td>字符类型列的声明长度</td>
</tr>
<tr>
<td> global_stats </td>
<td>text</td>
<td>如果收集统计数据，或者进行增量维护，则GLOBAL_STATS为YES，否则将为NO</td>
</tr>
<tr>
<td>user_stats </td>
<td>text</td>
<td>指示统计信息是否由用户直接输入（YES）或（NO）</td>
</tr>
<tr>
<td> avg_col_len </td>
<td>integer</td>
<td>列的平均长度（以字节为单位）</td>
</tr>
<tr>
<td>CHAR_LENGTH</td>
<td>integer</td>
<td>以字符的形式显示列的长度，使用的数据类型：CHAR、VARCHAR2、NCHAR、NVARCHAR2</td>
</tr>
<tr>
<td> char_used</td>
<td>text</td>
<td>表示列使用字节长度语义（B）或字符长度语义（C），或者数据类型是否不是以下任何一种（NULL）：CHAR、VARCHAR2、NCHAR、NVARCHAR2</td>
</tr>
<tr>
<td>v80_fmt_image</td>
<td>text</td>
<td>指示列数据是否为8.0版图像格式（YES）或否（NO）</td>
</tr>
<tr>
<td>data_upgraded</td>
<td>text</td>
<td>指示列数据是否已升级为最新类型版本格式（是）或未升级（否）</td>
</tr>
<tr>
<td>hidden_column </td>
<td>text</td>
<td>指示列是否是隐藏列，是（YES）或者否（NO）</td>
</tr>
<tr>
<td>virtual_column</td>
<td>text</td>
<td>指示列是否是虚拟列，是（YES）或者否（NO）</td>
</tr>
<tr>
<td>segment_column_id</td>
<td>text</td>
<td>列的序列号</td>
</tr>
<tr>
<td>internal_column_id</td>
<td>smallint</td>
<td>列的内部序列号</td>
</tr>
<tr>
<td>histogram</td>
<td>text</td>
<td>表示直方图存在的类型：NONE、FREQUENCY、TOP-FREQUENCY、HEIGHT BALANCED、HYBRID</td>
</tr>
<tr>
<td>qualified_col_name</td>
<td>name</td>
<td>限定列的名称</td>
</tr>
</table>


#### PRODUCT_COMPONENT_VERSION

兼容Oracle静态数据字典PRODUCT_COMPONENT_VERSION，其中包含组件产品的版本和状态信息。

可以使用如下查询语句进行查询：

```
select * from PRODUCT_COMPONENT_VERSION;
```

<table>
<tr>
<th>列名</th>
<th>类型</th>
<th>描述</th>
</tr>
<tr>
<td>PRODUCT</td>
<td>text</td>
<td>产品名称</td>
</tr>
<tr>
<td>VERSION</td>
<td>text</td>
<td>版本号</td>
</tr>
<tr>
<td>STATUS</td>
<td>text</td>
<td>发布状态</td>
</tr>
</table>

####  USER_PART_TABLES

USER_PART_TABLES视图用于提供当前用户的数据库中的分区表信息。该视图中的字段（除OWNER外）与ALL_PART_TABLES相同。具体请参考章节“ALL_PART_TABLES”。


#### USER_PART_INDEXES

USER_PART_INDEXES视图存储当前用户下分区表的索引信息。该视图中的字段（除OWNER外）与ALL_PART_INDEXES相同。具体请参考章节“ALL_PART_INDEXES”。


#### DBA_INDEXES

DBA_INDEXES视图提供所有用户的表上的索引信息。该视图中的字段与ALL_INDEXES相同。具体请参考章节“ALL_INDEXES”。


####  DBA_IND_PARTITIONS

DBA_IND_PARTITIONS视图存储数据库中所有索引分区的信息。该视图中的字段与ALL_IND_PARTITIONS相同。具体请参考章节“ALL_IND_PARTITIONS”。

#### USER_IND_PARTITIONS

USER_IND_PARTITIONS视图用于存储当前用户下的索引分区信息。该视图中的字段与ALL_IND_PARTITIONS相同。具体请参考章节“ALL_IND_PARTITIONS”。

#### DBA_ALL_TABLES

DBA_ALL_TABLES视图提供所有用户的表的信息。该视图中的字段与ALL_ALL_TABLES相同。具体请参考章节“ALL_ALL_TABLES”。

#### DBA_TABLES

DBA_TABLES视图提供所有用户的数据库用户定义表的信息。视图中的字段与ALL_TABLES相同。具体请参考章节“ALL_TABLES”。

#### DBA_CONS_COLUMNS

DBA_CONS_COLUMNS视图提供所有用户的表上约束指定列信息的信息。视图中的字段与ALL_CONS_COLUMNS相同。具体请参考章节“ALL_CONS_COLUMNS”。

#### DBA_CONSTRAINTS

DBA_CONSTRAINTS视图提供所有用户的表上的约束信息。视图中的字段与ALL_CONSTRAINTS相同。具体请参考章节“ALL_CONSTRAINTS”。

#### DBA_IND_COLUMNS

DBA_IND_COLUMNS视图提供所有用户的索引中包含的列信息。

| 列名            | 类型         | 描述                                                         |
| --------------- | ------------ | ------------------------------------------------------------ |
| index_owner     | varchar(64)  | 索引列的所有者                                               |
| schema_name     | varchar(64)  | 索引所属的模式名称                                           |
| index_name      | varchar(64)  | 索引名称                                                     |
| table_owner     | varchar(64)  | 表的所有者                                                   |
| table_name      | varchar(64)  | 表名                                                         |
| column_name     | name         | 列名                                                         |
| column_position | smallint     | 列的编号。一般列从1开始向上编号。系统列则拥有（任意）赋值编号 |
| column_length   | smallint     | 对于一个固定尺寸的类型，typlen是该类型内部表示的字节数。对于一个变长类型，typlen为负值。-1表示一个“varlena”类型（具有长度字），-2表示一个以空值结尾的C字符串 |
| char_length     | numeric      | 列的数据类型如果为char，表示字节数。否则为0                  |
| descend         | character(1) | 默认DESC。指示列是按降序（DESC）还是按升序（ASC）排序        |

#### DBA_OBJECTS

DBA_OBJECTS视图提供所有用户的数据库中所有对象的信息。视图中的字段与ALL_OBJECTS相同。具体请参考章节“ALL_OBJECTS”。

#### DBA_PART_KEY_COLUMNS

DBA_PART_KEY_COLUMNS视图提供所有用户的数据库中的分区表的分区键列的信息。视图中的字段与ALL_PART_KEY_COLUMNS相同。具体请参考章节“ALL_PART_KEY_COLUMNS”。

#### DBA_PART_TABLES

DBA_PART_TABLES视图提供所有用户的数据库中的分区表信息。

| 列名                      | 类型          | 描述                                                         |
| ------------------------- | ------------- | ------------------------------------------------------------ |
| owner                     | varchar(128)  | 分区表的所有者                                               |
| table_name                | varchar(128)  | 分区表名                                                     |
| partitioning_type         | varchar(9)    | 分区类型： range、list、hash                                 |
| subpartitioning_type      | varchar(9)    | 子分区类型：range、list、hash                                |
| partition_count           | bigint        | 分区表中的分区数                                             |
| def_subpartition_count    | bigint        | 复合分区表中，子分区数                                       |
| partitioning_key_count    | integer       | 分区键的列数                                                 |
| subpartitioning_key_count | integer       | 复合分区表中，子分区中的列数                                 |
| status                    | varchar(8)    | 仅为支持兼容性。该值始终为VALID                              |
| def_tablespace_name       | name          | 仅为支持兼容性。该值始终为NULL                               |
| def_pct_free              | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_pct_used              | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_ini_trans             | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_max_trans             | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_initial_extent        | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_next_extent           | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_min_extents           | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_max_extents           | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_max_size              | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_pct_increase          | varchar(40)   | 仅为支持兼容性。该值始终为NULL                               |
| def_freelists             | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_freelist_groups       | numeric       | 仅为支持兼容性。该值始终为NULL                               |
| def_logging               | varchar(7)    | 仅为支持兼容性。该值始终为YES                                |
| def_compression           | varchar(8)    | 仅为支持兼容性。该值始终为None                               |
| def_compress_for          | varchar(30)   | 添加分区时使用哪种操作的默认压缩                             |
| def_buffer_pool           | varchar(7)    | 仅为支持兼容性。该值始终为DEFAULT                            |
| def_flash_cache           | varchar(7)    | 仅为支持兼容性。该值始终为NULL                               |
| def_cell_flash_cache      | varchar(7)    | 仅为支持兼容性。该值始终为NULL                               |
| ref_ptn_constraint_name   | varchar(128)  | 仅为支持兼容性。该值始终为NULL                               |
| interval                  | varchar(1000) | 区间值字符串                                                 |
| autolist                  | varchar(3)    | 指示表是否通过自动列表分区 (  YES )分区 (  NO )              |
| interval_subpartition     | varchar(1000) | 子分区间隔值的字符串                                         |
| autolist_subpartition     | varchar(3)    | 指示此子 分区是否使用 (  YES )自动列表分区 ( ) NO            |
| is_nested                 | varchar(3)    | 指示分区表是否为嵌套表 (  YES ) 或不是 (  NO )               |
| def_segment_creation      | varchar(4)    | 指定是否在表级别指定了段创建的默认值：NO（指定延迟），YES（立即指定），NONE（未指定段创建的默认值） |
| def_indexing              | varchar(3)    | 指示为表指定的索引属性                                       |
| def_inmemory              | varchar(8)    | 只是内存列存储是否启用(  ENABLED )、禁用 (  DISABLED ) 或未指定 (  NONE ) 用于此表中的分区 |
| def_inmemory_priority     | varchar(8)    | 内存列存储填充的优先级                                       |
| def_inmemory_distribute   | varchar(15)   | 在 Oracle RAC)环境中默认情况下如何为表的分区分配 内存列存储  |
| def_inmemory_compression  | varchar(17)   | 内存列存储的默认压缩级别                                     |
| def_inmemory_duplicate    | varchar(13)   | Oracle RAC 环境中 内存列存储的默认重复设置                   |
| def_read_only             | varchar(3)    | 新分区的默认设置：（YES）新分区的默认设置是只读的。 （NO）新分区的默认设置是读/写。 |
| def_cellmemory            | varchar(24)   | 显示父表中的新分区将继承的属性的默认值， CELLMEMORY 除非该行为被显式覆盖 |
| def_inmemory_service      | varchar(12)   | 默认情况下如何在各种实例上为表的分区填充内存列存储           |
| def_inmemory_service_name | varchar(1000) | 默认情况下应为表的分区填充 内存列存储的服务的服务名称。      |

#### DBA_ROLE_PRIVS

DBA_ROLE_PRIVS包含当前数据库所有角色的权限信息。

| 列名         | 类型 | 描述                          |
| ------------ | ---- | ----------------------------- |
| grantee      | text | 接受授权的用户或角色名称      |
| granted_role | text | 被授权角色名称                |
| admin_option | text | 权限是否与amin option一起使用 |
| default_role | text | 是否被定义为默认              |

#### DBA_ROLES

DBA_ROLES包含当前系统的角色信息。

| 列名              | 类型 | 描述                 |
| ----------------- | ---- | -------------------- |
| role              | text | 角色名称             |
| password_required | text | 指定角色使用密码认证 |

#### DBA_SEGMENTS

DBA_SEGMENTS描述数据库中的所有段分配的存储。

| 列名                 | 类型             | 描述                                                         |
| -------------------- | ---------------- | ------------------------------------------------------------ |
| owner                | name             | 段的所有者                                                   |
| segment_name         | name             | 段的名称                                                     |
| partition_name       | varchar(128)     | 段所在分区的名称（设置NULL为非分区对象）                     |
| segment_type         | varchar(18)      | 段的类型                                                     |
| segment_subtype      | varchar(10)      | LOB 段的子类型：SECUREFILE、ASSM、MSSM和NULL                 |
| tablespace_name      | name             | 包含段的表空间的名称                                         |
| header_file          | oid              | 包含段头的文件编号                                           |
| header_block         | oid              | 包含段头的块的编号                                           |
| bytes                | bigint           | 段的大小，以字节为单位                                       |
| blocks               | double precision | 段的大小（以 Oracle 块为单位）                               |
| extents              | numeric          | 分配给段的区数                                               |
| initial_extent       | numeric          | 在创建时为段的初始范围请求的大小（以字节为单位）             |
| next_extent          | numeric          | 要分配给该段的下一个扩展区的大小（以字节为单位）             |
| min_extents          | numeric          | 段中允许的最小范围数                                         |
| max_extents          | numeric          | 段中允许的最大范围数                                         |
| max_size             | numeric          | 段中允许的最大块数                                           |
| retention            | varchar(7)       | SECUREFILE段 的保留选项                                      |
| minretention         | numeric          | SECUREFILE分段 的最短保留期限                                |
| pct_increase         | numeric          | 增加下一个要分配的范围大小的百分比                           |
| freelists            | numeric          | 分配给该段的进程空闲列表数                                   |
| freelist_groups      | numeric          | 分配给该段的空闲列表组数                                     |
| relative_fno         | numeric          | 段头的相对文件号                                             |
| buffer_pool          | varchar(7)       | 用于段块的缓冲池：DEFAULT、KEEP、RECYCLE                     |
| flash_cache          | varchar(7)       | 用于段块的数据库智能闪存缓存提示（仅限 Solaris 和 Oracle Linux 功能） |
| cell_flash_cache     | varchar(7)       | 用于段块的单元闪存缓存提示：DEFAULT、KEEP、NONE              |
| inmemory             | varchar(8)       | 此段 的内存中列存储是启用 ( ENABLED) 还是禁用 (DISABLED )    |
| inmemory_priority    | varchar(8)       | 内存列存储填充的优先级                                       |
| inmemory_distribute  | varchar(15)      | 内存列存储在ORACLE RAC环境中的分布方式                       |
| inmemory_duplicate   | varchar(13)      | Oracle RAC 环境中内存列存储的重复设置                        |
| inmemory_compression | varchar(17)      | 内存列存储的压缩级别                                         |
| cellmemory           | varchar(24)      | 存储单元闪存缓存中的列压缩值                                 |

#### DBA_SEQUENCES

DBA_SEQUENCES视图提供所有用户的数据库分区表的子分区的关键列的信息。视图中的字段与ALL_SEQUENCES相同。具体请参考章节“ALL_SEQUENCES”。

#### DBA_SUBPART_KEY_COLUMNS

DBA_SUBPART_KEY_COLUMNS视图提供了数据库分区表的子分区键列信息。视图中的字段与ALL_SUBPART_KEY_COLUMNS相同。具体请参考章节“ALL_SUBPART_KEY_COLUMNS”。

#### DBA_SYNONYMS

DBA_SYNONYMS提供了数据库同义词的信息。

| 列名              | 类型 | 描述                     |
| ----------------- | ---- | ------------------------ |
| owner             | text | 所有者                   |
| schema_name       | text | 名字空间名               |
| synonym_name      | text | 同义词名                 |
| table_owner       | text | 引用对象的所有者         |
| table_schema_name | text | 引用对象所在的名字空间名 |
| table_name        | text | 引用对象名               |
| db_link           | text | 引用数据库连接的名字     |

#### DBA_TAB_COLUMNS

DBA_TAB_COLUMNS视图提供所有用户的表和视图中所有列的信息。视图中的字段与ALL_TAB_COLUMNS相同。具体请参考章节“ALL_TAB_COLUMNS”。

#### DBA_TAB_PARTITIONS

DBA_TAB_PARTITIONS视图提供所有用户的数据库中的所有分区的信息。视图中的字段与ALL_TAB_PARTITIONS相同。具体请参考章节“ALL_TAB_PARTITIONS”。

#### DBA_TAB_SUBPARTITIONS

DBA_TAB_SUBPARTITIONS视图提供所有用户的数据库中的所有子分区的信息。视图中的字段与ALL_TAB_SUBPARTITIONS相同。具体请参考章节“ALL_TAB_SUBPARTITIONS”。

#### DBA_TRIGGERS

DBA_TRIGGERS视图提供所有用户的数据库表上的触发器信息。视图中的字段与ALL_TRIGGERS相同。具体请参考章节“ALL_TRIGGERS”。

#### DBA_TYPES

DBA_TYPES视图提供所有用户的数据库的对象类型信息。视图中的字段与ALL_TYPES相同。具体请参考章节“ALL_TYPES”。

#### DBA_USERS

DBA_USERS视图提供所有用户的数据库的用户信息。

| 列名                        | 类型                        | 描述                                                         |
| --------------------------- | --------------------------- | ------------------------------------------------------------ |
| username                    | varchar(64)                 | 用户名                                                       |
| user_id                     | oid                         | 用户id                                                       |
| password                    | varchar(30)                 | 密码                                                         |
| account_status              | varchar(32)                 | 用户状态                                                     |
| lock_date                   | timestamp without time zone | 如果账户状态是lock，显示被锁日期                             |
| expiry_date                 | timestamp without time zone | 过期时间                                                     |
| default_tablespace          | varchar(64)                 | 数据的默认表空间                                             |
| temporary_tablespace        | varchar(30)                 | 临时表的默认表空间的名称或表空间组的名称                     |
| local_temp_tablespace       | varchar(30)                 | 用户的默认本地临时表空间                                     |
| created                     | timestamp without time zone | 仅为支持兼容性。该值始终为NULL                               |
| profile                     | varchar(30)                 | Profile名                                                    |
| initial_rsrc_consumer_group | varchar(30)                 | 仅为支持兼容性。该值始终为NULL                               |
| external_name               | varchar(4000)               | 仅为支持兼容性。该值始终为NULL                               |
| password_versions           | varchar(12)                 | 显示帐户存在的密码哈希（也称为“验证器”）的版本列表。         |
| editions_enabled            | varchar(1)                  | 指示是否已为相应用户启用版本 ( Y) 或未启用 ( N)              |
| authentication_type         | varchar(8)                  | 表示用户的认证机制                                           |
| proxy_only_connect          | varchar(1)                  | 指示用户是否可以直接连接 (N) 或该帐户是否只能由对此帐户具有代理权限的用户代理 (Y)（即，由已被授予此帐户“连接通过”权限的用户 |
| common                      | varchar(3)                  | 指示给定用户是否是普通用户：YES(普通用户)，NO(本地用户)      |
| last_login                  | timestamp with time zone    | 上次用户登录时间                                             |
| oracle_maintained           | varchar(1)                  | 表示用户是否由 Oracle 提供的脚本（例如 catalog.sql 或 catproc.sql）创建和维护 |
| inherited                   | varchar(3)                  | 指示用户定义是否继承自另一个容器 ( YES) 或不是 ( N)          |
| default_collation           | varchar(100)                | 用户架构的默认排序规则                                       |
| implicit                    | varchar(3)                  | 指示此用户是否是由隐式应用程序创建的普通用户 ( YES) 或不是 ( NO) |
| all_shard                   | varchar(3)                  | 在分片数据库中，此列中的值指示用户是否是在启用分片 DDL 的情况下创建的 |

#### DBA_VIEWS

DBA_VIEWS视图提供所有用户的数据库的视图信息。视图中的字段与ALL_VIEWS相同。具体请参考章节“ALL_VIEWS”。

### 动态性能视图

#### V$DATABASE

V$DATABASE包含当前数据库的基本信息。

| 列名                         | 类型                     | 描述                                                         |
| ---------------------------- | ------------------------ | ------------------------------------------------------------ |
| dbid                         | oid                      | 数据库唯一标识符                                             |
| name                         | name                     | 数据库名称                                                   |
| created                      | timestamp with time zone | 数据库的创建时间                                             |
| resetlogs_change#            | integer                  | 打开的重置日志中的系统更改号                                 |
| resetlogs_time               | timestamp with time zone | 打开的重置日志的时间戳                                       |
| prior_resetlogs_change#      | integer                  | 先前的重置日志中的版本号                                     |
| prior_resetlogs_time         | text                     | 先前重置日志的时间                                           |
| log_mode                     | text                     | 归档日志模式                                                 |
| checkpoint_change#           | integer                  | 上一个scn检查点                                              |
| archive_change#              | integer                  | 数据库强制归档scn                                            |
| controlfile_type             | text                     | 控制文件类型                                                 |
| controlfile_created          | text                     | 控制文件的创建日期                                           |
| controlfile_sequence#        | integer                  | 控制文件序列号由控制文件事务增加                             |
| controlfile_change#          | integer                  | 备份控制文件中的最后一个scn；如果控制文件不是备份，则为null  |
| controlfile_time             | text                     | 备份控制文件中的最后一个时间戳；如果控制文件不是备份，则为null |
| open_resetlogs               | integer                  | 表明下一个打开的数据库是允许还是需要resetlogs选项            |
| version_time                 | text                     | 版本时间                                                     |
| open_mode                    | text                     | 数据库打开模式                                               |
| protection_mode              | text                     | 当前数据库的保护模式                                         |
| protection_level             | text                     | 当前数据库的保护级别                                         |
| remote_archive               | text                     | remote_archive_enable初始化参数的值                          |
| activation#                  | integer                  | 分配给数据库实例的编号                                       |
| switchover#                  | integer                  | 分配给数据库切换的编号                                       |
| database_role                | text                     | 数据库的当前角色                                             |
| archivelog_change#           | integer                  | 归档日志的最高编号                                           |
| archivelog_compression       | text                     | 归档日志的压缩状态                                           |
| switchover_status            | text                     | 表明允许切换                                                 |
| dataguard_broker             | text                     | data guard代理信息                                           |
| guard_status                 | text                     | 数据保护状态                                                 |
| supplemental_log_data_min    | text                     | 确保logminer有足够的信息进行工作                             |
| supplemental_log_data_pk     | text                     | 将所有具有主键的表的键值放入重做日志中                       |
| supplemental_log_data_ui     | text                     | 对于所有拥有唯一键的表，指示修改时放入重做日志中             |
| force_logging                | text                     | 指示数据库当前是否为强制日志模式                             |
| platform_id                  | integer                  | 数据库的平台标示号                                           |
| platform_name                | text                     | 数据库的平台名称                                             |
| recovery_target_incarnation# | integer                  | 该数据库恢复的所有文件的编号                                 |
| last_open_incarnation#       | integer                  | v$database_incarnation成功打开的记录号                       |
| current_scn                  | integer                  | 当前的scn号                                                  |
| flashback_on                 | text                     | 指示闪回功能是否开启                                         |
| supplemental_log_data_fk     | text                     | 对于拥有外键的表，修改时是否将键值放入重做日志中             |
| supplemental_log_data_all    | text                     | 对于所有列，修改时是否全部放入重做日志中                     |
| db_unique_name               | name                     | 数据库的唯一标示名称                                         |
| standby_became_primary_scn   | integer                  | 备机成为主机的scn号                                          |
| fs_failover_status           | text                     | 快速故障转移的状态                                           |
| fs_failover_current_target   | text                     | db_unique_name备用数据库                                     |
| fs_failover_threshold        | integer                  | 尝试使用备用机前的观察时间（单位为秒）                       |
| fs_failover_observer_present | text                     | 指示监控者是否连接到数据库                                   |
| fs_failover_observer_host    | text                     | 当前监控器的主机名                                           |
| controlfile_converted        | text                     | 指示还原期间是否隐式转换控制文件                             |
| primary_db_unique_name       | text                     | 对于任何节点数据库，此参数标明主节点名称                     |
| supplemental_log_data_pl     | text                     | 在支持复制工作时，是否额外在重做日志中记录内部的调用信息     |
| min_required_capture_change# | text                     | required_checkpoint_scn数据库上所有本地捕获过程的最小值      |

#### V$INSTANCE

V$INSTANCE描述当前系统实例信息。

| 列名             | 类型                     | 描述                       |
| ---------------- | ------------------------ | -------------------------- |
| instance_number  | integer                  | 实例编号                   |
| instance_name    | name                     | 实例名称                   |
| host_name        | text                     | 当前实例所在主机名称       |
| version          | text                     | 数据库版本信息             |
| startup_time     | timestamp with time zone | 数据库启动时间             |
| status           | text                     | 数据库状态                 |
| parallel         | text                     | 指明数据库是否在集群中     |
| thread#          | integer                  | 数据库打开的重做线程数     |
| archiver         | text                     | 自动归档信息               |
| log_switch_wait  | text                     | 记录切换日志的等待事件     |
| logins           | text                     | 指明数据库是否处于受限状态 |
| shutdown_pending | text                     | 是否正在关闭               |
| database_status  | text                     | 当前数据库状态             |
| instance_role    | text                     | 当前实例角色信息           |
| active_state     | text                     | 当前实例的活动状态         |
| blocked          | text                     | 当前实例是否阻塞           |
| edition          | text                     | 版本信息                   |

#### V$LICENSE

V$LICENSE包含当前系统license信息。

| 列名                       | 类型    | 描述                                  |
| -------------------------- | ------- | ------------------------------------- |
| sessions_max               | integer | 允许的最大会话数                      |
| sessions_warning           | integer | 并发用户的警告阈值                    |
| sessions_current           | integer | 当前并发的会话数量                    |
| sessions_highwater         | integer | 会话高水位线                          |
| users_max                  | integer | 数据库允许的最大用户数                |
| cpu_count_current          | text    | 系统上当前逻辑cpu数                   |
| cpu_core_count_current     | text    | 系统上当前物理cpu数                   |
| cpu_socket_count_current   | text    | 系统上当前的cpu插槽数                 |
| cpu_count_highwater        | text    | 自实例启动以来，系统上逻辑cpu的最大值 |
| cpu_core_count_highwater   | text    | 自实例启动以来，系统上的最大cpu物理核 |
| cpu_socket_count_highwater | text    | 自实例启动以来，系统上的最大cpu插槽数 |

#### V$VERSION

V$VERSION包含当前软件的版本信息。

| 列名   | 类型 | 描述                   |
| ------ | ---- | ---------------------- |
| banner | text | 当前的组件名称与版本号 |

#### V$OBSOLETE_PARAMETER

V$OBSOLETE_PARAMETER包含当前实例的初始化参数信息。

| 列名        | 类型    | 描述                         |
| ----------- | ------- | ---------------------------- |
| name        | text    | 参数名称                     |
| isspecified | boolean | 指明参数是否在参数文件中指定 |

#### V$OPTION

V$OPTION包含当前数据库扩展功能信息。

| 列名      | 类型    | 描述           |
| --------- | ------- | -------------- |
| parameter | name    | 选项功能的名称 |
| value     | boolean | 该功能是否开启 |

#### V$PARAMETER

V$PARAMETER包含当前实例参数的详细信息。

| 列名                  | 类型    | 描述                           |
| --------------------- | ------- | ------------------------------ |
| num                   | bigint  | 参数编号                       |
| name                  | text    | 参数名称                       |
| type                  | integer | 参数类型                       |
| value                 | text    | 当前会话的参数值               |
| display_value         | text    | 参数值的智能显示               |
| isdefault             | boolean | 是否为默认值                   |
| isses_modifiable      | boolean | 是否可以通过alter session修改  |
| issys_modifiable      | boolean | 是否可以通过alter system修改   |
| isinstance_modifiable | boolean | 集群中每个实例参数是否可以不同 |
| ismodified            | boolean | 该参数是否已修改               |
| isadjusted            | boolean | 数据库实例的建议值             |
| isdeprecated          | boolean | 该参数是否已弃用               |
| isbasic               | boolean | 该参数是否为基本参数           |
| description           | text    | 参数描述                       |
| update_comment        | text    | 参数更新的相关注释             |
| hash                  | text    | 参数名的哈希值                 |

#### V$TABLESPACE

V$TABLESPACE包含当前实例表空间的信息。

| 列名                        | 类型   | 描述                               |
| --------------------------- | ------ | ---------------------------------- |
| ts#                         | bigint | 表空间编号                         |
| name                        | name   | 表空间名称                         |
| included_in_database_backup | text   | 该表空间是否可以包含在备份集       |
| bigfile                     | text   | 是否开启大文件                     |
| flashback_on                | text   | 是否参与到flashback database操作中 |
| encrypt_in_backup           | text   | 该表空间是否为加密                 |

#### V$OBJECT_USAGE

V$OBJECT_USAGE包含数据库收集的用户索引使用情况的统计信息。

| 列名             | 类型 | 描述             |
| ---------------- | ---- | ---------------- |
| index_name       | name | 索引名称         |
| table_name       | name | 索引所在的表名   |
| monitoring       | text | 该索引是否被监控 |
| used             | text | 该索引是否被使用 |
| start_monitoring | text | 开始监控的时间   |
| end_monitoring   | text | 停止监控的时间   |

#### V$DBLINK

V$DBLINK包含当前会话在使用dblink时所有链接信息，在事务提交或回滚时清除。

| 列名                  | 类型 | 描述                         |
| --------------------- | ---- | ---------------------------- |
| db_link               | text | 数据库链接的名称             |
| owner_id              | text | 数据库链接uid的所有者        |
| logged_on             | text | 数据库链接当前是否已登录     |
| heterogeneous         | text | 数据库链接是否异构           |
| protocol              | text | 数据库链接的通信协议         |
| open_cursors          | text | 数据库链接是否有打开的游标   |
| in_transaction        | text | 数据库链接当前是否在事务中   |
| update_sent           | text | 数据库链接上是否有更新       |
| commit_point_strength | text | 数据库链接上事务的提交点强度 |


##  兼容PL/SQL

### 创建函数、存储过程、触发器和包时进行编译检查

**功能描述**

在创建PL/pgSQL对象时，进行语义检查。增加GUC参数vbplsql_check，当该参数设置为on或者true生效，在创建PL/pgSQL对象时进行语义检查，否则，不检查。检查功能如下：

- 创建函数需要返回非void时候，判断程序是否有return返回值，如果没有return返回值则创建失败，涉及到的statement有if、case语句。

- 字符串拼接如果使用的双引号进行字符串拼接，则创建对象失败。

- 如果DMshowu 句中出现表不存在的情况，则创建对象失败，不包含动态执行语句。

- 如果DML语句出现语法错误的情况，则创建对象失败，不包含动态执行语句。

**设置方法**
设置GUC参数vbplsql_check = true或者on。

```
set vbplsql_check = true;
```

**注意事项**

无。

**示例**

示例一：创建触发器，判断是否有return返回。

1、创建测试表。

```
drop table if exists t1_z;
drop function if exists tri_func;
create table t1_z(w1 date);
```

2、创建函数。

```
CREATE OR REPLACE FUNCTION tri_func() RETURNS TRIGGER AS
$$
DECLARE
BEGIN
raise notice 'trigger begin: TG_OP is %',TG_OP;
if TG_OP='INSERT' then
insert into t1_z values('2022-05-19'::date+1);
end if;
END $$ LANGUAGE 'plpgsql';
```

返回结果如下，则表示函数创建成功:

```
CREATE FUNCTION
```

3、创建触发器。

```
CREATE TRIGGER be_tri
BEFORE INSERT OR DELETE OR UPDATE
ON t1_z
FOR EACH ROW
EXECUTE PROCEDURE tri_func();
```

创建触发器失败，提示缺少返回值，返回结果如下：

```
ERROR:  control reached end of function without RETURN
```

示例二：存储过程-DML语句中出现表不存在的情况，则创建对象失败。

1、删除表。

```
drop table if exists t1_z;
drop procedure if exists func;
```

2、创建存储过程。

```
create or replace procedure func()
as
declare
begin
insert into t1_z values(to_date('2022-05-19 135623.123','YYYY-MM-DD HH24MISS.FF'));
end;
/
```

存储过程创建失败，提示表不存在，返回结果如下：

```
ERROR:  relation "t1_z" does not exist on node1
LINE 1: insert into t1_z values(to_date('2022-05-19 135623.123','YYY...
                    ^
QUERY:  insert into t1_z values(to_date('2022-05-19 135623.123','YYYY-MM-DD HH24MISS.FF'))

```

3、调用存储过程。

```
select func();
```

调用存储过程失败，提示不存在，返回结果如下：

```
ERROR:  function func() does not exist
LINE 1: select func();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: func
```

示例三：存储过程-DML语句出现语法错误，则创建对象失败。

1、创建测试表。

```
drop table if exists t1_z;
drop procedure if exists func;
create table t1_z(col1 date);
```

2、创建存储过程（其中insert语句语法错误）。

```
create or replace procedure func()
as
begin
insert into t1_z ('2022-05-19');
end;
/
```

存储过程创建失败，提示语法错误,返回结果如下：

```
ERROR:  syntax error at or near "'2022-05-19'"
LINE 3: insert into t1_z ('2022-05-19');
                          ^
QUERY:   DECLARE
begin
insert into t1_z ('2022-05-19');
end
```

### 数组支持RECORD类型

**功能描述**
该功能允许在PL/SQL程序中定义RECORD类型数组。

**语法格式**

```
TYPE array_type IS VARRAY(size) OF data_type;
```

**参数说明**

- array_type：要定义的数组类型名。
- VARRAY：表示要定义的数组类型。
- size：取值为正整数，表示可以容纳的成员的最大数量。
- data_type：要创建的数组中成员的类型，现在支持record类型。

**注意事项**

无。

**示例**

在程序块中定义数组类型。

```
declare
TYPE sum_type IS RECORD
(
sum_id varchar2(20),
sum_sum number
);

sum_rec sum_type;
TYPE sum_type_array IS VARRAY(2) of sum_type;
sum_rec_array sum_type_array;

begin
sum_rec.sum_id :='GLG001_CBB_DAY';
sum_rec.sum_sum := 1;
sum_rec_array[1] := sum_rec;

sum_rec.sum_id :='GLG001_CBC_SUM';
sum_rec.sum_sum := 2;
sum_rec_array[2] := sum_rec;

sum_rec := sum_rec_array[1];
raise notice 'sum_rec_array[1]：% %', sum_rec.sum_id, sum_rec.sum_sum;

sum_rec := sum_rec_array[2];
raise notice 'sum_rec_array[2]：% %', sum_rec.sum_id, sum_rec.sum_sum;
end;
/

```

返回结果为：

```
NOTICE:  sum_rec_array[1]：GLG001_CBB_DAY 1
NOTICE:  sum_rec_array[2]：GLG001_CBC_SUM 2
ANONYMOUS BLOCK EXECUTE
```

### 定义游标支持INTO关键字

**功能描述**

支持cursor xxx for/is select ... into ...用法。

**语法格式**

```
DECLARE
    CURSOR name FOR SELECT columns INTO ... FROM table_name;
```

**参数据说明**
INTO ... ：可以是声明的变量，数量与SELECT ...一致。

**注意事项**

无。

**示例**

1、创建测试表并插入数据。

```
CREATE TABLE stu_info
(
id INT NOT NULL DEFAULT 0,
name TEXT
);

INSERT INTO stu_info (id,name) VALUES(1,'name01');
INSERT INTO stu_info (id,name) VALUES(2,'name02');
INSERT INTO stu_info (id,name) VALUES(3,'name03');
```

2、定义一个游标。

```
do language plpgsql $$
declare
v_id int;
v_name TEXT;
cursor cur1 for
select id,name into v_id,v_name from stu_info where id>1;
begin
open cur1;
loop
fetch cur1 into v_id,v_name;
if found then
update stu_info set name='test' where id = v_id;
else
exit;
end if;
end loop;
end;
$$;
```

3、查询表中数据。

```
select * from stu_info;
```

返回结果如下，则表示游标定义成功：

```
 id |  name
----+--------
  1 | name01
  2 | test
  3 | test
(3 rows)
```

### CREATE FUNCTION中支持PIPELINED和PIPE ROW语法

**功能描述**

CREATE FUNCTION中支持PIPELINED和PIPE ROW语法，让函数可以返回一个集合，在函数中还可以使用PIPE ROW语句，用来返回集合中的单个元素。

**语法格式**

```
CREATE [ OR REPLACE ] FUNCTION func_name ( ... )
RETURNS rettype PIPELINED
...
```

**参数说明**

rettype：函数返回值的数据类型。

**注意事项**

PIPE ROW必须与PIPELINED语法配套使用。

**示例**

1、创建函数。

```
CREATE OR REPLACE FUNCTION test()
  RETURNS int 
  PIPELINED 
  AS $$
  DECLARE
  result RECORD;
  row RECORD;
  BEGIN
  pipe row(1);
  pipe row(2);
  return;
  END
$$
LANGUAGE plpgsql;
```

2、查询结果。

```
select * from table(test());
```

返回结果如下：

```
 test
------
    1
    2
(2 rows)
```

### 自治事务

**功能描述**

该功能支持在定义pl/pgsql定义函数/存储过程中，在声明部分增加指令：PRAGMA AUTONOMOUS_TRANSACTION，用来控制对当前存储过程中的内部事务可以进行独立提交，而不影响其他的事务。
该执行方式与普通方式执行函数/存储过程相同。
此外，自治事务还支持如下功能：

- 支持pl/pgsql块内的sql语句使用函数/存储过程参数和定义的变量。
- 允许在触发器函数内，匿名块内声明自治事务。
- 支持自治事务的嵌套使用。

**语法格式**

```
PRAGMA AUTONOMOUS_TRANSACTION;
```

**注意事项**

声明为自治事务的函数/存储过程对返回值以及参数有如下限制：

- 不支持集合作为返回值。
- 不支持组合类型作为返回类型。
- 不支持out参数。

**示例**

1、创建测试表。

```
create table at_tb2(id int, val varchar(64));
```

2、创建声明为自治事务的存储过程。

```
create or replace procedure at_test3(i int)
AS
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  insert into at_tb2 values(1, 'before s1');
  insert into at_tb2 values(2, 'after s1');
  if i > 10 then
  rollback;
  else
  commit;
  end if;
end;
/
commit;  -- 如果数据库未开启默认自动提交，则需要手动提交
```

3、调用存储过程。

```
call at_test3(6);
```

4、查询表中的数据。

```
select * from at_tb2;
```

返回结果为：

```
 id |    val
----+-----------
  1 | before s1
  2 | after s1
(2 rows)

```

5、支持pl/pgsql块内的sql语句使用函数/存储过程参数和定义的变量。

```
create or replace procedure at_proc(i int)
as
declare
strval varchar;
pragma autonomous_transaction;
begin
strval:= 'begin:insert by autonomous transaction procedure<at_proc>';
insert into at_tb2 values(i,strval);
commit;
end;
/

commit; -- 如果数据库未开启默认自动提交，则需要手动提交
```

6、调用存储过程。

```
call at_proc(1);
```

7、查询表中的数据。

```
select * from at_tb2;
```

返回结果为：

```
 id |                            val
----+-----------------------------------------------------------
  1 | before s1
  2 | after s1
  1 | begin:insert by autonomous transaction procedure<at_proc>
(3 rows)
```

8、支持在触发器函数内声明自治事务-创建源表及触发表。

```
create table test_trigger_src_tbl(id1 int, id2 int, id3 int);
create table test_trigger_des_tbl(id1 int, id2 int, id3 int);
```

9、创建触发器函数。

```
create or replace function tri_insert_func() returns trigger as
$$
declare
pragma autonomous_transaction;
begin
insert into test_trigger_des_tbl values(new.id1, new.id2, new.id3);
return new;
end
$$ language plpgsql;

commit; -- 如果数据库未开启默认自动提交，则需要手动提交
```

10、创建insert触发器。

```
create trigger insert_trigger
before insert on test_trigger_src_tbl
for each row
execute procedure tri_insert_func();
```

11、执行insert触发事件并检查触发结果。

```
insert into test_trigger_src_tbl values(100,200,300);
select * from test_trigger_src_tbl;
```

返回结果为：

```
 id1 | id2 | id3
-----------------
 100 | 200 | 300
 (1 row)
```

12、查看触发操作是否生效。

```
select * from test_trigger_des_tbl;  
```

返回结果为：

```
id1 | id2 | id3
-----------------
 100 | 200 | 300
 (1 row)
```

13、清除表中的数据。

```
truncate at_tb2;
```

14、支持在匿名块内声明自治事务。

```
declare
pragma autonomous_transaction;
strval varchar;
begin strval:='insert by autonomous transaction by anonymous block';
insert into at_tb2 values(1,strval);
commit;
end;
/
```

15、查询表中数据。

```
select * from at_tb2;
```

返回结果为：

```
id |                             val
----------------------------------------------------------
1 | insert by autonomous transaction by anonymous block
(1 row)
```

16、支持自治事务嵌套使用-创建嵌套自治事务的存储过程。

```
create or replace procedure at_proc_inner(i int)
as
declare
pragma autonomous_transaction;
begin
insert into at_tb2 values(1,'insert by autonomous transaction procedure<at_proc_inner>');
if i>5 then
rollback;
else
commit;
end if;
end;
/

create or replace procedure at_proc_outer(i int)
as
declare
pragma autonomous_transaction;
begin
insert into at_tb2 values(1,'insert by autonomous transaction procedure<at_proc_outer>');
at_proc_inner(i);
if i>10 then rollback;
else
commit;
end if;
end;
/
```

17、调用存储过程并查询结果

```
truncate at_tb2;
call at_proc_outer(8);
select * from at_tb2;
```

返回结果为：

```
id |                                 val
---------------------------------------------------------------
  1 | insert by autonomous transaction procedure<at_proc_outer>
(1 row)
```


###  关联数组

**功能描述**

关联数组也称索引表，是一组key-value键值对，每个key都是一个唯一索引。Vastbase支持在PL/SQL中定义关联数组类型，以及定义和使用关联数组变量，并支持关联数组元素的赋值与访问。

**语法格式**

```
TYPE typename IS TABLE OF datatype INDEX BY subtype;
```

**参数说明**

- typename：类型名称。
- datatype：数组元素支持Vastbase数据类型包括数值、字符、时间以及自定义类型，不支持REF CURSOR和NCLOB类型。
- subtype：数组下标的类型，目前支持varchar2，varchar2(n)，varchar，varchar(n)，pls_integer（整型数字）。

**注意事项**

赋值与访问关联数组变量，访问的下标类型可以是整型数字（INDEX BY PLS_INTEGER），varchar以及varchar2类型下标。

**示例**

定义关联数组赋值与访问关联数组变量。

```
CREATE OR REPLACE FUNCTION Fun() RETURNS int AS $$
DECLARE
TYPE ARRAY_INTEGER IS TABLE OF int index by varchar(20);   --定义类型
ARRINT ARRAY_INTEGER;   --定义变量
BEGIN
ARRINT('TOM') := 99;    --通过变量下标给数组赋值
RETURN ARRINT['TOM'];     --返回数组元素
END;
$$
LANGUAGE plpgsql;
```

返回结果为:

```
CREATE FUNCTION
```

###  嵌套表

**功能描述**

在数据库中嵌套表是一种列类型，用于存储未指定数量的行。未初始化的嵌套表变量是一个空集合，使用前必须对其进行初始化，方法是将其设置为空或分配一个非NULL的值。Vastbase G100 build 9支持在PL/pgSQL中定义嵌套表类型，以及定义和使用嵌套表变量，并支持嵌套表元素的赋值以及访问。

**语法格式**

```
---嵌套表的声明
TYPE typename IS TABLE OF datatype;
```

**参数说明**

- typename：类型名称。
- datatype：数组元素支持Vastbase数据类型包括数值、字符、时间以及自定义类型，不支持REF CURSOR和NCLOB类型。

**注意事项**

- 赋值与访问嵌套表变量，访问的下标类型是整型数字下标。
- 嵌套表不支持初始化赋值，直接对数组赋值而不初始化数组。
- 嵌套表的数组会自动增长，访问越界会返回一个NULL，不会报错。
- 嵌套表在存储过程中定义的数组类型，其作用域仅在该存储过程中。

**示例**

定义嵌套表。

```
CREATE OR REPLACE FUNCTION Fun() RETURNS int AS $$
DECLARE
TYPE ARRAY_INTEGER IS TABLE OF int;   --定义类型
ARRINT ARRAY_INTEGER;   --定义变量
BEGIN
ARRINT[1] := 1;   --通过常量下标给数组赋值
FOR I IN 2..16 LOOP
    select I into ARRINT[I] from dual;  --通过变量下标给数组赋值
END LOOP;
RETURN ARRINT[2];
END;
$$
LANGUAGE plpgsql;
```

返回结果为：

```
CREATE FUNCTION
```

###  PL/pgSQL-TYPE ... IS RECORD

**功能描述**

Vastbase G100 V2.2在PL/pgSQL-TYPE... IS RECORD(...)中支持嵌套定义和使用RECORD类型。

RECORD类型（记录类型）将多个基本数据类型变量组合成一个整体，作为一个复合数据类型使用，可以看做是一种用户自定义数据类型。

**语法格式**

```
TYPE 类型名称 IS RECORD  (成员名称 数据类型 [NOT NULL] :=[默认值][表达式],..);
```

**参数说明**

数据类型为：

- RECORD类型。
- 任意SQL兼容的数据类型（varchar、varchar2、char、int、number……）。
- 行类型table_name%ROWTYPE。
- 复制类型（Copying Types）variable%TYPE。
- 支持nested record类型，nested record指在record类型中嵌套record类型。

**注意事项**

无。

**示例**

1、预先创建测试表并插入数据。

```
CREATE TABLE EMP
(
EMPNO NUMBER(4) NOT NULL,
ENAME VARCHAR2(10),
JOB VARCHAR2(9),
MGR NUMBER(4),
HIREDATE DATE,
SAL NUMBER(7, 2),
COMM NUMBER(7, 2),
DEPTNO NUMBER(2)
);
INSERT INTO EMP VALUES (7369, 'SMITH', 'CLERK', 7902,TO_DATE('17-DEC-1980', 'DD-MON-YYYY'), 800, NULL, 20);
INSERT INTO EMP VALUES (7499, 'ALLEN', 'SALESMAN', 7698,TO_DATE('20-FEB-1981', 'DD-MON-YYYY'), 1600, 300, 30);
INSERT INTO EMP VALUES (7521, 'WARD', 'SALESMAN', 7698,TO_DATE('22-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 30);

CREATE TABLE DEPT
(    DEPTNO NUMBER(2),
DNAME VARCHAR2(14),
LOC VARCHAR2(13)
);
INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES', 'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON ');
```

2、定义和使用嵌套的记录类型1。

```
do language plpgsql $$  DECLARE
TYPE dept_type IS RECORD (
deptno    dept.deptno%TYPE := 80,    -- 定义默认值
dname    dept.dname%TYPE ,
loc    dept.loc%TYPE
) ;
TYPE emp_type IS RECORD (
empno    emp.empno%TYPE ,
ename    emp.ename%TYPE ,
job    emp.job%TYPE ,
hiredate    emp.hiredate%TYPE ,
sal    emp.sal%TYPE ,
comm    emp.comm%TYPE ,
dept    dept_type
) ;
v_emp    emp_type ;
BEGIN
SELECT e.empno,e.ename,e.job,e.hiredate,e.sal,e.comm,d.deptno,d.dname,d.loc INTO
v_emp.empno,v_emp.ename,v_emp.job,v_emp.hiredate,v_emp.sal,v_emp.comm,
v_emp.dept.deptno,v_emp.dept.dname,v_emp.dept.loc
FROM emp e, dept d WHERE e.deptno=d.deptno AND e.empno=7369 ;
RAISE notice '雇员编号：%, 姓名：%, ，职位：%, 雇佣日期：%, 基本工资：%, 佣金：%', v_emp.empno, v_emp.ename, v_emp.job, TO_CHAR(v_emp.hiredate,'yyyy-mm-dd'), v_emp.sal, NVL(v_emp.comm,0); 
RAISE notice '部门编号：%, 名称：%, 位置：%', v_emp.dept.deptno, v_emp.dept.dname, v_emp.dept.loc;
END ;
$$;
```

返回结果为：

```
NOTICE:  雇员编号：7369, 姓名：SMITH, ，职位：CLERK, 雇佣日期：1980-12-17, 基本工资：800, 佣金：0
NOTICE:  部门编号：20, 名称：RESEARCH, 位置：DALLAS
ANONYMOUS BLOCK EXECUTE
```

3、定义和使用嵌套的记录类型2。

```
do language plpgsql $$
DECLARE
TYPE dept_type IS RECORD(
deptno dept.deptno%TYPE := 80,
dname dept.dname%TYPE,
loc dept.loc%TYPE
);
TYPE emp_type IS RECORD(
empno emp.empno%TYPE,
ename emp.ename%TYPE,
job emp.job%TYPE,
hiredate emp.hiredate%TYPE,
sal emp.sal%TYPE,
comm emp.comm%TYPE,
dept dept_type
); 
v_emp emp_type;
v_dept dept_type;
BEGIN
v_emp.dept.deptno := 90;
v_emp.dept.dname := 'ACCOUNTING2';
v_emp.dept.loc := 'NEW YORK';
v_dept := v_emp.dept;
RAISE notice '部门编号：%，名称：%，位置：%',v_dept.deptno,v_dept.dname,v_dept.loc;
END;
$$;
```

返回结果为：

```
NOTICE:  部门编号：90，名称：ACCOUNTING2，位置：NEW YORK
ANONYMOUS BLOCK EXECUTE
```

###  RAISE自定义异常

**功能描述**

RAISE语句用于显式引发异常，在异常处理程序外部，必须指定异常名称外部。

**语法格式**

```
declare
exception_name exception;
begin
raise exception_name;
exception
when exception_name then
--handle the error
end;
```

**参数说明**

exception_name：自定义的异常变量名。

**注意事项**

无。

**示例**

声明自定义异常变量。

```
declare
  past_due exception;
  v_var1 number :=2;
  v_var2 number :=1;
begin
  if v_var1 > v_var2 then
     raise past_due;
  end if;
exception
  when past_due then 
    DBMS_OUTPUT.PUT_LINE('Account past due.');
end;
/
```

返回结果如下，则表示异常声明成功：

```
Account past due.
ANONYMOUS BLOCK EXECUTE
```

### EXCEPTION_INIT预定义异常处理

**功能描述**

使用exception_init可以将自定义异常变量名称预自定义的异常的错误代码关联。

**语法格式**

```
PRAGMA EXCEPTION_INIT (exception_name,error_code)
```

**参数说明**

- exception_name：自定义的异常变量名。

- error_code：自定义错误编码。

**注意事项**

无。

**示例**

1、创建测试表。

```
create table t2(id int not null,name varchar2(50));
```

2、声明预定义的异常处理。

```
declare
e_missingnull exception;
PRAGMA EXCEPTION_INIT(e_missingnull ,-1400);
begin
insert into t2(id) values(null);
exception
when e_missingnull then
dbms_output.put_line(SQLERRM);
rollback;
end;
/
```

返回结果为：

```
ERROR:  null value in column "id" violates not-null constraint
DETAIL:  Failing row contains (null, null).
CONTEXT:  SQL statement "insert into t2(id) values(null)"
PL/pgSQL function inline_code_block line 5 at SQL statement
```

###  RAISE_APPLICATION_ERROR存储过程

**功能描述**

该存储过程用于声明自定义异常编号和错误信息。

**使用流程**

1、RAISE_APPLICATION_ERROR定义异常编号和错误信息。
2、通过exception_init关联异常编号。
3、捕获异常变量。

**语法格式**

```
RAISE_APPLICATION_ERROR(error_code,message[,{TURE | FALSE}]);
```

**参数说明**

- error_code：用户自定义异常变量编号，范围是-20000~20999。
- message：错误信息，允许最长2k的字符串。
- [{TURE | FALSE}]：默认值是TRUE，输出自定义错误信息。当设置为FALSE，输出系统错误信息。

**注意事项**

无。

**示例**

1、声明自定义异常编号和错误信息。

```
create or replace procedure account_status(
due_date DATE,
today DATE
)authid definer
is
begin
if due_date < today then
RAISE_APPLICATION_ERROR(-20000,'Account past due.');
end if ;
end;
/
```

2、调用存储过程。

```
declare
past_due exception;
PRAGMA EXCEPTION_INIT(past_due,-20000);
begin
account_status('2021-10-22','2021-11-22');
exception
when past_due then
dbms_output.put_line(SQLERRM);
end;
/
```

返回结果为：

```
Account past due.
ANONYMOUS BLOCK EXECUTE
```

### 匿名块支持JDBC绑定变量输入输出

**功能描述**

该功能实现了JDBC驱动程序在使用匿名代码块的时候可以绑定变量作为输入输出参数。

**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。
- 只有使用配套的JDBC才可以实现该功能。
- 输入类型支持数值/字符串/日期等数据库常用数据类型。
- 内核输出类型只支持text，JDBC端支持ROWID类型输出。
- 不支持自治事务匿名块绑定变量输入输出。

**使用流程**

1、创建并切换至兼容模式为Oracle的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';    
\c db_oracle
```

2、在数据库中建表。

```
create table t_rowid(a varchar,b int,c float8,d timestamp,e varchar,f varchar);
```

3、JAVA端正常连接数据库后进行如下操作。

（1）匿名块+绑定变量SQL语句。

```
String sql=
  "begin\r\n"+
  "  insert into t_rowid values(?,?,?,?,?,?) returning rowid into ?;\r\n"+
  "insert into t_rowid values(?) returning rowid into ?;\r\n"+
  "select ? into ?;\r\n""+
  "end";
```

(2)输入输出参数声明并执行。

```
try(CallableStatement pstmt = connection.prepareCall(sql)){
      pstmt.setString(1, "hello");
      pstmt.setInt(2, 666);
      pstmt.setDouble(3, 66.66)
      pstmt.setTimestamp(4, new java.sql.Timestamp(new Date() getTime())); pstmt.setString(5, null); 
      pstmt.setString(6, "0");
      pstmt.registerOutParameter(7,Types.VARCHAR); 
      pstmt.setString(8, "你好");
      pstmt.registerOutParameter(9,Types.VARCHAR); 
      pstmt.setString(10, "hello world");
      pstmt.registerOutParameter(11,Types.VARCHAR);
      pstmt.execute();
      String value =pstrmt.getString(7); 
      System.out.println("value:"+value); 
      String val = pstmt.getString(9); 
      System.out.println("value:"+val); 
      String valu = pstmt.getString(11); 
      System.out.println("value:"+valu)
}
```

3、在数据库中执行结果查询。

```
select * fron t_rowid;
```

返回结果为：

```
  a   |   b   |    c  |          d           |    e | f

------+-------+-------+----------------------+------+---
hello |  666  | 66.66 | 2022-01-06 18:23:31:34|     | 0
你好
(2 rows)
```

4、JAVA端接受的结果。

```
value:0EQAAA==AAAAAA==BAA=
value:0EQAAA==AAAAAA==BQA=
value:hello world
```



## VPD功能

**功能描述**

通过添加管理策略功能可针对某个模式schema中的某个对象object（包括table或视图view）添加管理策略。

**语法格式/参数说明**

- 添加VPD策略

```
dbms_rls.add_policy(
        Object_name text, --对象名称
        policy_name text, --策略名称
        policy_function text, --策略函数名称
        object_schema text DEFAULT NULL::text, --对象模式，默认为空
        function_schema text DEFAULT NULL::text, --函数模式，默认为空
        statement_types text DEFAULT 'insert,update,delete,select'::text, --策略作用的语句类型，语句类型使用英文逗号分隔，默认为insert,update,delete,select
        update_check boolean DEFAULT false, --是否启动更新检查，默认为false
        enable boolean DEFAULT true, --是否启用策略
        sec_relevant_cols text DEFAULT NULL:text --敏感列，敏感列使用英文逗号分隔
) RETURN VOID   --返回值为空
```

- 删除VPD策略

```
dbms_rls.drop_policy(
        object_name text, --对象名称
        policy_name text, --策略名称
        object_schema text DEFAULT NULL:text --对象模式，默认为空
) RETURN VOID    --返回值为空
```

- 启动/禁用

```
dbms_rls.enable_policy(
        object_name text, --对象名称
        policy_name text, --策略名称
        enable boolean, --是否启用策略
        object_schema text DEFAULT NULL:text --对象模式，默认为空
) RETURN VOID    --返回值为空
```

**注意事项**

无。

**示例**

1、创建并设置模式为vpd。

```
create schema vpd;
set search_path to vpd;
```

2、创建测试表并插入数据。

```
create table t_vpd (x number);
insert into t_vpd values (1);
insert into t_vpd values (2);
insert into t_vpd values (10001);
insert into t_vpd values (10002);
```

3、创建测试函数。

```
CREATE OR REPLACE FUNCTION vpd.f_limited_query_t(s_schema IN text,s_object IN text)
RETURNS text AS $$
BEGIN
RETURN 'x <= 10000';
END;
$$ LANGUAGE plpgsql;
```

4、添加策略。

```
BEGIN
DBMS_RLS.ADD_POLICY (
object_schema => 'vpd',
object_name => 't_vpd',
policy_name => 'policy_t_vpd_select',
function_schema => 'vpd',
policy_function => 'f_limited_query_t',
statement_types => 'select'
);
END;
/
```

5、启用策略。

```
BEGIN
DBMS_RLS.enable_policy(
object_schema => 'vpd',
object_name => 't_vpd',
policy_name => 'policy_t_vpd_select',
enable => true
);
END;
/
```

6、如下所示：查询会自动带上where条件。

```
explain (COSTS false) select * from t_vpd;
           QUERY PLAN            
---------------------------------
 Seq Scan on t_vpd
   Filter: (x <= 10000::numeric)
(2 rows)
```


## 对象管理

### 触发器

#### 允许INSERT使用oid.colname获取值为空

**功能描述**

兼容Oracle的触发器特性，允许触发器在指定条件下取NULL值。在触发器中，支持使用oid.colname语法获取dml操作之前的旧值，如果之前是insert操作，oid.colname结果为空，如果之前值update和delete操作，oid.colname语法获取的值为操作之前的旧值。


**注意事项**

无。

**示例**

1、创建测试表。

```
CREATE TABLE tri_tbl(id int, name varchar(256));
```

2、创建函数。

```
CREATE OR REPLACE FUNCTION tri_func() RETURNS TRIGGER AS
$$
DECLARE
n_id int := new.id;
o_id int := old.id;
BEGIN
raise notice 'trigger begin: TG_OP is %',TG_OP;
if TG_OP='INSERT' then
raise notice 'old id:%,old name:%',o_id,old.name;
raise notice 'new id:%,new name:%',n_id,new.name;
end if;
return new;
END $$ LANGUAGE plpgsql;
```

3、创建触发器。

```
CREATE TRIGGER be_tri
BEFORE INSERT OR DELETE OR UPDATE
ON tri_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_func();
```

4、调用函数。

```
insert into tri_tbl values(1,'aaaaa');
```

返回结果为：

```
NOTICE:  trigger begin: TG_OP is INSERT
NOTICE:  old id:<NULL>,old name:<NULL>
NOTICE:  new id:1,new name:aaaaa
INSERT 0 1
```

#### 兼容IF Inserting THEN,IF updating THEN,IF deleting THEN

**功能描述**

该功能允许在触发器函数中使用IF Inserting THEN，IF updating THEN和IF deleting THEN命令来判断增加、修改和删除记录的dml操作。

**注意事项**

无。

**示例**

- **IF Inserting THEN**

1、创建测试表。

```
create table  tri_tbl(id int, name varchar(256));
```

2、创建函数。

```
CREATE OR REPLACE FUNCTION tri_func() RETURNS TRIGGER AS
$$
DECLARE
n_id int := new.id;
o_id int := old.id;
BEGIN
raise notice 'trigger begin: TG_OP is %',TG_OP;
if inserting then
raise notice 'old id:%,old name:%',o_id,old.name;
raise notice 'new id:%,new name:%',n_id,new.name;
end if;
return new;
END $$ LANGUAGE plpgsql;
```

3、创建触发器。

```
CREATE TRIGGER be_tri
BEFORE INSERT OR DELETE OR UPDATE
ON tri_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_func();
```

4、调用函数。

```
insert into tri_tbl values(1,'aaaaa'),(2,'bbb');
```

返回结果为：

```
NOTICE:  trigger begin: TG_OP is INSERT
NOTICE:  old id:<NULL>,old name:<NULL>
NOTICE:  new id:1,new name:aaaaa
NOTICE:  trigger begin: TG_OP is INSERT
NOTICE:  old id:<NULL>,old name:<NULL>
NOTICE:  new id:2,new name:bbb
INSERT 0 2
```

- **IF updating THEN**

1、创建测试表并插入数据。

```
CREATE TABLE tri_tbl1(id int, name varchar(256));
insert into tri_tbl1 values(1,null),(1,'bbb');
```

2、创建函数。

```
CREATE OR REPLACE FUNCTION tri_func() RETURNS TRIGGER AS
$$
DECLARE
n_id int := new.id;
o_id int := old.id;
BEGIN
raise notice 'trigger begin: TG_OP is %',TG_OP;
if updating then
raise notice 'old id:%,old name:%',o_id,old.name;
raise notice 'new id:%,new name:%',n_id,new.name;
end if;
return new;
END $$ LANGUAGE plpgsql;
```

3、创建触发器。

```
CREATE TRIGGER be_tri
BEFORE INSERT OR DELETE OR UPDATE
ON tri_tbl1
FOR EACH ROW
EXECUTE PROCEDURE tri_func();
```

4、调用函数。

```
update tri_tbl1 set name='aaaaa' where id=1;
```

返回结果为：

```
NOTICE:  old id:1,old name:<NULL>
NOTICE:  new id:1,new name:aaaaa
NOTICE:  trigger begin: TG_OP is UPDATE
NOTICE:  old id:1,old name:bbb
NOTICE:  new id:1,new name:aaaaa
UPDATE 2
```

- **IF deleting THEN**

1、创建测试表并插入数据。

```
CREATE TABLE tri_tb(id int, name varchar(256));
insert into tri_tb values(1,null),(1,'aaa');
```

2、创建函数。

```
CREATE OR REPLACE FUNCTION tri_func1() RETURNS TRIGGER AS
$$
DECLARE
n_id int := new.id;
o_id int := old.id;
BEGIN
raise notice 'trigger begin: TG_OP is %',TG_OP;
if deleting then
raise notice 'old id:%,old name:%',o_id,old.name;
raise notice 'new id:%,new name:%',n_id,new.name;
end if;
return new;
END $$ LANGUAGE plpgsql;
```

3、创建触发器。

```
CREATE TRIGGER be_tri
BEFORE INSERT OR DELETE OR UPDATE
ON tri_tb
FOR EACH ROW
EXECUTE PROCEDURE tri_func1();
```

4、调用函数。

```
delete tri_tb where id=1;
```

返回结果为：

```
NOTICE:  trigger begin: TG_OP is DELETE
NOTICE:  old id:1,old name:<NULL>
NOTICE:  new id:<NULL>,new name:<NULL>
NOTICE:  trigger begin: TG_OP is DELETE
NOTICE:  old id:1,old name:aaa
NOTICE:  new id:<NULL>,new name:<NULL>
DELETE 2
```

#### 兼容IF UPDATING('col1')

**功能描述**

允许触发器函数中对单个表字段的修改使用IF UPDATING('col1')进行判断单个表字段的更新。

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

**示例**

1、检查数据库兼容模式DBCOMPATIBILITY为A（即兼容Oracle）。

```
show sql_compatibility;
```

2、创建测试表并插入数据。

```
DROP TABLE IF EXISTS tri_tbl;
CREATE TABLE tri_tbl(id int, name varchar(256),note_pad varchar(256));
insert into tri_tbl values(1,null,'aaa');
insert into tri_tbl values(1,null,'aaa');
```

3、创建函数。

```
CREATE OR REPLACE FUNCTION tri_func() RETURNS TRIGGER AS
$$
DECLARE
n_id int := new.id;
o_id int := old.id;
BEGIN
raise notice 'trigger begin: TG_OP is %',TG_OP;
if updating('name') then
raise notice 'old name:%',old.name;
raise notice 'new name:%',new.name;
end if;
if updating('note_pad') then
raise notice 'old note_pad:%',old.note_pad;
raise notice 'new note_pad:%',new.note_pad;
end if;
return new;
END $$ LANGUAGE 'plpgsql';
```

4、创建触发器。

```
CREATE TRIGGER be_tri
BEFORE INSERT OR DELETE OR UPDATE
ON tri_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_func();
```

5、调用函数。

```
update tri_tbl set name='bbb',note_pad='666' where id=1;
```

返回结果为：

```
NOTICE: trigger begin: TG_OP is UPDATE
NOTICE: old name:<null>
NOTICE: new name:bbb
NOTICE: old note_pad:aaa
NOTICE: new note_pad:666
UPDATE 1
```

### 序列

#### SEQUENCE兼容RESTART语法

**功能描述**

SEQUENCE支持restart语法，通过该语法可以重新设置序列的起始值。

**语法格式**

```
ALTER SEQUENCE name RESTART [WITH] number;
```

**参数说明**

- name：序列名称。
- number：序列的起始值。

**注意事项**

无。

**示例**

1、创建一个序列起始值为32。

```
CREATE SEQUENCE sequence_test20 START WITH 32;
```

2、使用nextval返回序列的一个值。

```
SELECT nextval('sequence_test20');
```

返回结果为：

```
 nextval
---------
      32
(1 row)
```

3、修改序列的起始值。 

```
ALTER SEQUENCE sequence_test20 RESTART WITH 22;
```

4、查询修改结果。

```
SELECT nextval('sequence_test20');
```

返回结果为：

```
 nextval
---------
      22
(1 row)
```

#### 兼容NO CACHE、NOCACHE、ORDER、NO ORDER、NOORDER关键字

**功能描述**

提供类似Oracle的序列功能、支持创建（create）或修改（alter）时使用：no cache、nocache、order、no order、noorder。

**语法格式**

- CREATE

```
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] name [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ] [ CACHE cache ] [ NOCACHE ] [ NO CACHE ] [ [ NO ] CYCLE ]
        [ NOORDER ] [ [ NO ] ORDER ] [ OWNED BY { table_name.column_name | NONE } ]

```

- ALTER

```
ALTER SEQUENCE [ IF EXISTS ] name
    [ AS data_type ]
    [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ]
    [ RESTART [ [ WITH ] restart ] ]
    [ CACHE cache ] [ NOCACHE ] [ NO CACHE ] [ [ NO ] CYCLE ]
```

**参数说明**

- no cache、nocache：相当于cache 1（cache：设置缓存的序列值个数）。
- Order：保证序列号按请求顺序产生。如果想以序列号作为timestamp(时间戳)类型的话，可以采用该选项。
- noorder、no order：与order相对，不能保证序列号按请求顺序产生。

**注意事项**

无。

**示例**

1、 创建序列是使用nocache关键字。

```
create sequence SEQ_ID3  
minvalue 1  
maxvalue 99999999  
start with 1  
increment by 1  
nocache
noorder;
```

返回结果如下，则表示序列创建成功：

```
CREATE SEQUENCE
```

2、修改序列。

```
alter sequence SEQ_ID3 order;
```

返回结果如下，则表示修改成功：

```
ALTER SEQUENCE
```

### oracle的包（Package）和包体（Package body）

**功能描述**

Package是一个模式对象，用于组织过程、函数和变量的一种方式，由包声明和包体组成。

**语法格式**

- 包声明

```
CREATE [OR REPLACE] PACKAGE [schema_name.]<package_name> IS | AS
    declarations;
END;
```

- 包体

```
CREATE [OR REPLACE] PACKAGE BODY [schema_name.]<package_name> IS | AS
    declarations
    implementations;
[BEGIN
EXCEPTION]
END;
```

**参数说明**

- 声明包 
  - OR REPLACE：该参数说明如果创建的包存在,则重新创建包。
  - schema_name：包含此包的模式名称。
  - package_name：包的名称。
  - declarations：可以声明公有变量和公有子程序。
- 包体 
  - declarations：声明私有变量和私有子程序。
  - implementations：定义私有子程序和公有子程序。

**注意事项**

无。

**示例**

- 创建包

```
CREATE OR REPLACE PACKAGE emp_bonus AS
PROCEDURE calc_bonus (d date);
END;
/
```

- 创建包体

```
CREATE OR REPLACE PACKAGE BODY emp_bonus AS
PROCEDURE calc_bonus (date_hired DATE) IS
BEGIN
DBMS_OUTPUT.PUT_LINE
('Employees hired on ' || date_hired || ' get bonus.');
END;
END;
/
```

- 删除包体

```
 DROP PACKAGE BODY emp_bonus;
```

### 分区表

####  支持default分区

**功能描述**

针对range，list和hash分区，支持定义和使用default分区。创建分区表的时候可以指定创建default分区，对于已经创建的分区表，可以新增和删除default分区。

Range类型的分区表，可以通过指定分区范围值为MAXVALUE来包含所有情况的值。

Hash类型的分区表，由于Hash分区表的特性，必然可以包含所有情况的值。

**语法格式**

- 创建分区表时指定创建default分区，defaultf分区必须定义为最后一个分区，SQL语法如下：

```
CREATE TABLE [IF NOT EXISTS]table_name
...
PARTITION BY [RANGE | LIST| HASH]({column_name|(expression)})
(
  PARTITION partition_name...,
  PARTITION partition_name VALUES(DEFAULT)[TABLESPACE tablespace_name]
)
```

- 新增default分区(已存在default分区的LIST分区不能新增分区)SQL语法如下：

```
ALTER TABLE table_name ADD PARTITION partition_name VALUES(DEFAULT)
[TABLESPACE tablespace_name];
```

- 删除default分区(不能只剩下一个default分区)SQL语法如下：

```
ALTER TABLE partition_name DROP PARTITION partition_name;
```

**注意事项**

- 该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。
- 在创建分区表时，不能只定义一个default分区并且default分区必须定义在最后。
- 已经存在default分区的分区表，不能新增分区。
- 删除分区时，不能只剩下一个default分区。
- default分区不能进行SPLIT和MERGE操作。

**示例**

1、创建并切换至兼容模式为ORACLE的数据库db_oracle。

```
CREATE DATABASE db_oracle dbcompatibility='A';     
\c db_oracle
```

2、创建一个分区表。

```
create table t_partition_list4(col number,name varchar2(20))
partition by list(col)(
partition t_list_p1 values(1,3,5,7,9) ,
partition t_list_p2 values(2,4,6,8,10) );
```

2、添加一个默认分区并插入数据。

```
alter table t_partition_list4 add partition t_list_default values(default);
insert into t_partition_list4 values(1,'t_list_p1');
insert into t_partition_list4 values(2,'t_list_p2');
insert into t_partition_list4 values(31,'t_list_default');
```

3、查询分区表中的数据。

- 查询分区表中的数据t_list_p1.

```
select * from t_partition_list4 partition(t_list_p1);
```

返回结果为：

```
 col |   name
-----+-----------
   1 | t_list_p1
(1 row)
```

- 查询分区表中的数据t_list_p2。

```
select * from t_partition_list4 partition(t_list_p2);
```

返回结果为：

```
 col |   name
-----+-----------
   2 | t_list_p2
(1 row)
```

- t_list_default

```
select * from t_partition_list4 partition(t_list_default);
```

返回结果为：

```
 col |      name
-----+----------------
  31 | t_list_default
(1 row)
```

#### 支持全局分区索引

**功能描述**

支持创建全局分区索引。分区索引可以分为本地索引（local index）和全局索引（global index），建立分区索引可以分散数据库的IO压力。就像分区表一样，分区索引提高了可管理性、可用性、性能和可伸缩性。它们既可以独立分区(全局索引)，也可以自动链接到表的分区(本地索引)。

**语法格式**

```
CREATE [ UNIQUE ] INDEX [ [schema_name.] index_name ] ON table_name [ USING method ]
( {{ column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS LAST ] }[, ...] )
[GLOBAL] ；
```

**参数说明**

- UNIQUE： 指定 UNIQUE为唯一值索引
- schema_ma：方案名称。
- index_name：自定义的索引名称。
- table_name：创建索引所基于的表的名称。
- ASC|DESC：创建索引时指定按照升序或者降序进行排序，ASC：升序，DESC：降序。
- GLOBAL：指定创建的索引为全局索引

**注意事项**

无。

**示例**

1、创建一个测试分区表。

```
create table t_part_1(
id int,
col int
)
partition by range (id)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30),
partition p4 values less than (maxvalue)
);
```

2、创建全局分区索引。

```
create index idx_tp_1 on t_part_1(id) global;
```

当结果返回如下，则表示全局索引创建成功：

```
CREATE INDEX
```

#### 兼容interval分区表

**功能描述**

interval分区是range分区的扩展。

在没有自动interval分区特性之前，在创建范围Range类型分区表时，我们通常会定义一个maxvalue分区，将没有落在当前关注范围内的数据，都放到该分区中，以避免插入的元组的分区键值不能映射到任何分区的错误。然而当业务场景发生变化时，如果没有及时根据数据增长创建新的分区，就可能会导致分区表的数据发生倾斜，大多数数据都放到了这个未进行细分的maxvlaue分区中，这就违反了我们对表进行分区的初衷，我们希望各个分区的数据量均衡，这样才能加快查询。
自动interval分区可以改善这个问题，对于连续数据类型的Range分区，如果插入的新数据值与当前分区均不匹配，它可以自动创建分区。

**语法格式**

```
CREATE TABLE table_name
(
  ...
)
PARTITION BY RANGE(column1)
INTERVAL (expr) 
(
  PARTITION partition_name1 VALUES LESS THAN(literal | MAXVALUE) [TABLESPACE tablespace1],
  PARTITION partition_name2 VALUES LESS THAN(literal | MAXVALUE) [TABLESPACE tablespace2]
);
```

**参数说明**

- PARTITION BY RANGE(column1)：指定一个range分区的列。
- INTERVAL：指定分区间隔。
- expr：字符串类型，指定时间间隔值。

**注意事项**

无。

**示例**

1、创建interval分区表。

```
CREATE TABLE interval_normal_exchange (logdate date not null)
PARTITION BY RANGE(logdate)
INTERVAL('1 month')
(
        PARTITION interval_normal_exchange_p1 VALUES LESS THAN('2020-03-01'),
        PARTITION interval_normal_exchange_p2 VALUES LESS THAN('2020-04-01'),
        PARTITION interval_normal_exchange_p3 VALUES LESS THAN('2020-05-01')
);
```

2、执行以下语句查询分区情况。

```
SELECT relname,parttype,partstrategy,boundaries FROM pg_partition 
WHERE parentid = (SELECT oid FROM pg_class WHERE relname = 'interval_normal_exchange')
ORDER BY relname;
```

返回的分区情况如下:

```
           relname           | parttype | partstrategy |  boundaries
-----------------------------+----------+--------------+--------------
 interval_normal_exchange    | r        | i            |
 interval_normal_exchange_p1 | p        | r            | {2020-03-01}
 interval_normal_exchange_p2 | p        | r            | {2020-04-01}
 interval_normal_exchange_p3 | p        | r            | {2020-05-01}
(4 rows)
```


## 闪回/闪回查询

**功能描述**

在使用表的过程中，可能会出现误删，或者误改数据，此时闪回查询可以通过语句找回INSERT，UPDATE，DELETE操作之前的数据，看到修改表数据前或者删除数据前的数据装填，支持指定时间的闪回查询操作。

**注意事项**

- track_commit_timestamp设置为on。

- autovacuum设置为off。

- 数据表truncate后无法闪回。

- 闪回时间点的数据没有被autocacuum回收。


**使用步骤**

1、修改postgresql.conf，添加参数max_flashback_time，开启闪回功能，并重启数据库。

```
例如设置max_flashback_time=60，即最多允许闪回至60秒之内。
vim postgresql.conf
vb_ctl reatart
```

2、开启自动提交。

```
\set AUTOCOMMIT on
\echo :AUTOCOMMIT
```

3、创建测试表并查询表中数据。

```
create table t_a (col1 int, col2 char(20),col3 char(20));
insert into t_a values(1,'aa','a1');
insert into t_a values(2,'bb','b1');
insert into t_a values(3,'cc','c1');
SELECT * FROM t_a;
```

返回结果为：

```
 col1 |         col2         |         col3         
------+----------------------+----------------------
    1 | aa                   | a1                  
    2 | bb                   | b1                  
    3 | cc                   | c1                  
(3 rows)
```

4、修改表中的数据并查询结果。

```
select pg_sleep(17);
insert into t_a values (4,'dd','d4');
SELECT * FROM t_a;
```

返回结果为：

```
col1 |         col2         |         col3         
------+----------------------+----------------------
    1 | aa                   | a1                  
    2 | bb                   | b1                  
    3 | cc                   | c1                  
    4 | dd                   | d4                  
(4 rows)
```

5、进行闪回查询。

```
select *  from t_a FLASHBACK(15);
 col1 |         col2         |         col3         
------+----------------------+----------------------
    1 | aa                   | a1                  
    2 | bb                   | b1                  
    3 | cc                   | c1                  
(3 rows)
```

6、将表闪回至15秒之前。

```
select pg_flashback('t_a',15);
select *  from t_a;
 col1 |         col2         |         col3         
------+----------------------+----------------------
    1 | aa                   | a1                  
    2 | bb                   | b1                  
    3 | cc                   | c1                  
(3 rows)

```

## OCI/OCCI接口

**功能描述**

支持Oracle Call Interface和Oracle C++ Call Interface的函数，具体见下表：

| 函数                   | 描述                                                         |
| :--------------------- | ------------------------------------------------------------ |
| OCILogon               | 创建一个简单的登录会话                                       |
| OCILogoff              | 释放使用OCILogon登录的会话                                   |
| SQ                     | 执行模块实现函数                                             |
| OCIStmtPrepar          | 函数实现准备要执行的SQL或PL / SQL语句                        |
| OCIBindByPos           | 在SQL语句或PL / SQL块中的程序变量和占位符之间创建关联        |
| OCIBindByName          | 函数实现在SQL语句或PL / SQL块中的程序变量和占位符之间创建关联 |
| OCIBindArrayOfStruct   | 函数实现为静态数组绑定设置跳过参数                           |
| OCIDefineByPos         | 函数实现将选择列表中的项目与类型和输出数据缓冲区关联         |
| OCIDefineArrayOfStruct | 指定在多行多列结构读取数组中使用的静态数组定义所必需的其他属性 |
| OCIStmtExecute         | 函数实现将应用程序请求与服务器关联                           |
| OCIStmtFetch           | 函数实现从查询中获取行                                       |
| OCITransStart          | 函数实现设置事务开始                                         |
| OCITransCommit         | 函数实现事务提交                                             |
| OCITransRollback       | 函数实现事务回滚                                             |
| OCIHandleAlloc         | 函数返回指向已分配和初始化的句柄的指针                       |
| OCIHandleFree          | 函数实现该调用显式取消分配句柄                               |
| OCIErrorGet            | 在提供的缓冲区中返回错误消息和Oracle数据库错误代码           |
| OCIDateToText          | 函数实现将日期类型转换为字符串                               |
| OCINumberFromText      | 函数实现将number类型转换为字符类型                           |
| OCINumberFromReal      | 函数实现将浮点类型转化为number类型                           |
| OCINumberfromInt       | 函数实现将int类型转换为number类型                            |
| OCIDateSysDate         | 函数实现获取客户端的当前系统日期和时间                       |
| OCIDateCompare         | 函数实现两个日期进行比较                                     |
| OCINumberCmp           | 函数实现将两个number类型进行比较                             |
| OCINumberAdd           | 函数实现将两个number类型值进行相加                           |
| OCINumberSub           | 函数实现将两个number类型值进行相减                           |
| OCINumberMul           | 函数实现将两个number类型值进行相乘                           |
| OCINumberDiv           | 函数实现将两个number类型值进行相除                           |
| OCIParamGet            | 函数返回由描述句柄或语句句柄中的位置指定的参数的描述符       |

**注意事项**

该功能仅在数据库兼容模式为Oracle时能够使用（即创建DB时DBCOMPATIBILITY='A'），在其他数据库兼容模式下不能使用该特性。

# PostgreSQL兼容性

## TO_REGCLASS函数

**功能描述**

to_regclass函数，用以判断表对象是否存在。

**语法格式**

```
to_regclass ( text )
```

**参数说明**

text：支持所有的文本字符、字符数组（字符串）类型，函数入参必须保障需要支持的数据类型有：

| 名称                              | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| CHAR(n)、CHARACTER(n)、 NCHAR(n)  | 定长字符串，不足补空格。n是指字节长度，如不带精度n，默认精度为1。 |
| VARCHAR(n) 、CHARACTER VARYING(n) | 变长字符串。n是指字节长度。                                  |
| VARCHAR2(n)                       | 变长字符串。是VARCHAR(n)类型的别名。n是指字节长度。          |
| NVARCHAR2(n)                      | 变长字符串。n是指字节长度。                                  |
| CLOB                              | 文本大对象。是TEXT类型的别名。                               |
| TEXT                              | 变长字符串。                                                 |
| VARCHAR                           | 变长字符串。                                                 |
| CHAR                              | 单字节内部类型                                               |
| NAME                              | 用于对象名的内部类型。                                       |

注：其他的数据类型，只要能完成向text类型的隐式转换，在Vastbase中就是合法的。

**注意事项**

- 函数输入：类型是text，格式是[[catalogname.]schemaname.]relname；根据search_path顺序查找，并且查找的是relation。

- 函数返回：类型是regclass。

- 输入输出遵循现有的隐式类型转化规则，隐式类型转化可以在pg_cast系统表中查看。

- 具备该函数的访问权限，例如to_regclass函数如果位于pg_catalog模式下，用户需要具备以下权限：

  - pg_catalog模式的usage权限。

  - to_regclass函数的excute权限。


**示例**

1、创建测试表。

```
create table table_exit(id int);
```

2、验证函数。

```
select  to_regclass('table_exit');
```

结果返回如下：

```
  to_regclass
-------------
  table_exit
(1  row)
```

## 游标（CURSOR）语法

**功能描述**

游标（cursor）是数据库系统在内存中开设的一个数据缓冲区，存放SQL语句的执行结果。

**语法格式**

- Oracle类型和PG类型语法：

```
name [ [ NO ] SCROLL ] CURSOR [ ( arguments ) ] FOR query;
```

- Vastbase类型语法：

```
CURSOR name [ [ NO ] SCROLL ] [ ( arguments ) ] FOR query;
```

**参数说明**

- name：游标变量的名称。

- [NO] SCROLL：如果指定了SCROLL特性，则表示游标的光标可以向后滚动（回滚）。如果使

  用 NO SCROLL则游标不能回滚。如果两个关键字都没有出现，则是否允许反向回迁取决于查询。

- CURSOR：关键字，指明变量是游标类型。

- [ ( arguments ) ]：如果指定了arguments，则是一个逗号分隔的对名称数据类型列表，起到类

似绑定变量作用。

- FOR：关键字，表示后面的语句为游标定义的内容，可以被IS取代。
- query：查询语句，包含各种关联查询和子查询。

**注意事项**

- 该功能仅在数据库兼容模式为Oracle类型和PG类型时能够使用（即创建DB时DBCOMPATIBILITY='A'或者'PG'），其他类型数据库兼容模式保持原有语法不做改动。
- 在Vastbase使用游标（CURSOR）语法时，仅需要在Oracle类型和PG类型语法基础上调换变量名与类型关键字的顺序即可在Vastbase中实现该功能。

**示例**

- Oracle兼容模式的数据库中。

```
CREATE OR REPLACE procedure a()  as
     CURSOR c_id FOR  select * from tt; 
BEGIN
    select 2*3 from dual;
END;
/
```

- PG兼容模式的数据库中。

```
CREATE OR REPLACE procedure a()  as
     CURSOR c_id FOR  select * from tt; 
BEGIN
    select 2*3 from dual;
 END;
/
```







